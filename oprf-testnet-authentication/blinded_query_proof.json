{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"5492901140906425798","abi":{"parameters":[{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"beta","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"babyjubjub::BabyJubJubPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"285034277038352717":{"error_kind":"string","string":"Edwards add y-coordinate constraint failed"},"819864067177566446":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2535200074311762945":{"error_kind":"string","string":"Point must be on curve"},"4113444419942717674":{"error_kind":"string","string":"b must be a square root of na or a"},"9537330626372423756":{"error_kind":"string","string":"Field failed to decompose into specified 251 limbs"},"9573319718572995577":{"error_kind":"string","string":"y must be a square root of gx"},"12462572295873618800":{"error_kind":"string","string":"Beta cannot be zero"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"13573753826873208116":{"error_kind":"string","string":"Edwards add x-coordinate constraint failed"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17520344586198764996":{"error_kind":"string","string":"InverseOrZero zero constraint 1 failed"},"17552704699056728709":{"error_kind":"string","string":"InverseOrZero zero constraint 2 failed"},"18273966037014093413":{"error_kind":"string","string":"l must be in {-1,0,1}"}}},"bytecode":"H4sIAAAAAAAA/+x9B3wVVfftHdITQlWalEvoJfQmHZFepUlTOiq9KCCKFBVEQCkhRgMREwhgFEILXYEASmiCiEhHVLo0RZrwZg+TL5c4YWbtyTn3vvdyfr958/7n23fOOvvsss4CVXE8Gt76e3Cv14ZMKeNw9M/z6P9W1MdLf9PwTzWnGMxlMpjzMpjzNpjzMZjzNZjzM5jzN5gLMJgLNJgLMpjLbDAXbDCXxWAuq8FcNoO57AZzOQzmchrMPWUw97TBXC6DudwGc3kM5vIazOUzmHvGYC6/wVwBg7mCBnOFDOacBnOFDeZCDOaKGMwVNZgrZjBX3GCuhMFcSYO5UgZzpQ3myhjMlTWYCzWYK2cwV95groLBXEWDuUoGc5UN5qoYzFU1mKtmMFfdYK6GwdyzBnM1DeZqGczVNpirYzBX12CunsFcfYO5BgZzzxnMNTSYe95grpHBXGODuSYGc00N5poZzDU3mGthMNfSYK6VwVxrg7k2BnNtDeZeMJhrZzDX3mCug8FcR4O5TgZzLxrMdTaY62Iw19VgrpvBXHeDuZcM5l42mOthMNfTYK6XwVxvg7k+BnN9Deb6Gcz1N5h7xWDuVYO51wzmBhjMDTSYG2QwN9hgbojB3FCDuWEGc8MN5kYYzI00mHvdYO4Ng7lRBnOjDebGGMy9aTA31mDuLYO5tw3mxhnMvWMwN95gboLB3ESDuUkGc+8azL1nMPe+wdxkg7kpBnMfGMxNNZj70GBumsHcdIO5GQZzHxnMfWwwN9NgbpbB3GyDuTkGc2EGc3MN5sIN5j4xmIswmPvUYO4zg7lIg7l5BnPzDeaiDOY+d5nz1d9O/V1Yf4fo7yL6u6j+Lqa/i+vvEvq7pP4upb9L6+8y+rus/g7V3+X0d3n9XUF/V9TflfR3Zf1dRX9X1d/V9Hd1/V1Dfz+rv2vq71r6u7b+rqO/6+rvevq7vv5uoL+f098N9ffz+ruR/m6sv5vo76b6u5n+bq6/W+jvlvq7lf5urb/b6O+2+vsF/d1Of7fX3x30d0f93Ul/v6i/O+vvLvq7q/7upr+76++X9PfL+ruH/u6pv3vp7976u4/+7qu/++nv/vr7Ff39qv5+TX8P0N8D9fcg/T1Yfw/R30P19zD9PVx/j9DfI/X36/r7Df09Sn+P1t9j9Peb+nus/n5Lf7+tv8fp73f093j9PUF/T9Tfk/T3u/r7Pf39vv6erL+n6O8P9PdU/f2h/p6mv6fr7xn6+yP9/bH+nqm/Z+nv2fp7jv4O099z9Xe4/v5Ef0fo70/192f6O1J/z9Pf8/V3lCOlFtDbob+Tn0z6O7lmeOtvH/2dXDf89HdyPQnQ34H6O0h/Z9bfwfo7i/7Oqr+z6e/s+juH/s6pv5/S30/r71z6O7f+zqO/8+rvfPr7Gf2dX38X0N8F9Xchfe9Oh6WhxKSeYPw+2bZC39YjzlRcUGpd20YJEyd2fqlk5fNN31w/bFbDM3/PueZ45HPycyaDD/mD6zot2ypaD7BkqzzqE1ZsyU9FrNlqLi1qyfaR94tZsdUPqrgF2+QzLeGw6Ic0htNhaZnHzneh/l6UbJGcgPQ/fJNqjozqp/pqoLXF/wfC6cgIDBrcwEgjiWfqSawsNLf9X8Ivclj0b6qRHEBOi+sgmGId/8WU1m9cY5N+R/FKRSy5SaQeig3cVrAkj8V2Flxs4GCzxRc7rCfgEgAPdw9LHGl3qrR+v8SBBWNa30/LfJGOK5PF39UuGDgo68OHDxF/LXVY34Nr8NLv6GaQnh24pGVbRbtFWbJVHt20rNjSvspYs9WOsqwl20enHmrFVg+QchZsk2OpvMOiH9IYToelZR473y/1d1yyRXJQ0P+QugOTUf1UX0U7cEZgPHpxA8OsA39pbvu/ghHnsOjfVAPtwAimrxy8Dky/S+8O/CWIJXl8bWfBrx14B/7aYT0BlwF4uHtY5sA78DKH2A4cp+NCOzDir+UO63twDV76XXp34AqWbRVNh7RkqzzSKq3Y0r4qW7PVjrKKJdtHp17Viq0eINUs2CbHUnWHRT+kMZwOS8s8dr7x+ntFskVyUND/kLoDk1H9VF9FO3BGYDx6cQPDrAPHm9v+r2CscFj0b6qBdmAE00oHrwPT79K7A8eDWJLHKjsLrnLgHXiVw3oCrgbwcPew2oF34NUOsR14hY4L7cCIv9Y4rO/BNXjpd+ndgWtYtlW0P8mzZKs8+tM+K7a0r1rWbLWjrG3J9tGp17FiqwdIXQu2ybFUz2HRD2kMp8PSMo+db4L+XptskRwU9D+k7sBkVD/VV9EOnBEYj17cwDDrwAnmtv8rGGsdFv2baqAdGMG0zsHrwPS79O7ACSCW5LHezoLrHXgHXu+wnoAbADzcPWxw4B14g0NsB16r40I7MOKvjQ7re3ANXvpdenfg+pZtFe3vwliyVR79fRkrtrSvhtZstaN83pLto1NvZMVWD5DGFmyTY6mJw6If0hhOh6VlHjvfTfp7c7JFclDQ/5C6A5NR/VRfRTtwfUdGYNDgBoZZB95kbvu/grHZYdG/qQbagRFM3zh4HfgbR/p34E0gluTxrZ0Fv3XgHfhbh/UE3ALg4e5hiwPvwFscYjvwZh0X2oG3OKzvfavD+h5cg5d+l94duKllW0X726SWbJVHf+PUii3tq4U1W+0oW1qyfXTqrazY6gHS2oJtciy1cVj0QxrD6bC0zGPnu01/JyZbJAcF/Q+pOzAZ1U/1VbQDZwTGoxc3MMw68DZz2/8VjESHRf+mGmgHRjBtd/A6MP0uvTvwNhBL8thhZ8EdDrwD73BYT8CdAB7uHnY68A680yG2AyfquNAOjPjrO4f1PbgGL/0uvTtwW8u2ivbPY1iyVR79MxtWbGlf7a3ZakfZwZLto1PvaMVWD5BOFmyTY+lFh0U/pDGcDkvLPHa+3+vvXckWyUFB/0PqDkxG9VN9Fe3AGYHx6MUNDLMO/L257f8Kxi6HRf+mGmgHRjAlOXgdmH6X3h34exBL8thtZ8HdDrwD73ZYT8A9AB7uHvY48A68xyG2A+/ScaEdGPHXXof1PbgGL/0uvTtwZ8u2ivZPNFqyVR79U49WbGlf3azZakfZ3ZLto1N/yYqtHiAvW7BNjqUeDot+SGM4HZaWeex89+nv/ckWyUFB/0PqDkxG9VN9Fe3AGYHx6MUNDLMOvM/c9n8FY7/Don9TDbQDI5h+cPA6MP0uvTvwPhBL8jhgZ8EDDrwDH3BYT8CDAB7uHg468A580CG2A+/XcaEdGPHXjw7re3ANXvpd8r+nIPmfq16kv+P09wr9vdaR8keC9E50pFyPkou0lf25wID8nmFrzXYCYIt8N8P28XFIfX5Sn8Pq87P6HFGfX9TnqPocU5/j6nNCfU6qzyn1Oa0+Z9TnV/U5qz6/qc/v6vOH+pxTn/Pqc0F9LqrPJfW57Ej5dy16GayP1qFDDswPqYfTmpk//7fK//akuHzoivr8qT5X1Ydq3XX1uaE+N9Xnr2Tj5IJ2xfHffynNnwZzVw3mrhnMXTeYu2Ewd9Ng7i/Hf70RADnk8UMzawJXLNpeffhQ+dOyrUO5atVWxXvNmu1sYozXLdn+pbHLG1ZsTz9iojct2D6ns9a/HNaTIj2T8SfrtobDac0s3ZPxb/W5pT7/qM9t9bmjPnfV55763E82Tk6Avx3/TYpbBnP/GMzdNpi7YzB312DunsHcfYf9ZHQ9NLNk/NvhsJyMtyzbOpR/rNqqeG9bs9WS8Y4l20fJeNeKrZ6M9yzYJifjfYd7kvGwdVvD4bRmlu7J+K/6PFCfh/r/oKhPJvXxUh9vxfF4Avzr+G9SPDCYe2gwR/9P6jnFYC6TwZyXwZy3Yj8ZXQ/NLBn/tWhLyfjAsq1DeWjVVj9BC7ZaMiqWbB8lYyYrtnoyelmwTU5Gb8U9yfizdVvD4bRmlu7J6KP+H77q40exrT4B6hOoPkHqkzl1MvoYJIWvwZyfwZy/wVyAwVygwVyQwVzmdEhG10MzS0Yfa4mgJaOvZVuH4mfVVsXrDyRjAJCMgUAyBgHJmBlMRqtCpMlQFli3fWy9YMXGgsEuX3Lqb7Og8jYA4bCBwaLtY3+kkUVfKGvqbKf/YUKquazK40qNw5FSPp0OHKiZg7KkHW3dU9kqWcFo01r/E2ycacynXtf1f0MPLYvCi9RsqQ+LJlJHUeqDQZz9hLX/B8Dqd7Mrlp352J6yWwg2s7WzAjiRPeV4wp5S/9Z1Tzn0PdkJwLi6V9Y96/wz8JURnxx/tnDx667/m6wAzJk6AHNKDsCcwGE9pVh25jXXPT0lOQCRPT39hD35Zp66r3vxKj7VA/0TfqhQJsh1T0+7BGB6kd8F1m0Nh9Oa2T0bv83k2tqTP5RL/T9yq08e9cmrPvnU5xn1ya8+BdSnoPoUIj+rT2H1CVGfIupTVH2KqU9x9SmhPiXVp5T6lFafMupTVn1C1aec+pRXnwrqU1F9KqlPZfWpoj5V1aea+lRXnxrq86z61FSfWupTW33qqE9d9amnPvXVp4H6PKc+DdXnefVppD6N1aeJ+jRVn2bq01x9WqhPS/VppT6t1aeN+rRVnxfUp536tFefDurTUX06qc+L6tNZfbqoT1f16aY+3dWHqtbL6tNDfXqqTy/16a0+fdSnr/r0U5/+6vOK+ryqPq+pzwD1Gag+g9RnsPoMUZ+h6jNMfYarzwj1Gak+r6vPG+ozSn1Gq88Y9XlTfcaqz1vq87b6jFOfd9RnPMWr+kxUn0nq8676vKc+76vPZPWZoj4fqM9U9flQfaapz3T1maE+H6nPx+ozU33oT5xnq88c9QlTn7nqE64+n6hPhPp8qj6fqU+k+sxTn/nqE6U+n6vPAvX5Qn2i1SdGfRaqzyL1iVWfxeqzRH2Wqs+X6hOnPl+pz9fqs0x9lqtPvPqsUJ+V6rNKfVarzxr1SVCfteqzTn3Wq88G9dmoPpvUZ7P6fKM+36rPFvXZqj7b1CdRfbarzw712ak+36nP9+qzS32S1Ge3+uxRn73qs0999qvPD+pzQH0Oqs+P6nNIfX5Sn8Pq87P6HFGfX9TnqPocU5/j6nNCfU6qzyn1Oa0+Z9TnV/U5qz6/qc/v6vOH+pxTn/Pqc0F9LqrPJfW5rD5X1OdP9bmqPlRUr6vPDfW5qT5/qc/f6nNLff5Rn9vqc0d97qrPPfW5rz7/qs8D9XmoOLQuqahPJvXxUh9v9fFRH1/18VMff/UJUJ9A9QlSn8zqE6w+WdQnq/pkS/0v76bEV1LN5TaYy2Mwl9dgLp/B3DMGc/kN5goYzBU0mCtkMOc0mCtsMBdiMFfEYK6owVwxg7niBnMlDOZKGsyVMpgrbTBXxmCurMFcqMFcOYO58gZzFQzmKhrMVTKYq2wwV8VgrqrBXDWDueoGczUM5p41mKtpMFfLYK62wVwdg7m6BnP1DObqG8w1MJh7zmCuocHc8wZzjQzmGhvMNTGYa2ow18xgrrnBXAuDuZYGc60M5lobzLUxmGtrMPeCwVw7g7n2BnMdDOY6Gsx1Mph70WCus8FcF4O5rgZz3QzmuhvMvWQw97LBXA+DuZ4Gc70M5nobzPUxmOtrMNfPYK6/wdwrBnOvGsy9ZjA3wGBuoMHcIIO5wQZzQwzmhhrMDTOYG24wN8JgbqTB3OsGc28YzI0ymBttMDfGYO5Ng7mxBnNvGcy9bTA3zmDuHYO58QZzEwzmJhrMTTKYe9dg7j2DufcN5iYbzE0xmPvAYG6qwdyHBnPTDOamG8zNMJj7yGDuY4O5mQZzswzmZhvMzTGYCzOYm2swF24w94nBXITB3KcGc58ZzEUazM0zmJtvMBdlMPe5wdwCg7kvDOaiDeZiDOYWGswtMpiLNZhbbDC3xGBuqcHclwZzcQZzXxnMfW0wt8xgbrnBXLzB3AqDuZUGc6sM5lYbzK0xmEswmFtrMLfOYG69wdwGg7mNBnObDOY2G8x9YzD3rcHcFoO5rQZz2wzmEg3mthvM7TCY22kw953B3PcGc7sM5pIM5nYbzO0xmNtrMLfPYG6/wdwPBnMHDOYOGsz9aDB3yGDuJ4O5wwZzPxvMHTGY+8Vg7qjB3DGDueMGcycM5k4azJ0ymDttMHfGYO5Xg7mzBnO/Gcz9bjD3h8HcOYO58wZzFwzmLhrMXTKYu2wwd8Vg7k+DuasGc9cM5q4bzN0wmLtpMPeXwdzfBnO3DOb+MZi7bTB3x2DursHcPYO5+wZz/xrMPTCYe2gwpwlTqeYUg7lMBnNeBnPeBnM+BnO+BnN+BnP+BnMBBnOBBnNBBnOZDeaCDeayGMxlNZjLps+5jvv62+mwNKA/Tibdz4rt1YcPH+a2bvtvHuu2d/Jat72ez7rtmWes227Nb912YgHrtkpBy7YPlEKWbe8rTsu2t5XClm2vKSGWbU8rRSzbblGKWradoBSzbOtQilu1feBQSli1ve9QSlq1ve1QSlm1veZQSlu1Pe1Qyli13eJQylq1neBQQq3aqrWknEXbP1Xb8hZtL6u2FSzanldtK1q0Pa3aVrJo+4NqW9mibbxqW8Wi7TDVtqo1W+0vpVWzZjuLbKtbs/2YbGtYs51Gts9as32XbGtasx1JtrWs2bYn29rWbHOSbR1Lto/+Il9dS7Y3Ndt6lmyva7b1Ldle0WwbWLL9XbN9zpLtT5ptQ0u2azTb5y3ZvqHZNrJiq//lx8ZWbE89sm1ixfbEI9umVmx/eWTbzIrtgUe2za3Ybn1k28KK7RePbFtase31yLaVBdvkvzDa2oJtA922jQXberptWwu2tXTbFyzYVtZt21mwLaLbtrdg66XbdjC3nZmo23a0YJv8VxU7mdt+nGz7orntjGTbzua2U5Ntu5jbTky27WpuOzzZtpu57QvJtt3NbbMn275kajv0f38V9GVT2yH/s+1hajvof7Y9TW1f/Z9tL1Pbnv+z7W1q2/Z/tn1MbSv8z7avme26a/+z7Wdqm/JXbfub2a5NsX3FzHZNiu2rZrYrUmxfM7NdmmI7wMz20xTbgWa2b6bYDjKzfTbFdrCJ7RiXv8o8xMR2tIvtUBPbN1xsh5nYDnexHW5i+5qL7QgT2y4utiNNbJ91sX39ybZN7rjYvmFi6/pXxUc92baxq+3oJ9s+72o75sm29V1t33yybQ1X27FPti3pavvWk239XW3ffqLtue9dbcc92faxv4r/zhNt/3jMdvwTbX97zHbCE21PP2Y78Ym2Rx6znfRE2+8fs333ibZLHrN974m2rz5m+/6TbCs9/o86TH6SbcXHbac8ybb847YfPMm2zOO2U59kW+Rx2w+fZJvzcdtpT7AtcfNx2+lPsl31uO2MJ9mm+kdJPnqCbfFUth8/wbZoKtuZT7B1prKd9QTbPKlsZz/B1j+V7Zy0bbufT2Ub9gTbJals5z7BNpX+q4Snbdstte0nadt2SW0bkbZtx9S2n6Zt2yq17Wdp29ZJbRuZtm2B1Lbz0rR98URq2/lp276U2jYqTdtO/7H9PE3bDv+xXZCmbdv/2H6Rpm3T/9hGp2lb4z+2MWna5vmP7cK0bCcc+Y/tojRtO//HNjYt2/H/tV2clu24/9ouScv2zf/aLk3Ldvh/bb9My7bXf23j0rJt8F/br9KyVf5r+3UathMm/td2WRq24w1sl6dhO87ANj4N2zcNbFekYTvcwHZlGra9DGxXpWHbwMB2dRq2ioHtGmPbNRMNbBOMbVcb2a41tl1pZLvO2HaZke16Y9tYI9sNxrbhRrYbjW1HGdluMratZmS72dD2+QQj228MbRsa2n5raNvA0HaLoW0dQ9uthrZVDW23GdoWM7RNNLT1MbTdbmTbZoeh7Q5D20aGtjuNbFsb235nZNvS2PZ7I9umxra7jGzrG9smGdlWMLbdbWSbzdh2j4Ht2h+Mbfca2bY1tt1nYJuQhu1+A9vVadj+YGAbn4btAQPbJWnYHjSwjUjD9kcD2zFp2B4ysK2Rhu1P/7UtuS4N28P/tS2Rlu3P/7Utlpbtkf/aFk7L9pf/2uZNy/bof20D0rI99h/bzy+kZXv8v7ZL07I98V/bUmnZnvyPbVSatqf+YzsvTdvT/7GNSNP2zH9sZ6Zp++t/bCekaXv2P7Y907T97T+2zjRtf09tW2FBmrZ/pLYtn7btudS2oWnbnk9tWypt2wupbQunbXsxtW32tG0vpbI9fT1t28upbVekbXsltW3FtG3/TGV76gm2V1PZnniC7bVUtr88wfZ6KtsDT7C9kcp26xNsb6ay/eIJtn+lsu31BNu/H7cdfuYJtrcetx32JNt/Hrcd8iTb24/bDniS7Z3HbXs/yfbu47btnmR773HbSk+yvf+YbasbT7L993HbEU+yffCYbcsn2j58zLb5E23p73mm2DZ+oq3ymG3dJ9pmesy23BNtvR6zzfJEW29X2z77nmjr85ht6yfa+rra9n6yrZ+rbc8n2/q72nZ/sm2Aq22HJ9sGuto+/2TbIFfbok+2zexiW/63J9sGu9r2fbJtFhfbcia2WV1sy5rYZnOxRYbJf61CST3xpH8VZmrjf59gm9r4wZNsUxk/fKJtKmPlyX5xNVZMbF2NM5nZuhh7mdqmGHv/lw+ndeaOybl4Z55ZfzufBMRl3EnD1sj4blq2Bsb3HOb4k3/lo1jYq27sa8VWN/azZPvI2N+arWYcYNGWjAOt2qrGQZZtH/+X85nF0hRmLHnpb6fFdbJbr1MKEN+KK/4CvgOKdUzoHJ1nXt9BxZt+vS9z74jNHUY2rVNwTnmfbp/lOKr9IBVus+8T7uyZ/vs7s/3mAOsyiou+n4OBK2cmOef9lPV1MgHnncn1vEsdvbqmxzfv5LkR1fZBjyprPn5QoW+P0TtvX8s7b//mqqOmjSAb1K+E+ymGX58WfN70/acZuHJJOu/cEvK7UNkVvZt/X7ddvzLOyy23lRk28HjtY4NbRK1QvHe0yvHwxcraD1LhNvs+4c7N8GsewedN38/DwJVXLK5MVAtzMnB9kEusvyhnczFwTRWMi2IrLwPXh8y+7A2ukw/IW+AMFcCviuteA78u9+b1F6ve2Dx6y5U6T31ZYkWhgNLtN+48c8x3xMkjbSr+rv1At3Va/D7tMR/jDJ4RnOP0/WcYuPJnkhMbBVzWyVOpxLPDIn546njJkGP1t3xVLizvX0VrH1/X9Itrd3fdxmIjEzc2Qtr1bjM598jph2/1OlE/rHqP6pk+jLh+cl//gPz7n567ul5J7Qep9mj2fdpjAcYZFBQcG/T9ggxchSTFhlNMbCB1I5NrbOQrOqvm7Gk1mnbtt6R5qQJfPJy1zbd4uxZlphz6vE3ZmXl+rqp9PNUezbBoe2ScQWHBsUHfL8zAFSKYG1CNzc/ANU1wD6b8LsTANV0wLoqtEAauGZK4QRGAGwBnqAB+VVz3GnK/8ce5u6xt9db9597qkf3SisAGL7x06q9PVrQ5fPRM24+3j9V+oNs6LX6f9liEcQZFBec4fb8oA1cxSfW/OFD/gdjIxI2NbF2SxowvNPXKvB+KX9iVlG3sH3k7PQxqUPinq4c7Pt1r/JBW2g9S7dHs+7TH4owzKCE4Nuj7JRi4SkqKjVJiYgOpG5lcYyPTN2Ejq77X68itQlWrHRl9MqJwEaVQ0K3rHRd233j3/PqJ2n/5Gz0D2mMpxhmUFhwb9P3SDFxlBHMDqrHFGLg+EtyDKb9LMnB9LBgXxVYZBq6ZkrhBWYAbAGeoAH5VXPeaZdegjyqFhzYuMWZxs+/LHS4StzThta+6Tan2xcOaz+dr+95C7Qe6rdPi92mPZRlnECo4x+n7oQxc5STV//JA/QdiIxM3NkqVnznEr9ro+h2e+6Vj7UZ363Vtsnjvul2fhze9V67VxFZ/v6P9INUezb5PeyzPOIMKgmODvl+BgauipNioJCY2kLqRyTU2SjSb9HyDF9e9UnzrM59lffnZRXt6Ze8ZE3axceY+11Y+/L0fKzZoj5UYZ1BZcGzQ9yszcFURzA2oxpZj4JoluAdTfldk4JotGBfFVhUGrjmSuEFVgBsAZ6gAflVc95qvgG/dDivO9U2om6fjt9eeXrfvRN7yTSpMqdhs7sgbVT85tEb7gW7rtPh92mNVxhlUE5zj9P1qDFzVBec4+ao6A1cYM2Z9wHVqiIlZLyBmvYD8VFz9Ujxu59B6pz569d352eb27uJb3b/IS3u2fll9zvpnHGW7FXu7uvYD3dZp8fvkjxqM83pWcHzT959l4KopOL7JVzUZuMKZ8e0LrlPLOu/yBuI7EIjvIG58m9m6+jDz232XHplSo/3ERWP2X+l6pbpfh+fGxiXNXhxUu0yOh63eOq/9QLd1Wvw++a4W42xrC84F+n5tBq46gnOBfFWHgSuCmQt+4Dp1redCMJALRYBcKOmaC2b5yM0FM1tXf+f/+9Mpr124uzYq97WEH6aFFtxQbkNicOLk+Cs/vvtuzg6r52o/0G2dFr9Pfq7LiIN6gvOGvl+Pgau+4LwhX9Vn4Ipk5o0/uE4D6/sPBfJmHJA3s4C8CQ4DcoybN2a2rmeT9eWa7/f/puLaTi1jvXtdOD0t76QpfZf2j9w6dkPQJ38MVLT/xj0ay3QmDRgx85zgHKPvP8fA1VBwjpGvGjJwRTFzLABc53nrvSnGeo4p26znWKZggKeFAjkWHA7kIzfHzGxdzzHPqQHz816ceWTuH1laxb/ZXLnZZVHNPEHjWjz3bZ2x7fN/MkT7gW7rtPh9Or/nGfHVSHA+0vcbMXA1FpyP5KvGDFzRzHwMBNdpYjkfM7W0no++Xazno98goOfFAFwxFMjH4Aggd7n5aGbreube/3xbtrtPja+GtBhTtvaQnvl+uFigZq35xa62rlS/492KRY5rP9BtnRa/T2fdhBGLTQXnLn2/KQNXM8G5S75qxsAVy8zdIHCd5pb379/Keu7mumk9d/Mds567mVoCvTQG4KuhQO4GRwJ5zs1dM1vX+Cj13aBfQzo6h9Su7/N+kdffr3hu2JbOzaMrTf/9pQ69p0299If2A93WafH7FBfNGXHbQnCe0/dbMHC1FJzn5KuWDFxx6fTPKZut08pyjy7obz3P22eynue9yljnzP6twoCaAPToGIAzhwJ5HhwF1ARunpvZusZS3hnPdW209qP3t7Tv99nqKuNf6rdi3YWd2WZ84zh9odGxHQ+f1n6g2zotfp9iqBUjxlsLrgn0/dYMXG0E1wTyVRsGrnhmTQgG12lruSYMWmS5JihlW1iuCUqPmdZ7f0H/MKB+hAP1A+j9MQBvDwVqQnA0UD+4NcHM1jXuiv1ZIq53+N6XB9zc8+aOiC+OLn44/tUxq7bPb/bj0qWZ6516XfuBbuu0+H2Kt7aMfHhBcP2g77/AwNVOcP0gX7Vj4Epg1o8s4Drtre5fmZrdcv3wrjvYcv3w/ueO9foxaFEYUGvCgVoTAdQagFPEAHeHUKB+BMcCtYZbP8xsXWM050dLTi9v8MXpop2yKVsSLj3t895L4zJ3XLFyy+3JU5YOzjlR+4Fu67T4fYrN9ozc6SC41tD3OzBwdRRca8hXHRm4NjFrTVZwnU5WuYrPR4Us15qsXb+0XGuy37Wu+av1LgyoS+FAXYoA6lIkUJcArhID3F9CgVoTHAfUJW6tMbN1jecKvT65Vy/ulYK3zm3bHf3nv1mee/+ZbhHZbyTVz1k9UPml0xTtB7qt0+L3KY47MfLsRcF1ib7/IgNXZ8F1iXzVmYErkVmXsoHrdLFal57K+7zlulR9RkXLdalBYF/LHEitjWFADQsHalgEUMMigRoWBdQwgAPFAHeoUKAuBccDNYxbl8xsXWM/X+Zx7Y5XWtiwTP9rq6e2apOv8LE3+v2+upj35AZRyx3nb2lmaK2gmO/CyMmugmsYfb8rA1c3wTWMfNWNgSuJWcOyg+t0t7r/pmvXW65h39+PsVzDLr2wynINU+toGFDvwoF6FwHUu0ig3kUB9S4aqHcAt4oB7nGhQA0LTgDqHbeGmdm65kmZxqvznJwwq0e92wM+6j7t1J5L937/+4U+ewd92e7TcdE7mn+u/UC3dVr8PuVHd0b+viS43tH3X2LgellwvSNfvczAdZBZ73KA6/SwyNnu+OWx/PdVMv0cWtNqvfNq33ea5bukWnPDgNoYDtTGCKA2RgK1MQqojdFAbYwFaiPA2WKAu2QoUO+CNwG1kVvvzGxdcyrHj6ePO96fUl25vXb0+ldq3ulVM9/fx5qe7nav8dkcayZ93lf7gW7rtPh9yqUejFzvKbg20vd7MnD1ElwbyVe9GLiOMmtjTnCd3hZr4721v56wWhsDG9+w/PeBMvu/XMMqF6T6HAbU0XCgjkYAdTQSqKNRQB2NBupoLFBH44A6CnDBGOA+GwrUxuBEoI5ya6OZrWv+Fa88c//rx2t+MOxvR7mDBfw/v1fmn1eLZO07Y0PlD7uviKxZSPuBbuu0+H3Ku96MutBHcB2l7/dh4OoruI6Sr/oycJ1l1tGnwHX6Wdx/8Mi/frJaR4uVOz7fah0t88HpXlbrKNXyMKDmhgM1NwKouZFAzY0Cam40UHNjgZobB9TceKDmAhwzBrhThwJ1NDgJqLncOmpm65qrgU/drNnjj1djA79/b3VSz7E/3I5bs7z+naEFxnWos6aMo85e7Qe6rdPi9ylH+zFqSH/BNZe+35+B6xXBNZd89QoD12VmzX0aXOdVa9w1qeRXXY5ZrbmTp8xsZ7Xmzp/04V6r93qq+2FAfQ4H6nMEUJ8jgfocBdTnaKA+xwL1OQ6oz/FAfU4A6jPAXWOAe30oUHODDwL1mVtzzWxd87rkxV92TH6hbly+lye3nf/qyqMlvqnZRsmdr8CRJqcmRe58d732A93WafH7lM+vMurNa4LrM33/NQauAYLrM/lqAAPXLWZ9zgWuM9BifV6S905+i/VZ+WPjpKkW63OmZ093yG+RE2s9Igyo5eFALY8AankkUMujgFoeDdTyWKCWxwG1PB6o5QlALd8E1HKAE8cA2kIoUJ+DjwK1nFufzWxda0D+ASsSSybubBgwwqvQM8dK7/rg4yxfxJ3L//Birr2xZxY3GKT9QLd1Wvw+5f5ARm0aJLiW0/cHMXANFlzLyVeDGbgcuXm1PDe4zhBr+880rmj+RhZrue8Zr405LdZy/+BDf06zWsupn4QBdT8cqPsRQN2PBOp+FFD3o4G6HwvU/Tig7scDdT8BqPubgLqfCNR9gGvHAPpGKFDLg88CdZ9by81sXetFoe/OPbNlXd43yxRzFPl8/IzTbQZfPuy/O2JppSo9n96xumzYox88Gk6L36c6MYRRx4YKrvv0/aEMXMME133y1TAGriBm3c8DrjPcGoc/eKfS8h8s1v08Z1/Lt9Ji3S9Q5Dtvq/8csdZ7woAeEQ70iAigR0QCPSIK6BHRQI+IBXpEHNAj4oEekQD0iE1Aj0gEekQS0CMADh8DaCyhQN0Pvgz0CG7dN7N1rS1eZ/wu1Xxu5eWzE04f6Vnq49xbtp75ZFe7fln+OPH++prBR5c8+vij4bT4faopwxk1b4TgHkHfH8HANVJwjyBfjWTgysXsEXnBdV631iMuTm96Zo3FHtE16O7JZyz2iNcGbxjktHg30PpUGNBPwoF+EgH0k0ign0QB/SQa6CexQD+JA/pJPNBPEoB+sgnoJ4lAP0kC+slBoJ8Ad4MYQOcJBXpE8C2gn3B7hJmtax0Krdq8WKEa+Rq/tuWnMrenjS7buFHZRW/7vza+USOfW2EFxrD+XJfqz+uM+viG4H5C33+DgWuU4H5CvhrFwBXC7Cf5wHVGW9v/G6eG3HnTWj9RGiUdORBsrZ8o44Zv9dtlsZ9oPS0M6D3hQO+JAHpPJNB7ooDeEw30nlig98QBvSce6D0JQO/ZBPSeRKD3JAG95yDQe44CvQe4c8QAWlMo0E+CXfuJWe/h9hMzW9eaFdD89ofxL4VtuDXl6lObOg3O367YC4dz+V6JOdCise+koW+20H6g2zotfp9q1WhGLR0juPfQ98cwcL0puPeQr95k4CrH7D3PgOuMtXSXuf/60G9G/Wyt93h/tqHjNxus9R6fvk8VDmxlUe/S+l8Y0KfCgT4VAfSpSKBPRQF9KhroU7FAn4oD+lQ80KcSgD61CehTiUCfSgL61EGgTx0F+tRZoE8Bd5kYQO8KBXpPcBDQp7i9x8zWtb7lHdZtTK2bB4/n3bQs7lr56YvOxHUbWq7i3KU/lQktOj9n+D/aD3Rbp8XvU10by6i7bwnuU/T9txi43hbcp8hXbzNw1WL2qfzgOuOs9Knrjh+uzxhxyFqfyrbk62ELe1nrUzknljmdOczaHelRrwwDelo40NMigJ4WCfS0KKCnRQM9LRboaXFAT4sHeloC0NM2AT0tEehpSUBPOwj0tKNATzsL9LTLQE8D7kgxgOYWCvSp4FxAT+P2KTNb11oY8G3zPTWn7atXaE/lB7+32bFySpEVA8e9Hli3575b74cMd2r/Kkq0d1ANHMeo0e8I7mn0/XcYuMYL7mnkq/EMXE2ZPa0AuM4ES/t/et/UwEvXrfW02o2+nfx2Q2s9rfGsURuD+ljqaXpfDQP6XzjQ/yKA/hcJ9L8ooP9FA/0vFuh/cUD/iwf6XwLQ/zYB/S8R6H9JQP87CPS/o0D/Owv0v8tA/7sF9D/g7hUD6H6hQE8LDgH6H7enmdm61s08XredwQlK7ba3a2f+OK73e1VyjixfodCwzh1q+tWrV+vl1toPdFunxe9TvZzAqOcTBfc/+v5EBq5Jgvsf+WoSA1cnZv8rCK7zrqU7XbPlO0a+FGat/x3N3nVw9QHW+t/DF0Y1vmvxv0f8qAeHAb0yHOiVEUCvjAR6ZRTQK6OBXhkL9Mo4oFfGA70yAeiVm4BemQj0yiSgVx4EeuVRoFeeBXrlZaBX3gJ6pfX+l6klcKeLAbTHUKD/BZcDeiW3/5nZutbYrBOWr/Hu/fzJCl265QqaUajGt0PjQ5/vsOXrQ4XGXy2/vG537Qe6rdPi96m2vsuo/e8J7pX0/fcYuN4X3CvJV+9z/j0wzF5ZCFxnspVeeSNP3daBNaz9d5e9nrrrO3FxoqVe6RX57b8blza1dld81K/DgL4aDvTVCKCvRgJ9NQroq9FAX40F+moc0Ffjgb6aAPTVTUBfTQT6ahLQVw8CffUo0FfPAn31MtBXbwF91br+6d8qCOirwF0xBtA/Q4FeGVwL6KvcXmlm61qPcww5c7ttm6cTfx7v+GDr/l194/bv71uv+dCL4xLvTMrbbv4Y7Qe6rdPi96kOT2b0iSmC+yp9fwoD1weC+yr56gPOP2PA7KtOcJ2pVvbv7f/9lzee/9dSXw0qPq17/4qbLfXV4CwlFzUZVNFSX9V7exjQg8OBHhwB9OBIoAdHAT04GujBsUAPjgN6cDzQgxOAHrwJ6MGJQA9OAnrwQaAHHwV68FmgB18GevAtoAdbv4MW9A8CenAuoAcDd9AYQIMNBfpqcFOgB3P7qpmta+0uss3rQOb7O7O+9u2qX/J2LPtF1nut/6j4xonbVyffmfXzD4tmaT/QbZ0Wv081eyqjp3wouAfT9z9k4JomuAeTr6Zx9GlmDy4MrjPdyt324ZyhCz6on9NSDy754uGvR6341VIPLl87qNGGfTMs6cA6DwgD+nU40K8jgH4dCfTrKKBfRwP9Ohbo13FAv44H+nUC0K83Af06EejXSUC/Pgj066NAvz4L9OvLQL++BfRr6z140KIgoF/nAvp1CNCvgbttDKADhwI9OLgT0K+5PdjM1rXOly595qVpT1UPuBwcMKxHTGyFOpcL/vbntv2vv9218uejn7/H+nekUH2fzug/MwT3a/r+DAaujwT3a/LVRwxcs5n9OgRc52ML/Tq6WFK+S1fODbLUr2fdGjO33YT1lvr1l78PDql/aY+lO7POGcKA3h4O9PYIoLdHAr09Cujt0UBvjwV6exzQ2+OB3p4A9PZNQG9PBHp7EtDbDwK9/SjQ288Cvf0y0NtvAb3dshat9vYgoLfnAnp7CNDbywG9HbgzxwBadCjQr4P7Ar2d26/NbF17gl9C8J+dhxy+2uT3xIlxfRpeTvxxlWPQ6l4bE9YcmTnxk6Ay2g90W6fF71Mv+JjRq2YK7u30/ZkMXLME93by1SwGrmhmby8CrjPbyv6/zd55zP3nN1vp7Zmy5S01pUVgZSu9PdOA1hdaR82uZaW3J/OLMIAHhAM8IALgAZEAD4gCeEA0wANiAR4QB/CAeIAHJAA8YBPAAxIBHpAE8ICDAA84CvCAswAPuAzwgFsAD7B8F1d5QBDAA3IBPCAE4AHlAB5QC+ABwF08BtDDQ4HeHjwS4AHc3m5m69o/SlQc2DHy7JV/P3hp7vawrcvqfBgR49yw+EC7nGUfdK49J/tm7Qe6rdPi96lvzGb0tTmCeQB9fw4DV5hgHkC+CmPgWsXkAUXBdeZauOMvXPj81VlNDkZY4QF+o75+ff3R5b2t8AD/zVkHnThU39q/B1XnImEAZwgHOEMEwBkiAc4QBXCGaIAzxAKcIQ7gDPEAZ0gAOMMmgDMkApwhCeAMBwHOcBTgDGcBznAZ4Ay3AM5gmQeonCEI4Ay5AM4QAnCGcgBnqAVwhqYAZwDu+DGAJh8K8IDgSQBn4PIAM1vXXlOge7MNT79dad2ROW+v/PF2w+xX3225bXHDK/3L9/js2pYq5UZpP9BtnRa/Tz1mLqMHhgvmDPT9cAauTwRzBvLVJwxc25mcoRi4ToQFzhCXkGv3p2/usPTfzHjG8fvo+/uevWSFMxSav23Wnsz94q1oB8m8JQzgF+EAv4gA+EUkwC+iAH4RDfCLWIBfxAH8Ih7gFwkAv9gE8ItEgF8kAfziIMAvjgL84izALy4D/OIWwC8s/7mAyi+CAH6RC+AXIQC/KAfwi1oAv2gK8ItOAL8AtIMY4M8FQgHOEDwb4BdczmBm69qXyk/L0XpMrlrlK5d4/fS6tmsuB2x55tYnn9a49XbRzV3qh7/3gfYD3dZp8fvUjyIY/fJTwfyCvv8pA9dngvkF+eozBq7DTH5RHFwn0sL+i3TJ27Lknc29rPCLXqvyZGu9dfXXVvjFiD7j1y3Os/FTK/wimeOEAVwkHOAiEQAXiQS4SBTARaIBLhILcJE4gIvEA1wkAeAimwAukghwkSSAixwEuMhRgIucBbjIZYCL3AK4iFVNgrhIEMBFcgFcJATgIuUALlIL4CJNAS7SCeAifQEuAmgSMcCfTYQC/CI4GuAiXH5hZuvawwq+2nBRo9dzJRzvNnbBZ/N+faZAyw39Ovxe4L3+Pd4oruRc9ZP2A93WafH71LsiGb11nmAuQt+fx8A1XzAXIV/NZ+A6z+QiJcB1osy1jmaFD12pO3/8kY8tcBGl19j7dz7d2i/JAhdR5h9fsa1Jna8t/TMLyXwoDOAt4QBviQB4SyTAW6IA3hIN8JZYgLfEAbwlHuAtCQBv2QTwlkSAtyQBvOUgwFuOArzlLMBbLgO85RbAW6xyEeItQQBvyQXwlhCAt5QDeEstgLc0BXhLJ4C39AV4y0iAtwBaRwzw5yOhABcJXgXwFi4XMbN17XfZ914LrHqr7Y4eScV2zZ734S+xM5Z/tvOLqXGFun33eeG+BVj/vQ/qc1GMPvy5YN5C3/+cgWuBYN5CvlrAwHWPyVtKgut8Yc5bmg9bXCOsf9SU3yzwFu8H58Z8NOrBG7Ms8BafX166W8G5bv12CxrK/7hTGMBxwgGOEwFwnEiA40QBHCca4DixAMeJAzhOPMBxEgCOswngOIkAx0kCOM5BgOMcBTjOWYDjXAY4zi2A41j9MxriOEEAx8kFcJwQgOOUAzhOLYDjNAU4TieA4/QFOM5IgONMAjgOoKHEAH9GEwrwluDtAMfh8hYzW9feWLhP6NkfN+74rdzNIZ0ndj58qOe0kk9/N7Lj2vNlukW+s6bnJu0Huq3T4vepJ37B+WcyBHMc+n40A1eMYI5Dvoph4MqSh8dxSoHrLDTfv++Hz4z56sqng5Za4Dg5chZ87Xy7iq3PWuA4T5eaPKBYvVfq5LTAcf7Hs8IAPhQO8KEIgA9FAnwoCuBD0QAfigX4UBzAh+IBPpQA8KFNAB9KBPhQEsCHDgJ86CjAh84CfOgywIduAXzIojaj8aEggA/lAvhQCMCHygF8qBbAh5oCfKgTwIf6AnxoJMCHJgF8aDbAhwBtJgb4c6JQgOMEHwb4EJfjmNm69tHgP4q98V67q5s/WTms2L2DjU4X6/rbRzdiSv3W7Oc1O/Lnafah9gPd1mnx+9Q/FzL6+yLBfIi+v4iBK1YwHyJfxTJwhTD5UGlwncXmmk/P5pcKVxvxx+jjFvhQg345ErY2eVD3Mwt8qOXMpPK7Pn115jQLf1b1P04WBnCncIA7RQDcKRLgTlEAd4oGuFMswJ3iAO4UD3CnBIA7bQK4UyLAnZIA7nQQ4E5HAe50FuBOlwHudAvgTlb5EHGnIIA75QK4UwjAncoB3KkWwJ2aAtypE8Cd+gLcaSTAnSYB3Gk2wJ2iAe4EaD4xwJ9VhQJ8KPg8wJ24fMjM1rXnlj7Yfkv7c+1y/vrg20O/jNqjnIgqmH9o1oT4yIAOAxe8OyFC+4Fu67T4feq1ixlcYIlg7kTfX8LAtVQwdyJfLWXgqsbkTmXAdb40505RtZv3mLJhYnUr/37wy5/umFB7r2PZHHPupDzt3e541W2+X3S2oCX9j7+FATwrHOBZEQDPigR4VhTAs6IBnhUL8Kw4gGfFAzwrAeBZmwCelQjwrCSAZx0EeNZRgGedBXjWZYBn3QJ4lsU/L9N4VhDAs3IBPCsE4FnlAJ5VC+BZTQGe1QngWX0BnjUS4FmTAJ41G+BZ0QDPWgXwLEBLigH+vCwU4E7B9wCexeVOZrau/bnAwFxRh2uMOD7ku1cLJkbWulDn0LwTOb/PufbHFzOdndEzfrT2A93WafH71Je/ZPCGOME8i74fx8D1lWCeRb76ioGrBZNnlQXX+dp0/0rVhOPVw/v7bFlkzrO8OvuNu/rap5nLnzDnWV4XG8S9nH93rg6KBZ71P64XBnCycICTRQCcLBLgZFEAJ4sGOFkswMniAE4WD3CyBICTbQI4WSLAyZIATnYQ4GRHAU52FuBklwFOdgvgZBY1Ko2TBQGcLBfAyUIATlYO4GS1AE7WFOBknQBO1hfgZCMBTjYJ4GSzAU4WDXCyVQAn2w5wMkCjigH+zC4U4FnBrjzLjJNxeZaZrWsvz9Vzbf0vGvZvsT7H280aJIy/EnT24rDoVh1fTVzUetigB/880H6g2zotfp96+NcMjrFMMCej7y9j4FoumJORr5YzcPVkcrJQcJ14U+1r09IK4/P6lAqPa2HOyTLnLfpZmVP3n508wpyTZSldacPUd0Nbj2tl/ueGKbwwDOBv4QB/iwD4WyTA36IA/hYN8LdYgL/FAfwtHuBvCQB/2wTwt0SAvyUB/O0gwN+OAvztLMDfLgP87RbA3yxyMo2/BQH8LRfA30IA/lYO4G+1AP7WFOBvnQD+1hfgbyMB/jYJ4G+zAf4WDfC3VQB/2w7wt8MAfwO0rxjgzw1DAU4WHALwNy4nM7N9rO/3Wxpa4HyhKtnbtIw+eXXU6X1fnTiWY/+UmeHRn2erPmg3i79Rv49n8JEVgvkbfX8FA9dKwfyNfLWSgWsUk7+VA9dZZcrfvi94ZMDbyvVDc2ub87cyO2bNKNfm6q/xF8z5W+V6a1oceXgpz763zTW1FA4ZBnC9cIDrRQBcLxLgelEA14sGuF4swPXiAK4XD3C9BIDrbQK4XiLA9ZIArncQ4HpHAa53FuB6lwGudwvgehb/7FLjekEA18sFcL0QgOuVA7heLYDrNQW4XieA6/UFuN5IgOtNArjebIDrRQNcbxXA9bYDXO8wwPXOA1wP0NRigD+7DAX4W3A1gOux+ZuJrStHKJT9Wj9nsaoRI1+5XeTouFfKVq37Tdnd2ydH7q/wU2Dn4d7B2g90W6fF7xM3WMXgLqsFcz36/moGrjWCuR75ag0D13Qm1ysPrpNguv9nWzaJ+PPqhaqz1phzvaiXnd9mLr+t1aH25lxv/cDph2cMXX1z7iVzrpfCN8MAXhgO8MIIgBdGArwwCuCF0QAvjAV4YRzAC+MBXpgA8MJNAC9MBHhhEsALDwK88CjAC88CvPAywAtvAbzQmlb3iBcGAbwwF8ALQwBeWA7ghbUAXtgU4IWdAF7YF+CFIwFeOAnghbMBXhgN8MJVAC/cDvDCwwAvPA/wwnsALwS0uhjgz09DAa4X3ALghVyuZ2bryieKdxna/aWfFh1YXX3fW09FJ56odeBATOQrXTZk9293YNy11+pqP9BtnRa/TzwigcFz1grmhfT9tQxc6wTzQvLVOs6/o4PJCyuA66w30wBPTAn/56NCvRb+9mdPU16Yqfbd3Xc69sife0UOU16YKepY1TWTy11v9LuF/45bCjcNAzhkOMAhIwAOGQlwyCiAQ0YDHDIW4JBxAIeMBzhkAsAhNwEcMhHgkEkAhzwIcMijAIc8C3DIywCHvAVwSEu8UOeQQQCHzAVwyBCAQ5YDOGQtgEM2BThkJ4BD9gU45EiAQ04COORsgENGAxxyFcAhtwMc8jDAIc8DHPIewCGt88JMLQENMAb4M9xQgBcG9wQ4JJcXmtm6co9cf0V+V+K3ruXfuukz5P7thB/ff3Z7rpo9Cg57peGxp5fPmpxV+4Fu67T4feIc6xmcaINgDknf38DAtVEwhyRfbeT4i8khK4LrbDLjkKdi25339cuWNGh/R1MO6Z83a+cigy9vud5moymHDHirXMuuxzaFRk6vb6otuvDYMIBvhgN8MwLgm5EA34wC+GY0wDdjAb4ZB/DNeIBvJgB8cxPANxMBvpkE8M2DAN88CvDNswDfvAzwzVsA37T258iP+GYQwDdzAXwzBOCb5QC+WQvgm00BvtkJ4Jt9Ab45EuCbkwC+ORvgm9EA31wF8M3tAN88DPDN8wDfvAfwTet/juzfKgTgm4C2GAP8OXIowCGDRwF8k8shzWxdeUq+bwpcarTqbPZPO+R++V7lZ/7q9PHFfy5Oq7PjzMJzDWf8GNVD+4Fu67T4feInmxj8abNgvknf38zA9Y1gvkm++oaB6yCTb1YC1/nWbP+Bn8atfHHywI2L++4y5ZsFWvbfdHDs9hr187Yy5ZshrT4fXjNuW+hXDV8z5ZsunDcM4KbhADeNALhpJMBNowBuGg1w01iAm8YB3DQe4KYJADfdBHDTRICbJgHc9CDATY8C3PQswE0vA9z0FsBNrWmWj7hpEMBNcwHcNATgpuUAbloL4KZNAW7aCeCmfQFuOhLgppMAbjob4KbRADddBXDT7QA3PQxw0/MAN70HcFPrmmVB/xCAm1YDuCmgWcYAf5YdCvDN4OkAN+XyTTNbV06T5blBSQmvvXfgyKc1X0/qMG305y+tL71sx/VMmYKrLPuix4Yu2g90W6fF7xOX+ZbBtbYI5qb0/S0MXFsFc1Py1VYGrotMbloZXGebiRZaxyvH0G/rvDRpctFLTUy56QDH6n8G1q/aYerVo6bc9O38Vdf1yFbQ0X7OXtM/T3fhx2EAjw0HeGwEwGMjAR4bBfDYaIDHxgI8Ng7gsfEAj00AeOwmgMcmAjw2CeCxBwEeexTgsWcBHnsZ4LG3AB5riZvqPDYI4LG5AB4bAvDYcgCPrQXw2KYAj+0E8Ni+AI8dCfDYSQCPnQ3w2GiAx64CeOx2gMceBnjseYDH3gN4rHVuOmhRCMBjqwE8tgXAYwEtNAb48/RQgJsGxwA8lstNzWxd+U+Wtyts+/X83PHNKm/O+5xPvUKO4a+2mBnavs2SBrMbet2K3an9QLd1Wvw+8Z5tDF6WKJjH0vcTGbi2C+ax5KvtDFxeeXk8tgq4zg4zHvvK2BXr1jdt/tTIBa+b8Vhl/PtTit47VnXG8ApbzXisstX/ap81f+8u8Pysv8w0VlcuHQZw3nCA80YAnDcS4LxRAOeNBjhvLMB54wDOGw9w3gSA824COG8iwHmTAM57EOC8RwHOexbgvJcBznsL4LyW/kxf57xBAOfNBXDeEIDzlgM4by2A8zYFOG8ngPP2BTjvSIDzTgI472yA80YDnHcVwHm3A5z3MMB5zwOc9x7AeS3/mb7KeUMAzlsN4LwtAM7bE+C8gMYaA/yZfijAY4M3AJyXy2PNbF25kn+OBbmTZu8PzBUy7OPvrjws0Kv/ycNn2330dctRZ24WqLdzvvYD3dZp8fvEkXYwONxOwZyXvr+Tges7wZyXfPUdA1d+JuetCq7zvcn+lVsBzU4NnPv7d1OnnjHjvD4DI/Kd/dFPyf/e8++acV7fzp8v6Lzy7V4zV99KNOW8Lrw7DODH4QA/jgD4cSTAj6MAfhwN8ONYgB/HAfw4HuDHCQA/3gTw40SAHycB/PggwI+PAvz4LMCPLwP8+BbAjy1ptzo/DgL4cS6AH4cA/LgcwI9rAfy4KcCPOwH8uC/Aj0cC/HgSwI9nA/w4GuDHqwB+vB3gx4cBfnwe4Mf3AH5sWbtV+XEIwI+rAfy4BcCPewL8eBTAjwHtNgb4ewWhAOcNPgjwYy7nNbN15VWFF3199lSZrWs2Lm124Fi4t+PV5b9nGnJi7LxyJQY22a8Ed9B+oNs6LX6f+NT3DL63SzA/pu/vYuBKEsyPyVdJnP/WIZMfVwPX2W2iCTf8O99XMwr33dlm8MdFzfhxznndf91Q+eid3T16J5nx41x/X3/9+z8XXGtQ8XaQ2d9tcOXoYQCXDge4dATApSMBLh0FcOlogEvHAlw6DuDS8QCXTgC49CaASycCXDoJ4NIHAS59FODSZwEufRng0rcALm2FHydz6SCAS+cCuHQIwKXLAVy6FsClmwJcuhPApfsCXHokwKUnAVx6NsClowEuvQrg0tsBLn0Y4NLnAS59D+DSlvmxyqVDAC5dDeDSLQAu3RPg0qMALj0d4NKAJhwD/N2GUIAfB18EuDSXH5vZunIw5aZXhz4TB7339fBnri/ovHPn5mx5G/2dpeuDESsWFak3pdk+zUa3dVr8PnGv3QxuuEcwl6bv72Hg2iuYS5Ov9jJwtWVy6ergOvtMuHSnD95IOr6rUM3vXs/XyoxLN77587nyvxU5NqDJJ33MuHT7HJ8Wr1g2YdeI4b6vmmnNrnw+DODd4QDvjgB4dyTAu6MA3h0N8O5YgHfHAbw7HuDdCQDv3gTw7kSAdycBvPsgwLuPArz7LMC7LwO8+xbAuy39/QqddwcBvDsXwLtDAN5dDuDdtQDe3RTg3Z0A3t0X4N0jAd49CeDdswHeHQ3w7lUA794O8O7DAO8+D/DuewDvtvz3K1TeHQLw7moA724B8O6eAO8eBfDu6QDvjgF4N6A1xwB/vyIU4NLBrlzajHdzubSZrStfC8reccS1Glt+zTS99PJtPwx4edqNO8/O2Jz1VKukJWWyZs4/TfuBbuu0+H3iafsYPHK/YN5N39/PwPWDYN5NvvqBgWsgk3fXANc5YLL/7qe/++Sjxgsbd3au3WvCuxXHmldytRw+6NV8U33/NeHdStmPG48OqDa4zq1aTQ6Y8W5X7h8GcPRwgKNHABw9EuDoUQBHjwY4eizA0eMAjh4PcPQEgKNvAjh6IsDRkwCOfhDg6EcBjn4W4OiXAY5+C+DoVjTsZI4eBHD0XABHDwE4ejmAo9cCOHpTgKN3Ajh6X4CjjwQ4+iSAo88GOHo0wNFXARx9O8DRDwMc/TzA0e8BHN2qhk0cPQTg6NUAjt4C4Og9AY4+CuDo0wGOHgNw9A0ARwc07Bjg73iEArw7OD/A0bm828zWldvlr3E56NOE8oeuXS3WseHfweVK3C967LlNswKr9OxVa8jfUdp/1grlwsTpDnD+fWWCOTp9/yAD14+COTr56kcGrslMjv4suM6hJ2vjxab/fnFVw7xv/h3TI+e7Jhzda8F3uy99tG3At8OblMtkwtG96w3tHVajwszGs282CTb7eyau94QwgM+HA3w+AuDzkQCfjwL4fDTA52MBPh8H8Pl4gM8nAHx+E8DnEwE+nwTw+YMAnz8K8PmzAJ+/DPD5WwCft8LRk/l8EMDncwF8PgTg8+UAPl8L4PNNAT7fCeDzfQE+PxLg85MAPj8b4PPRAJ9fBfD57QCfPwzw+fMAn78H8HmrHJ34fAjA56sBfL4FwOd7Anx+FMDnpwN8Pgbg8xsAPn8Q4POANh4D/D2TUICjB1cD+DyXo5vZuvLA/FN3/tK/94jzz3Wvd/2vr0a+Vf6lio19oz85tOKHlR2OTNjB+m/MEf87xOCnPwnm8/T9nxi4Dgvm8+Srwwxc0Uw+XxNc5+cn8/mS92P3vero2uD5iOpJ0034fLCz2+3SLcL+Wb0iITGvCZ/P+nLP6bMu/rq8TNZP7pc10dwfu1OEAdw/HOD+EQD3jwS4fxTA/aMB7h8LcP84gPvHA9w/AeD+mwDunwhw/ySA+x8EuP9RgPufBbj/ZYD73wK4v5W/65LM/YMA7p8L4P4hAPcvB3D/WgD3bwpw/04A9+8LcP+RAPefBHD/2QD3jwa4/yqA+28HuP9hgPufB7j/PYD7W/27LsT9QwDuXw3g/i0A7t8T4P6jAO4/HeD+MQD33wBw/4MA978IcH9Ac48B/q5LKMDng9sC3J/L581sXTmjV6UhfatOqDrw1qH6/staepcu/HXTCQFjX141bfivFZ9Z9/HH2g90W6fF7xNX/JnBZY8I5v70/SMMXL8I5v7kq184/w0ZJvf3TrWOwchebvuIKSsb/vbh97XmhJrw+fLjfjvxbHz+LUnPhV4YacLnq3+25sBf48Z+Nmpo9amRrnze9L8Xk057Nbu7hAF3jHDgjhEB7HWLuL0+Vg8BzSIG+HPFUNcaZ/p32aTs1RE8EKi73Fpq+vfWmHsNtLBX1ztqJHBHjQLuqNHAHTUWuKPGAXfUeOCOmgDcUTcBd9REIJffLSPuzF3vwknAXfggcBc+CtyFzwJ34cvAXfgWcBe28OdV/7sLBwF3Ydf7rdmZvyf0zFPu3CHAnbsccOeuBdy5mwJ37k7AnbsvcOceCdy5JwF37tnAmb8v+MyT7/bRwN1+FXC33w7c7Q8Dd/vzwN3+HnC3t/jnb9rdPgS427ve103/Lo3oM9c1hBaAhtAT0BBGARrCdEBDiAE0hA2AhnAQ0BAuAhqCF8DhpjDPPEh/Oy2uc9T6nVMB7oEKcI9SgHuIAvB4BeDBCsCfFKDvKkC9VoA8V1zjo/iEUfE+bdbWe2XfhYtZXjj7ddsbY/tWWXP8UrcTv5b6NNvCXdoPdFunxe9TXBxlaAXHBGsr9P1jDFzHBWsr5KvjHH8x72q1wXVOPPnPVXu/smVyu0bVsufbkuNSSRMdJu7Hr95seSv2ysCD7b/dZqLD7Ar9suvl4/9EjDlZILGMyd+TfEwLMtFHHtNSwgEtJQLQUszut6534SjgLhwN3IVjgbtwHHAXjgfuwgnAXXgTcBdOBO7C5vfOlDvqQeCOehS4o54F7qiXgTvqLeCOauHe+b87ahBwR80F3FGt3AeT747lgLtjLeDu2BS4O3YC7o59gbvjSODuOAm4O84G7o6W7mn6nW4VcKfbDtzpDgN3uvPAne4ecKezek+jO10IcKerBtzpWgB/XtsTuGuNAu5a04G7Vgxw19oA3LUOAneti8Bdy/rfk/RvZf3PHDK1BP5cNQb4e5KhwJ8FBE8G/twA+Lt40J3NlYvm29tn5/hNn63oPeSXKrM2x5R76YuPlh757boy5ofmsbdfH/uD9gPd1mnx+8RBTzA48knBdwr6/kkGrlMgruSRGVzndCbLsZEJOG8f4I7uA9zRfYA7us8B63GvAHclH+A+7wPc532A+7wPcJ/3cb3P57296PCw83H9t599qsXvH92a+cydym/8WqluYtL0yXtLl1yziGzQGKcYOs2I8TOCc4++f4aB61dm7qH35rNPzr3l9WIalTkW8/aNLIFHvJ98b1YmVB+8od61Is9Uef/nBS2ffG9Wtv7y7JycA4Kub3zw2tBdJvfm4gOv9xi0u9qaS7H3bg0xuTeXOzay3MZyA/qMfaVnxS9M7s0lyj53fkSNO0G/nQqrPM3s3rx/2Tunxl79/p+ofDO9ze7NoxrOuRzRaEbIZ/cv5ze7N7fc0KTL+OUVN5/Z/up5s3uzd+/wTm82/uOtXWUG/Wp2b66b48G+P0/GPHX7h+sTTe/Nlca+WMdrSfkB5ZZMMb03515185uzxTqN8D65wPTefLbRoCXVkuq1L7fpsum9+eSUnyYFdO9Vu+etPeb35gmFGtWJGr/7G+9q5vfmYyudie1mXXj+2Qbm9+ZtORoX6J/95tqDXub35kyrP9xffHK/bHO6m9+b1/sHXRzR4J/3X+tu4d48bupW7xK5JuWJt3BvzvL5gOtjXtj7wwAL9+aWX0WsLf9lvopnrNybv72wIfenmw89tHJvbhPYf9A7BR/UsHJvXrvri64hsxdY+ucLF9/dkr329MGW/j3WSlydmT9Ft3rH0r35lWx/FG/v3cvKvTk6e1T5uZU+esvSvTnAp8fdjiWqWLo333zz6c9XDLf23+i+Hld1wY/zxli7N1fYdiW+0Ahr92b/50u3+3SrtXvzg3fDes8Zbe3erPjNbpelrbV7870cB4Z/OMjivflkvrAO3S3em31mxh9sbPHevHvizm6K1Xtz38MVblq9Nxd86tJ0i/fmJEfbt7pbvTffbdmyvuV7c/Sndy3fm8teL2z53px54FXL92avIeet35tvXLZ+b25Y1Pq9OcdH1u/NPoWt35uVgcC9uS9wb84P3Jv9gXvzY/co5F6SP3h7wxc++3nJkLv1D57KtiC778Q5F1+4tav0mf0be7wV+eocskE5MnHQswyO/Jtg7k7f/42B63fBfxZHGsMpBq4C+cT6i+5fvzJwFRSMi2LrdwauQiCu5OENrvMH8HcUgDNUAL8qrnt9alXU2IW+M75p+2D4zN8KH8977+Kq2qtvRW/Pk6VlpaIR4+poP9BtnRa/T3v8g3EG5wTnOH3/HAPX+UxyYuOCdW0MiY1M3Ngo8Hzk8M2Thuz4uOTOurE7eq1d57z/wufKtcLLV5x9uWT8my9rP0i1R7Pv0x4vMM7gouDYoO9fZOC6JCk2LouJDaRuZHKNjYLRu5ZEfnliY8+7nzzo+WD+R1NPPpVr6oFiIaPatdqy9MKU+9rHU+3RDAvt8TLjDK4Ijg36/hUGrj8FcwOqsecZuJyCezDl9yUGrsKCcVFs/cnAFSKJG1wFuAFwhgrgV8V1r95jDg9u2L7r9DXvzMtfZ0CZn7sU+qzxggtbOuds1f3qsdrjr2s/0G2dFr9Pe7zKOINrgnOcvn+Ngeu6pPp/A6j/QGxk4sZG3hKhawte/iP2lv/NlcPHzzvYv1zxrydvd6zMf/Ll5m85vvlG+0GqPZp9n/Z4g3EGNwXHBn3/JgPXX5Ji428xsYHUjUyusfFUSL/qlbvHVf6u2XeNr832j1t54pnDA6ZcfcMr8nzj5Tkb9Nc+nmqPZlhoj38zzuCW4Nig799i4PpHMDegGnudgauI4B5M+f0XA1dRwbgotv5h4ComiRvcBrgBcIYK4FfFda/KvwOud+lUqs38BzW2/DJqwQcr8xf+7Ytt54vcyfFXs153lrL+W3+0x9uMM7gjOMfp+3cYuO5Kqv/3gPoPxEYmbmzk+T3uyuHilyu8lZQ3aFrZuHzLfv2j3MFSG7p2PfLCjNY9Sr+o/SDVHs2+T3u8xziD+4Jjg75/n4HrX0mx8UBMbCB1I5NrbGTdunHfBp+Zf8dtfhj746qXK32ypXDMwoDZg7OEdjie/71/Y7WPp9qjGRba4wPGGTwUHBv0/YcMXA4vobh8qMbeZeAqLrYHB1J+/8vAVUIsLh+KLToTFFdJSdxAsR4vCnCGCuBXRdZeM7nsNWe3dmFdc/7yZbP1a96uvLfTtKXLul9Iah7qe+7mvUM7+/d/xXWvZrYlANuSgrkonWcmRrx5AXFAfvdzwWYHL7DuY+t5e9lY0NsL/52PF1CEmbh8vFImnA58ZEr1WzOcyJ58gQD53//jEB+4fkAAUeBmcjweSChO8oMffk6K65r+3OBNXhx1UoDNwzP7Pm0ogIErUHBQEaZAZlKha/nLWct3QfP8RWkteoCEn9FmzdkT/kDCB4FnkzyQInT138F+CKbMYtktO7+CBeOis8jMwJUFLI5ejvTp6si6rutl5RZG+mFWL7wDZgWCLxt4yMkjNSYre3FaxJRdcAGlPWdnFLX0pIhZgT26rpfDTjDl8MIPLgcANKdgOkl7yMmguTnBiuHtePyQQZ/5ZNFxJtub+YJsszDOBqlIOZnV6yluwNEPnwKr19WHD+9nARz3tOAWxdlD6hZlZpsL3AMaJFTtAD8pVBlzubk6clttbm6w0oK5GZUlj+CKR7jySOL6WSWuFaxXPJT75U3nSm61MjsdlobWafJ6yQv4fMnn5cVYEG1RgPMVApZPArn3daQc6mMAUq1rBa9FW8PhtGaWyRXrM/qh5U++oSS/6X/4N9Vcfq//llb00PNZPHC1DT98BgiO/Ol0iTBbB8FUwMXW5M/5HvNzAd33SDtDcFvBkjwKetlYsKABbzFbvCCQ4YVstj4reyhkUEHM9lBIMCfMr+NyYL/jrJWJqi6tlzrRrVRrq7b5AdvCEuQzWicfgCnE5nmbFcK0zsBsGeDCpSBnUETwfjPrzADdb2arzUWVR5H4LArGHHo/olgDfKpQDoQwmE0xkNnY/TMd8lsxRp1yXbM49z6VvDjqpBICg/uavqESDFwlBUuShKmkpLtXceZa6XnBL86875TiBiQtWMoL/11pmyzHCq7S6XTw/7dV9jKCmRoVoeKMZC8rGFcxJq7Q/886fzkw95IHyjaRHC8vuBHQGZdjxEYFwTFLuVqWgauiYFx0HhW8cNaHnHklcA/JA7m1qbnhA/hKqQTgr5xO+M0wicJfRXAMEe5KjNiu6qG4qoE3DR9Hyl87tYvXoq2tdSpJWscT9+OqH1fXE7RGWqTYpOAEUABXYwTYszav5FYKFpD0CjngWS/4b2n5AAmsVBOZ7Jlm3+aeRU3BhISCrKYXfoZVgQJfjZloaIOtDsaUle8S/lqSGqwo/LUFNzLCXYMR23U8FFddNzXY6sw4Q9epIWkdT9yPa4OtpydofW6DpQCuywiwBoIbLBUsIOkVckADRoMFElipKzLZ1QbLPYvnBDdYCrLnGA22DlDg6zITDW2w9cCYsvJdwt9QUoMVhf95wY2McNdnxHYjD8XV2E0Nth4zztB16ktaxxP349pgm+gJ2pTbYCmAGzMCrJngBksFC0h6hRzQjNFggQRWGotMdrXBcs+iueAGS0HWnNFgGwEFXrRvaQ9NGL5tIbjAU9y2YOBqCeKCGnmm2feT/WXJXt9HU+C8ybalV8oHrP7uSc0q9bc4w2nNTDH6P5wOS0Np4sXDyIkti7aPNZVW+rm0dolLePFs4L8KBS0u9H1ggxqe1gYBJwpbExBbKyY2zrm0YhScNl7icbX24vnaqm1bsFEmD/QWB/hKaQsUzRck3eJE4W8nOIYId1tGbLf3UFwd3HSLayOpQbWVtI4n7se14XbUE7QT9xZHAdyBEWAvCr7FUcECkl4hB7zIuMUBCax0EJns6k2DexadBd/iKMg6Mxpse6DAd2AmGtpgO4IxZeW7hL+LpAaL3qySbc3wd5VwW+3IiO1ugnGRPzsxcHV3U4PtyIwzdJ1Oktbx9BvtS3qCvuxl40ab1ea/3NOsiVOSdGcEcQ/BjYOc1oOBq6fgpKdiTQUPlba6efEKhJltL3C/8L8BKNPjPjX9txhleoTJga3zaDHkNyrp4cZub8GxS4nfm4Grj0151crZdAPPEmhWWqz0kaR20VodQWwveeHx3xHwV18v8XvuBO75ZcaeEfLaTxL5Bnyr9APw95dEvkXhf0VwvyPc/Ri17FUPxfWam8h3X2acoev0k7SOJ+7HlXwP0BN0IFfdogB+jRFggwSrW1SwgKRXyAGDGOoWkMDKayKTXSV63LMYLJjoUZANZqhbrwIFXqhv9dvtAIZvh0hQVwYycA11U4EfIKkgDsxQV7QxTC/sw71sqCtZBKsrlCRDGUE8QnDhIqeNYOAaKfCGQ02nq16MnNY+r3TViwSqxgzx4hUUM9vXbfrHZGjxOhLAQ/ave6V8wOmwPtAmzY31NwTHOhWKNxi4RglWY+hshoBnCTQ3LVZGSVJjaK0BILZhDGViAOCv0V7i9zwQ3PNwxp4HAnseI0mNAXyrjAHwv5lO+M0wicI/VjApJtxjGLXsLQ/F9babyPpoZpyh64yRtI4n7seVrI/TE/QdrhpDAfw2I8DGC1ZjqGABSa+QA8Yz1BgggZW3RSa7SvS4ZzFBMNGjIJvAUGPeAgq8UN/qt+FxDN9OlKDGvMPANclNBX6cpIL4ToYao4139cL+npcNNSZYsBpDSTKJEcTvCy5c5LT3GbgmS1BjgETS1Jh3GGrMRC9eQTGznWLTPyZDi9fJAB6yn+KV8gGnw/pAmzQ31j8QHOtUKD5g4JoqWI2hs5kIniXQ3LRYmSpJjaG1xoHY3mUoE+MAf33oJX7P74B7fo+x53eAPU+TpMYAvlWmAfinpxN+M0yi8M8QTIoJ9zRGLfvIQ3F97Cay/iEzztB1pklaxxP340rWZ+oJOourxlAAf8wIsNmC1RgqWEDSK+SA2Qw1Bkhg5WORya4SPe5ZzBFM9CjI5jDUmI+AAi/Ut/pteCbDt2ES1JhZDFxz3VTgZ0oqiLMy1BhthOuF/RMvG2pMZsFqDCXJXEYQRwguXOS0CAauTyWoMUAiaWrMLIYaE+bFKyhmtp/Z9I/J0OL1UwAP2X/mlfIBp8P6QJs0N9YjBcc6FYpIBq55gtUYOpsw8CyB5qbFyjxJagytNRPEFs5QJmYC/prvJX7Ps8A9f8LY8yxgz1GS1BjAt0oUgP/zdMJvhkkU/gWCSTHhjmLUsi88FFe0m8j6fGacoetESVrHE/fjStZj9ARdyFVjKICjGQG2SLAaQwULSHqFHLCIocYACaxEi0x2lehxzyJWMNGjIItlqDFfAAVeqG/123AMw7eLJagxCxm4lripwMdIKogLM9QYbSzVC/uXXjbUmCDBagwlyRJGEMcJLlzktDgGrq8kqDFAImlqzEKGGrPYi1dQzGy/tukfk6HF61cAHrL/2ivlA06H9YE2aW6sLxMc61QoljFwLResxtDZLAbPEmhuWqwsl6TG0FoxILalDGUiBvBXvJf4PS8E9/wlY88LgT2vkKTGAL5VVgD4V6YTfjNMovCvEkyKCfcKRi1b7aG41riJrMcz4wxdZ4WkdTxxP65kPUFP0LVcNYYCeA0jwNYJVmOoYAFJr5AD1jHUGCCBlTUik10letyzWC+Y6FGQrWeoMauBAi/Ut/ptOIHh2w0S1Ji1DFwb3VTgEyQVxLUZaow2NumFfbOXDTUmULAaQ0mykRHE3wguXOS0bxi4vpWgxgCJpKkxaxlqzAYvXkExs91i0z8mQ4vXbwE8ZL/FK+UDTof1gTZpbqxvFRzrVCi2MnBtE6zG0NlsAM8SaG5arGyTpMbQWgkgtk0MZSIB8Feil/g9rwX3vJmx57XAnrdLUmMA3yrbAfw70gm/GSZR+HcKJsWEezujln3nobi+dxNZT2TGGbrOdknreOJ+XMn6Lj1Bk7hqDAXw94wA2y1YjaGCBSS9Qg7YzVBjgARWvheZ7CrR457FHsFEj4JsD0ON+Q4o8EJ9q9+GdzF8u1eCGpPEwLXPTQV+l6SCmJShxmhjv17Yf/CyocYECFZjKEn2MYL4gODCRU47wMB1UIIaAySSpsYkMdSYvV68gmJm+6NN/5gMLV4PAnjI/kevlA84HdYH2qS5sX5IcKxToTjEwPWTYDWGzmYveJZAc9Ni5SdJagyttQvEtp+hTOwC/HXYS/yek8A9/8DYcxKw558lqTGAb5WfAfxH0gm/GSZR+H8RTIoJ98+MWnbUQ3EdcxNZP8yMM3SdnyWt44n7cSXrx/UEPcFVYyiAjzEC7KRgNYYKFpD0CjngJEONARJYOSYy2VWixz2LU4KJHgXZKYYacxQo8EJ9q9+GjzN8e1qCGnOCgeuMmwr8cUkF8USGGqONX/XCftbLhhrjL1iNoSQ5wwji3wQXLnLabwxcv0tQY4BE0tSYEww15rQXr6CY2f5h0z8mQ4vX3wE8ZP+HV8oHnA7rA23S3Fg/JzjWqVCcY+A6L1iNobM5DZ4l0Ny0WDkvSY2htY6D2H5lKBPHAX9d8BK/5xPgns8y9nwC2PNFSWoM4FvlIoD/UjrhN8MkCv9lwaSYcF9k1LIrHorrTzeR9QvMOEPXuShpHU/cjytZv6on6DWuGkMB/CcjwK4LVmOoYAFJr5ADrjPUGCCBlT9FJrtK9LhncUMw0aMgu8FQY64ABV6ob/Xb8FWGb29KUGOuMXD95aYCf1VSQbyWocZo42+9sN/ysqHG+AlWYyhJ/mIE8T+CCxc57R8GrtsS1BggkTQ15hpDjbnpxSsoZrZ3bPrHZGjxehvAQ/Z3vFI+4HRYH2iT5sb6XcGxToXiLgPXPcFqDJ3NTfAsgeamxco9SWoMrXUVxPY3Q5m4Cvjrvpf4PV8D93yLsedrwJ7/laTGAL5V/gXwP0gn/GaYROF/KJgUE+5/GbWMGK7TYX3IwqUAuNKTrN9nxhm6zr+S1vHE/biS9Uz6oXl5p7GwGZGmU6dgQQPM23qAsdQYKlhA0ivkAMKEEmMggRVFZLKrRI97Fj7gWaDBSUHm442foatv07NgcfZAt+FMDN/6CsZFaoAXA5efmwp8JtAf3HW8JK3j6WqMv35oAd421BhfwWoMJYkfI4gDBRcuclogA1cQGHwcNQZIJE2NoYRA1Rhfb15BMbPNbNM/JkOL1yAAD9lndqluTof1gTZpbqwHC451KhTBDFxZwLNE1Rg6G1/wLIHmpsVKFubZo4SG1soEYvP3xuM/E+CvrN7i9+wF7jmAsWcvYM/ZmOQAVWMA3yrZAPzZ0wm/GSZR+HMIJsWEOxujluX0UFxPuYmsZ2XGGbpONknreOJ+XMn60/qh5eKqMRTATzECLLdgNYYKFpD0CjkgN0ONARJYeUpksqtEj3sWeQQTPQqyPAw1JidQ4IX6Vr8NP83wbV4JakwuBq58birwT0sqiLky1BhtPKMfWn5vG2qMj2A1hpIkHyOICwguXOS0AgxcBSWoMUAiaWpMLoYak9ebV1DMbAvZ9I/J0OK1IICH7AtJUmO4se4UHOtUKJwMXIUFqzF0NnnBswSamxYrhSWpMbTW0yC2ZxjKxNOAv0K8xe85F7jn/Iw95wL2XESSGgP4VikC4C+aTvjNMInCX0wwKSbcRRi1rLiH4irhJrIewowzdJ0iktbxxP24kvWS+qGV4qoxFMAlGAFWWrAaQwULSHqFHFCaocYACayUEJnsKtHjnkUZwUSPgqwMQ40pDhR4ob7Vb8MlGb4tK0GNKcXAFeqmAl9SUkEslaHGaKOcfmjlvW2oMd6C1RhKklBGEFcQXLjIaRUYuCpKUGOARNLUmFIMNaasN6+gmNlWsukfk6HFa0UAD9lXkqTGcGO9suBYp0JRmYGrimA1hs6mLHiWQHPTYqWKJDWG1ioJYivHUCZKAv6q6i1+z6XAPZdn7LkUsOdqktQYwLdKNQB/9XTCb4ZJFP4agkkx4a7GqGXPeiiumm4i61WZcYauU03SOp64H1eyXks/tNpcNYYCuCYjwOoIVmOoYAFJr5AD6jDUGCCBlZoik10letyzqCuY6FGQ1WWoMc8CBV6ob/XbcC2Gb+tJUGNqM3DVd1OBryWpINbOUGO00UA/tOe8bagxXoLVGEqS+owgbii4cJHTGjJwPS9BjQESSVNjajPUmHrevIJiZtvIpn9MhhavzwN4yL6RJDWGG+uNBcc6FYrGDFxNBKsxdDb1wLMEmpsWK00kqTG0Vi0QWwOGMlEL8FdTb/F7rg3u+TnGnmsDe24mSY0BfKs0A/A3Tyf8ZphE4W8hmqx7PzpjtJa19FBcrdxE1psy4wxdp5mkdTxxP65kvbV+aG24agwFcCtGgLUVrMZQwQKSXiEHtGWoMUACK61EJrtK9Lhn8YJgokdB9gJDjWkJFHihvtVvw60Zvm0nQY1pw8DV3k0FvrWkgtgmQ43RRgf90Dp621BjMglWYyhJ2jOCuJPgwkVO68TA9aIENQZIJE2NacNQY9p58wqKmW1nm/4xGVq8vgjgIfvOktQYbqx3ERzrVCi6MHB1FazG0Nm0A88SaG5arHSVpMbQWq1BbB0YykRrwF/dvMXvuQ24546MPbcB9txdkhoD+FbpDuB/KZ3wm2EShf9lwaSYcHdn1LIeHoqrp5vIejdmnKHrdJe0jifux5Ws99IPrTdXjaEA7skIsD6C1RgqWEDSK+SAPgw1BkhgpafIZFeJHvcs+gomehRkfRlqTA+gwAv1rX4b7sXwbT8JakxvBq7+birwvSQVxN4Zaow2XtEP7VVvG2qMIliNoSTpzwji1wQXLnLaawxcAySoMUAiaWpMb4Ya08+bV1DMbAfa9I/J0OJ1AICH7AdKUmO4sT5IcKxToRjEwDVYsBpDZ9MPPEuguWmxMliSGkNr9QKxvcJQJnoB/hriLX7PvcE9v8rYc29gz0MlqTGAb5WhAP5h6YTfDJMo/MMFk2LCPZRRy0Z4KK6RbiLrQ5hxhq4zVNI6nrgfV7L+un5ob3DVGArgkYwAGyVYjaGCBSS9Qg4YxVBjgARWRopMdpXocc9itGCiR0E2mqHGjAAKvFDf6rfh1xm+HSNBjXmDgetNNxX41yUVxDcy1BhtjNUP7S1vG2qMQ7AaQ0nyJiOI3xZcuMhpbzNwjZOgxgCJpKkxbzDUmDHevIJiZvuOTf+YDC1exwF4yP4dSWoMN9bHC451KhTjGbgmCFZj6GzGgGf5pjcWKxMkqTH0g9dBbGMZysTrgL8meovf8xvgnt9i7PkNYM+TJKkxgG+VSQD+d9MJvxkmUfjfE0yKCfckRi1730NxTXYTWZ/IjDN0nUmS1vHE/biS9Sn6oX3AVWMogCczAmyqYDWGChaQ9Ao5YCpDjQESWJksMtlVosc9iw8FEz0Ksg8Zasz7QIEX6lv9NjyF4dtpEtSYDxi4prupwE+RVBA/yFBjtDFDP7SPvG2oMQ8Ve0Fs1kQoSaYzgvhjwYWLnPYxA9dMCWoMkEiaGvMBQ42Z5s0rKGa2s2z6x2Ro8ToTwEP2sySpMdxYny041qlQzGbgmiNYjaGzmQaeJdDctFiZI0mNobWmgNhmMJSJKYC/wrzF7/kDcM8fMfb8AbDnuZLUGMC3ylwAf3g64TfDJAr/J4JJMeGey6hlER6K61M3kfUwZpyh68yVtI4n7seVrH+mH1okV42hAP6UEWDzBKsxVLCApFfIAfMYagyQwMqnIpNdJXrcs5gvmOhRkM1nqDERQIEX6lv9NvwZw7dREtSYSAauz91U4D+TVBAjM9QYbSzQD+0LbxtqzAPFXhCbNRFKks8ZQRwtuHCR06IZuGIkqDFAImlqTCRDjYny5hUUM9uFNv1jMrR4jQHwkP1CSWoMN9YXCY51KhSLGLhiBasxdDZR4FkCzU2LlVhJagyt9RmIbQFDmfgM8Ndib/F7jgT3/AVjz5HAnpdIUmMA3ypLAPxL0wm/GSZR+L8UTIoJ9xJGLYvzUFxfuYmsL2bGGbrOEknreOJ+XMn61/qhLeOqMRTAXzECbLlgNYYKFpD0CjlgOUONARJY+UpksqtEj3sW8YKJHgVZPEONiQMKvFDf6rfhrxm+XSFBjVnGwLXSTQX+a0kFcVmGGqONVfqhrfa2ocb8q9gLYrMmQkmykhHEawQXLnLaGgauBAlqDJBImhqzjKHGrPDmFRQz27U2/WMytHhNAPCQ/VpJagw31tcJjnUqFOsYuNYLVmPobFaAZwk0Ny1W1ktSY2itr0FsqxjKxNeAvzZ4i9/zMnDPqxl7XgbseaMkNQbwrbIRwL8pnfCbYRKFf7NgUky4NzJq2TceiutbN5H1Dcw4Q9fZKGkdT9yPK1nfoh/aVq4aQwH8LSPAtglWY6hgAUmvkAO2MdQYIIGVb0Umu0r0uGeRKJjoUZAlMtSYb4ACL9S3+m14C8O32yWoMVsZuHa4qcBvkVQQt2aoMdrYqR/ad9421Jj7ir0gNmsilCQ7GEH8veDCRU77noFrlwQ1BkgkTY3ZylBjtnvzCoqZbZJN/5gMLV53AXjIPkmSGsON9d2CY50KxW4Grj2C1Rg6m+3gWQLNTYuVPZLUGFprC4htJ0OZ2AL4a6+3+D1vBff8HWPPW4E975OkxgC+VfYB+PenE34zTKLw/yCYFBPufYxadsBDcR10E1nfy4wzdJ19ktbxxP24kvUf9UM7xFVjKIAPMgLsJ8FqDBUsIOkVcsBPDDUGSGDloMhkV4ke9ywOCyZ6FGSHGWrMAaDAC/Wtfhv+keHbnyWoMYcYuI64qcD/KKkgHspQY7Txi35oR71tqDH3FHtBbNZEKEmOMIL4mODCRU47xsB1XIIaAySSpsYcYqgxP3vzCoqZ7Qmb/jEZWrweB/CQ/QlJagw31k8KjnUqFCcZuE4JVmPobH4GzxJoblqsnJKkxtBaP4LYfmEoEz8C/jrtLX7Ph8A9H2Xs+RCw5zOS1BjAt8oZAP+v6YTfDJMo/GcFk2LCfYZRy37zUFy/u4msn2bGGbrOGUnreOJ+XMn6H/qhneOqMRTAvzMC7LxgNYYKFpD0CjngPEONARJY+V1ksqtEj3sWFwQTPQqyCww15jegwAv1rX4b/oPh24sS1JhzDFyX3FTg/5BUEM9lqDHauKwf2hVvG2rMXcVeEJs1EUqSS4wg/lNw4SKn/cnAdVWCGgMkkqbGnGOoMRe9eQXFzPaaTf+YDC1erwJ4yP6aJDWGG+vXBcc6FYrrDFw3BKsxdDYXwbMEmpsWKzckqTG01h8gtssMZeIPwF83vcXv+Ry45yuMPZ8D9vyXJDUG8K3yF4D/73TCb4ZJFP5bgkkx4f6LUcv+8VBct91E1m8y4wxd5y9J63jiflzJ+h390O5y1RgK4NuMALsnWI2hgnULaQLejzChxBhIYOW2yGRXiR73LO4LJnoUZPcZasw/QIEX6lv9NnyH4dt/Jagxdxm4HripwN+RVBDvZqgx2niYfGg+NtSYO4q9IDZrIpQkDxhBrPiILVya03xwXJl8MH9x1BggkTQ15i5DjfnXm1dQzGy9bPrHZGjx6noGZnjInjA5sHUeLYb8Rm3S3Fj3FhzrVCi8GbHuA54lqsbQ2SBxSPZAc9NixYd59iihobXugNgeMpSJO4C/fH3E7/kuuGequ7ACC+zZD9xz8kDVGMC3ih9Qr/zTCb8ZJlH4A0D8aC0j3H6MWhboobiCAFzpSdZ9mXGGruMnaR1P3I8rWc+s96FgnzQWNiPSFMBBjADLApILtAlQwQKSXiEHZPHBiTGQwEqQyGRXiR73LLIKJnoUZFl98DMMBAq8UN/qt+HMDN9mE4yL1IBgBq7sbirwmSUVxGBJ63i6GpNDL+w57agxtxV7QWzWRChJsjOC+CnBhYuc9hQD19MS1BggkTQ1hhICVWOy+fAKipltLpv+MRlavD4N4CH7XMwbOdqkubGeW3CsU6HIzcCVR7AaQ2eTDTxLoLlpsZJHkhpDa2UGseVgKBOZAX/l9RG/52BwzzkZew4G9pxPkhoD+FbJB+B/Jp3wm2EShT+/YFJMuPMxalkBD8VV0E1kPS8zztB18klaxxP340rWC+l9yMlVYyiACzICrLBgNYYKFpD0CjmgMEONARJYKSgy2VWixz2LEMFEj4IshKHGFAAKvFDf6rfhQgzfFpGgxjgZuIq6qcAXklQQnRlqjDaK6YW9uI8NNeYfxV4QmzURSpKijCAuIbhwkdNKMHCVlKDGAImkqTFOhhpTxIdXUMxsS9n0j8nQ4rUkgIfsS/mkfMDpsD7QJs2N9dKCY50KRWkGrjKC1Rg6myLgWQLNTYuVMpLUGFqrEIitGEOZKAT4q6yP+D07wT0XZ+zZCew5VJIaA/hWCQXwl0sn/GaYROEvL5gUE+5QRi2r4KG4KrqJrJdlxhm6TqikdTxxP65kvZLehypz1RgK4IqMAKsiWI2hggUkvUIOqMJQY4AEViqKTHaV6HHPoqpgokdBVpWhxlQACrxQ3+q34UoM31aToMZUZuCq7qYCX0lSQaycocZoo4Ze2J/1saHG3FLsBbFZE6Ekqc4I4pqCCxc5rSYDVy0JagyQSJoaU5mhxlTz4RUUM9vaNv1jMrR4rQXgIfvaPikfcDqsD7RJc2O9juBYp0JRh4GrrmA1hs6mGniWQHPTYqWuJDWG1qoEYqvBUCYqAf6q5yN+z5XBPT/L2HNlYM/1JakxgG+V+gD+BumE3wyTKPzPCSbFhLs+o5Y19FBcz7uJrNdjxhm6Tn1J63jiflzJeiO9DzXmqjEUwM8zAqyJYDWGChaQ9Ao5oAlDjQESWHleZLKrRI97Fk0FEz0KsqYMNaYhUOCF+la/DTdi+LaZBDWmMQNXczcV+EaSCmLjDDVGGy30wt7Sx4Ya87diL4jNmgglSXNGELcSXLjIaa0YuFpLUGOARNLUmMYMNaaZD6+gmNm2sekfk6HFa2sAD9m38Un5gNNhfaBNmhvrbQXHOhWKtgxcLwhWY+hsmoFnCTQ3LVZekKTG0FqNQGwtGMpEI8Bf7XzE77kxuOeWjD03BvbcXpIaA/hWaQ/g75BO+M0wicLfUTApJtztGbWsk4fietFNZL0dM87QddpLWscT9+NK1jvrfagLV42hAH6REWBdBasxVLCApFfIAV0ZagyQwMqLIpNdJXrcs+gmmOhRkHVjqDGdgAIv1Lf6bbgzw7fdJagxXRi4XnJTge8sqSB2yVBjtPGyXth7+NhQY/5S7AWxWROhJHmJEcQ9BRcuclpPBq5eEtQYIJE0NaYLQ43p7sMrKGa2vW36x2Ro8doLwEP2vX1SPuB0WB9ok+bGeh/BsU6Fog8DV1/BagydTXfwLIHmpsVKX0lqDK3VGcT2MkOZ6Az4q5+P+D13Affcg7HnLsCe+0tSYwDfKv0B/K+kE34zTKLwvyqYFBPu/oxa9pqH4hrgJrLejxln6Dr9Ja3jiftxJesD9T40iKvGUAAPYATYYMFqDBUsIOkVcsBghhoDJLAyQGSyq0SPexZDBBM9CrIhDDXmNaDAC/WtfhseyPDtUAlqzCAGrmFuKvADJRXEQRlqjDaG64V9hI8NNeamYi+IzZoIJckwRhCPFFy4yGkjGbhel6DGAImkqTGDGGrMUB9eQTGzfcOmf0yGFq+vA3jI/g2flA84HdYH2qS5sT5KcKxToRjFwDVasBpDZzMUPEuguWmxMlqSGkNrDQSxDWcoEwMBf43xEb/nQeCeRzD2PAjY85uS1BjAt8qbAP6x6YTfDJMo/G8JJsWE+01GLXvbQ3GNcxNZH8OMM3SdNyWt44n7cSXr7+h9aDxXjaEAHscIsAmC1RgqWEDSK+SACQw1BkhgZZzIZFeJHvcsJgomehRkExlqzNtAgRfqW/02/A7Dt5MkqDHjGbjedVOBf0dSQRyfocZo4z29sL/vY0ONuaHYC2KzJkJJ8i4jiCcLLlzktMkMXFMkqDFAImlqzHiGGjPJh1dQzGw/sOkfk6HF6xQAD9l/4JPyAafD+kCbNDfWpwqOdSoUUxm4PhSsxtDZTALPEmhuWqx8KEmNobXeAbG9x1Am3gH8Nc1H/J7Hg3t+n7Hn8cCep0tSYwDfKtMB/DPSCb/JUETh/0gwKSbc0xm17GMPxTXTTWR9GjPO0HWmS1rHE/fjStZn6X1oNleNoQCeyQiwOYLVGCpYQNIr5IA5DDUGSGBlpshkV4ke9yzCBBM9CrIwhhrzMVDghfpWvw3PYvh2rgQ1ZjYDV7ibCvwsSQVxdoYao41P9MIe4WNDjbmu2AtisyZCSRLOCOJPBRcuctqnDFyfSVBjgETS1JjZDDVmrg+voJjZRtr0j8nQ4vUzAA/ZR/qkfMDpsD7QJs2N9XmCY50KxTwGrvmC1Rg6m7ngWQLNTYuV+ZLUGFprFojtE4YyMQvwV5SP+D3PBvccwdjzbGDPn0tSYwDfKp8D+BekE34zTKLwfyGYFBPuzxm1LNpDccW4iaxHMeMMXedzSet44n5cyfpCvQ8t4qoxFMAxjACLFazGUMECkl4hB8Qy1BgggZUYkcmuEj3uWSwWTPQoyBYz1JhooMAL9a1+G17I8O0SCWrMIgaupW4q8AslFcRFGWqMNr7UC3ucjw015ppiL4jNmgglyVJGEH8luHCR075i4PpaghoDJJKmxixiqDFLfHgFxcx2mU3/mAwtXr8G8JD9Mp+UDzgd1gfapLmxvlxwrFOhWM7AFS9YjaGzWQKeJdDctFiJl6TG0FoLQWxfMpSJhYC/VviI3/MicM9xjD0vAva8UpIaA/hWWQngX5VO+M0wicK/WjApJtwrGbVsjYfiSnATWV/BjDN0nZWS1vHE/biS9bV6H1rHVWMogBMYAbZesBpDBQtIeoUcsJ6hxgAJrCSITHaV6HHPYoNgokdBtoGhxqwBCrxQ3+q34bUM326UoMasY+Da5KYCv1ZSQVyXocZoY7Ne2L/xsaHGXFXsBbFZE6Ek2cQI4m8FFy5y2rcMXFskqDFAImlqzDqGGrPRh1dQzGy32vSPydDidQuAh+y3+qR8wOmwPtAmzY31bYJjnQrFNgauRMFqDJ3NRvAsgeamxUqiJDWG1loLYtvMUCbWAv7a7iN+z+vAPX/D2PM6YM87JKkxgG+VHQD+nemE3wyTKPzfCSbFhHsHo5Z976G4drmJrG9nxhm6zg5J63jiflzJepLeh3Zz1RgK4F2MANsjWI2hggUkvUIO2MNQY4AEVnaJTHaV6HHPYq9gokdBtpehxnwPFHihvtVvw0kM3+6ToMbsZuDa76YCnySpIO7OUGO08YNe2A/42FBj/lTsBbFZE6Ek2c8I4oOCCxc57SAD148S1BggkTQ1ZjdDjdnnwysoZraHbPrHZGjx+iOAh+wP+aR8wOmwPtAmzY31nwTHOhWKnxi4DgtWY+hs9oFnCTQ3LVYOS1JjaK0kENsPDGUiCfDXzz7i97wb3PMBxp53A3s+IkmNAXyrHAHw/5JO+M0wicJ/VDApJtxHGLXsmIfiOu4msv4zM87QdY5IWscT9+NK1k/ofegkV42hAD7OCLBTgtUYKlhA0ivkgFMMNQZIYOW4yGRXiR73LE4LJnoUZKcZaswxoMAL9a1+Gz7B8O0ZCWrMSQauX91U4E9IKognM9QYbZzVC/tvPjbUmCuKvSA2ayKUJL8ygvh3wYWLnPY7A9cfEtQYIJE0NeYkQ40548MrKGa252z6x2Ro8foHgIfsz/mkfMDpsD7QJs2N9fOCY50KxXkGrguC1Rg6mzPgWQLNTYuVC5LUGFrrBIjtLEOZOAH466KP+D2fBPf8G2PPJ4E9X5KkxgC+VS4B+C+nE34zTKLwXxFMign3JUYt+9NDcV11E1m/yIwzdJ1LktbxxP24kvVreh+6zlVjKICvMgLshmA1hgoWkPQKOeAGQ40BEli5KjLZVaLHPYubgokeBdlNhhrzJ1DghfpWvw1fY/j2LwlqzHUGrr/dVOCvSSqI1zPUGG3c0gv7Pz421JjLir0gNmsilCR/M4L4tuDCRU67zcB1R4IaAySSpsZcZ6gxf/nwCoqZ7V2b/jEZWrzeQW43yiNMDmydR4shv1GbNDfW7wmOdSoU9xi47gtWY+hs/gLPEmhuWqzcl6TG0FrXQGy3GMrENcBf//qI3/N1cM//MPZ8HdjzA0lqDOBb5QGA/2E64TfDJAq/w1csKSbcDxi1TPFQXJkAXOlJ1v9lxhm6zgNJ63jiflzJupfvo7e3bxoLmxFpCmAKFjTAfKwHmOIK2mnx+1SwgKRXyAGECSXGQAIrmUQmu0r0uGfhC54FGpwUZL6++Bm6+jY9CxZnD3Qb9mL41k8wLlIDvBm4/N1U4L1Af3DX8Za0jqerMQF6YQ/0taHGXFLsBbFZE6Ek8WcEcZDgwkVOC2LgygwGH0eNARJJU2MoIVA1xs+XV1DMbINt+sdkaPGaGcBD9sG+KR9wOqwPtElzYz2L4FinQpGFgSsreJaoGkNn4weeJdDctFjJyjx7lNDQWl4gtgBfPP69AH9l8xW/Z29wz4GMPXsDe87OJAeoGgP4VskO4M+RTvjNMInCn1MwKSbc2Rm17CkPxfW0m8h6Nmacoetkl7SOJ+7Hlazn0vtQbq4aQwH8NCPA8ghWY6hgAUmvkAPyMNQYIIGVp0Umu0r0uGeRVzDRoyDLy1BjngIKvFDf6rfhXAzf5pOgxuRm4HrGTQU+l6SCmDtDjdFGfr2wF/C1ocZcVOwFsVkToSR5hhHEBQUXLnJaQQauQhLUGCCRNDUmN0ONyefLKyhmtk6b/jEZWrwWAvBo8e2b8gGnw/pAmzQ31gsLjnUqFIUZuEIEqzF0NvnAswSamxYrIZLUGForF4gtP0OZyAX4q4iv+D3nBvdcgLHn3MCei0pSYwDfKkUB/MXSCb8ZJlH4iwsmxYS7KKOWlfBQXCXdRNaLMOMMXaeopHU8cT+uZL2U3odKc9UYCuCSjAArI1iNoYIFJL1CDijDUGOABFZKikx2lehxz6KsYKJHQVaWocaUAAq8UN/qt+FSDN+GSlBjSjNwlXNTgS8lqSCWzlBjtFFeL+wVfG2oMRcUe0Fs1kQoScoxgrii4MJFTqvIwFVJghoDJJKmxpRmqDGhvryCYmZb2aZ/TIYWr5UAPGRf2TflA06H9YE2aW6sVxEc61QoqjBwVRWsxtDZhIJnCTQ3LVaqSlJjaK1SILbyDGWiFOCvar7i91wa3HMFxp5LA3uuLkmNAXyrVAfw10gn/GaYROF/VjApJtzVGbWspofiquUmsl6NGWfoOtUlreOJ+3El67X1PlSHq8ZQANdiBFhdwWoMFSwg6RVyQF2GGgMksFJLZLKrRI97FvUEEz0KsnoMNaYmUOCF+la/Dddm+La+BDWmDgNXAzcV+NqSCmKdDDVGG8/phb2hrw015rxiL4jNmgglSQNGED8vuHCR055n4GokQY0BEklTY+ow1Jj6vryCYmbb2KZ/TIYWr40APGTf2DflA06H9YE2aW6sNxEc61QomjBwNRWsxtDZ1AfPEmhuWqw0laTG0Fq1QWzPMZSJ2oC/mvmK33MdcM8NGXuuA+y5uSQ1BvCt0hzA3yKd8JthEoW/pWBSTLibM2pZKw/F1dpNZL0ZM87QdZpLWscT9+NK1tvofagtV42hAG7NCLAXBKsxVLCApFfIAS8w1BgggZXWIpNdJXrcs2gnmOhRkLVjqDGtgAIv1Lf6bbgNw7ftJagxbRm4OripwLeRVBDbZqgx2uioF/ZOvjbUmHOKvSA2ayKUJB0YQfyi4MJFTnuRgauzBDUGSCRNjWnLUGPa+/IKipltF5v+MRlavHYG8JB9F9+UDzgd1gfapLmx3lVwrFOh6MrA1U2wGkNn0x48S6C5abHSTZIaQ2u1AbF1ZCgTbQB/dfcVv+e24J47MfbcFtjzS5LUGMC3yksA/pfTCb8ZJlH4ewgmxYT7JUYt6+mhuHq5iax3Z8YZus5LktbxxP24kvXeeh/qw1VjKIB7MQKsr2A1hgoWkPQKOaAvQ40BEljpJTLZVaLHPYt+gokeBVk/hhrTEyjwQn2r34Z7M3zbX4Ia04eB6xU3Ffjekgpinww1Rhuv6oX9NV8baswfir0gNmsilCSvMIJ4gODCRU4bwMA1UIIaAySSpsb0Yagx/X15BcXMdpBN/5gMLV4HAnjIfpBvygecDusDbdLcWB8sONapUAxm4BoiWI2hs+kPniXQ3LRYGSJJjaG1eoPYXmUoE70Bfw31Fb/nPuCeX2PsuQ+w52GS1BjAt8owAP/wdMJvhkkU/hGCSTHhHsaoZSM9FNfrbiLrQ5lxhq4zTNI6nrgfV7L+ht6HRnHVGArg1xkBNlqwGkMFC0h6hRwwmqHGAAmsvC4y2VWixz2LMYKJHgXZGIYaMxIo8EJ9q9+G32D49k0JaswoBq6xbirwb0gqiKMy1BhtvKUX9rd9bagxvyv2gtisiVCSjGUE8TjBhYucNo6B6x0JagyQSJoaM4qhxrzpyysoZrbjbfrHZGjx+g6Ah+zH+6Z8wOmwPtAmzY31CYJjnQrFBAauiYLVGDqbN8GzBJqbFisTJakxtNYbILa3GMrEG4C/JvmK3/MocM9vM/Y8Ctjzu5LUGMC3yrsA/vfSCb8ZJlH43xdMign3u4xaNtlDcU1xE1mfxIwzdJ13Ja3jiftxJesf6H1oKleNoQCewgiwDwWrMVSwgKRXyAEfMtQYIIGVKSKTXSV63LOYJpjoUZBNY6gxk4ECL9S3+m34A4Zvp0tQY6YycM1wU4H/QFJBnJqhxmjjI72wf+xrQ435TbEXxGZNhJJkBiOIZwouXOS0mQxcsySoMUAiaWrMVIYaM92XV1DMbGfb9I/J0OJ1FoCH7Gf7pnzA6bA+0CbNjfU5gmOdCsUcBq4wwWoMnc108CyB5qbFSpgkNYbW+gDE9hFDmfgA8NdcX/F7ngru+WPGnqcCew6XpMYAvlXCAfyfpBN+M0yi8EcIJsWEO5xRyz71UFyfuYmsz2XGGbpOuKR1PHE/rmQ9Uu9D87hqDAXwZ4wAmy9YjaGCBSS9Qg6Yz1BjgARWPhOZ7CrR455FlGCiR0EWxVBjPgUKvFDf6rfhSIZvP5egxsxj4FrgpgIfKakgzstQY7TxhV7Yo31tqDFnFXtBbNZEKEkWMII4RnDhIqfFMHAtlKDGAImkqTHzGGrM5768gmJmu8imf0yGFq8LATxkv8g35QNOh/WBNmlurMcKjnUqFLEMXIsFqzF0Np+DZwk0Ny1WFktSY2itSBDbFwxlIhLw1xJf8XueB+45mrHnecCel0pSYwDfKksB/F+mE34zTKLwxwkmxYR7KaOWfeWhuL52E1lfwowzdJ2lktbxxP24kvVleh9azlVjKIC/ZgRYvGA1hgoWkPQKOSCeocYACax8LTLZVaLHPYsVgokeBdkKhhrzFVDghfpWvw0vY/h2pQQ1ZjkD1yo3Ffhlkgri8gw1Rhur9cK+xteGGvOrYi+IzZoIJckqRhAnCC5c5LQEBq61EtQYIJE0NWY5Q41Z6csrKGa262z6x2Ro8boWwEP263xTPuB0WB9ok+bG+nrBsU6FYj0D1wbBagydzUrwLIHmpsXKBklqDK21DMS2mqFMLAP8tdFX/J6Xg3tew9jzcmDPmySpMYBvlU0A/s3phN8Mkyj83wgmxYR7E6OWfeuhuLa4iaxvZMYZus4mSet44n5cyfpWvQ9t46oxFMBbGAGWKFiNoYIFJL1CDkhkqDFAAitbRCa7SvS4Z7FdMNGjINvOUGO+BQq8UN/qt+GtDN/ukKDGbGPg2ummAr9VUkHclqHGaOM7vbB/72tDjTmj2AtisyZCSbKTEcS7BBcuctouBq4kCWoMkEiaGrONocbs8OUVFDPb3Tb9YzK0eE0C8JD9bt+UDzgd1gfapLmxvkdwrFOh2MPAtVewGkNnswM8S6C5abGyV5IaQ2ttBbF9x1AmtgL+2ucrfs/bwD1/z9jzNmDP+yWpMYBvlf0A/h/SCb8ZJlH4DwgmxYR7P6OWHfRQXD+6iazvY8YZus5+Set44n5cyfohvQ/9xFVjKIB/ZATYYcFqDBUsIOkVcsBhhhoDJLDyo8hkV4ke9yx+Fkz0KMh+ZqgxB4ECL9S3+m34EMO3RySoMT8xcP3ipgJ/SFJB/ClDjdHGUb2wH/O1ocacVuwFsVkToST5hRHExwUXLnLacQauExLUGCCRNDXmJ4Yac8SXV1DMbE/a9I/J0OL1BICH7E/6pnzA6bA+0CbNjfVTgmOdCsUpBq7TgtUYOpsj4FkCzU2LldOS1Bha6xCI7ShDmTiEqFe+4vf8E7jnY4w9/wTs+VdJagzgW+VXAP/ZdMJvhkkU/t8Ek2LC/Sujlv3uobj+cBNZP8OMM3SdXyWt44n7cSXr5/Q+dJ6rxlAA/8EIsAuC1RgqWEDSK+SACww1Bkhg5Q+Rya4SPe5ZXBRM9CjILjLUmN+BAi/Ut/pt+BzDt5ckqDHnGbguu6nAn5NUEM9nqDHauKIX9j99bagxpxR7QWzWRChJLjOC+KrgwkVOu8rAdU2CGgMkkqbGnGeoMZd8eQXFzPa6Tf+YDC1erwF4yP66b8oHnA7rA23S3Fi/ITjWqVDcYOC6KViNobO5BJ4l0Ny0WLkpSY2htc6B2K4wlIlzgL/+8hW/5/Pgnv9k7Pk8sOe/JakxgG+VvwH8t9IJvxkmUfj/EUyKCfffjFp220Nx3XETWf+LGWfoOn9LWscT9+NK1u/qfegeV42hAL7DCLD7gtUYKlhA0ivkgPsMNQZIYOWOyGRXiR73LP4VTPQoyP5lqDG3gQIv1Lf6bfguw7cPJKgx9xi4HrqpwN+VVBDvZagxj4af/gE/G2rMScVeEJs1EUqSh4wgzuQntnCR0zL54bi8/DB/cdQYIJE0NeYeQ4154MsrKGa23jb9YzK0eHU9A9O/q6M8wuTA1nm0GPIbtUlzY91HcKxTofBhxLoveJaoGkNng8Qh2QPNTYsVX+bZo4SG1roLYqNzQeP/LuAvPz/xe74H7llh7PkesGd/cM/JA1VjAN8q/kC9Ckgn/GaYROEPBPGjtYxw+zNqWZCH4soM4EpPsu7HjDN0HX9J63jiflzJerDeh7L4pbGwGZGmAM7MCLCsILlAmwAVLCDpFXJAVj+cGAMJrGQWmewq0eOeRTbBRI+CLJsffoZBQIEX6lv9NhzM8G12wbhIDcjCwJXDTQU+WFJBzCJpHU9XY3Lqhf0pO2rMCcVeEJs1EUqSHIwgflpw4SKnPc3AlUuCGgMkkqbGUEKgakx2P15BMbPNbdM/JkOL11wAHrLPzbyRo02aG+t5BMc6FYo8DFx5BasxdDbZwbMEmpsWK3klqTG0VjCILSdDmQgG/JXPT/yes4B7foqx5yzAnp+RpMYAvlWeAfDnTyf8ZphE4S8gmBQT7mcYtaygh+Iq5Cayno8ZZ+g6z0haxxP340rWnXofKsxVYyiACzECLESwGkMFC0h6hRwQwlBjgARWColMdpXocc+iiGCiR0FWhKHGFAQKvFDfJt+GGb4tKkGNKczAVcxNBd4pqSAWzlBjtFFcL+wl/GyoMccVe0Fs1kQoSYoxgrik4MJFTivJwFVKghoDJJKmxhRmqDFF/XgFxcy2tE3/mAwtXksBeMi+tF/KB5wO6wNt0txYLyM41qlQlGHgKitYjaGzKQqeJdDctFgpK0mN0eooiK04Q5lwAv4K9RO/58Lgnksw9lwY2HM5SWoM4FulHIC/fDrhN8MkCn8FwaSYcJdj1LKKHoqrkpvIeigzztB1yklaxxP340rWK+t9qApXjaEArsQIsKqC1RgqWEDSK+SAqgw1BkhgpZLIZFeJHvcsqgkmehRk1RhqTEWgwAv1rX4brszwbXUJakwVBq4abirwlSUVxCoZaow2ntULe00/G2rMMcVeEJs1EUqSGowgriW4cJHTajFw1ZagxgCJpKkxVRhqTHU/XkExs61j0z8mQ4vX2gAesq/jl/IBp8P6QJs0N9brCo51KhR1GbjqCVZj6Gyqg2cJNDctVupJUmNorcogtmcZykRlwF/1/cTvuQq455qMPVcB9txAkhoD+FZpAOB/Lp3wm2EShb+hYFJMuBswatnzHoqrkZvIen1mnKHrNJC0jifux5WsN9b7UBOuGkMB3IgRYE0FqzFUsICkV8gBTRlqDJDASiORya4SPe5ZNBNM9CjImjHUmOeBAi/Ut/ptuDHDt80lqDFNGLhauKnAN5alkmSoMdpoqRf2Vn421Jijir0gNmsilCQtGEHcWnDhIqe1ZuBqI0GNARJJU2OaMNSY5n68gmJm29amf0yGFq9tADxk39Yv5QNOh/WBNmlurL8gONapULzAwNVOsBpDZ9McPEuguWmx0k6SGkNrNQaxtWQoE40Bf7X3E7/nJuCeWzH23ATYcwdJagzgW6UDgL9jOuE3wyQKfyfBpJhwd2DUshc9FFdnN5H19sw4Q9fpIGkdT9yPK1nvovehrlw1hgK4MyPAuglWY6hgAUmvkAO6MdQYIIGVziKTXSV63LPoLpjoUZB1Z6gxLwIFXqhv9dtwF4ZvX5KgxnRl4HrZTQW+i6SC2DVDjdFGD72w9/Szocb8otgLYrMmQknyMiOIewkuXOS0XgxcvSWoMV2Q5qYXCVSNecmPV1DMbPvY9I/J0OK1N4CH7Pv4pXzA6bA+0CbNjfW+gmOdCkVfBq5+gtUYOpuXwLMEmpsWK/0kqTG0VhcQWw+GMtEF8Fd/P/F77gruuSdjz12BPb8iSY0BfKu8AuB/NZ3wm2EShf81waSYcL/CqGUDPBTXQDeR9f7MOEPXeUXSOp64H1eyPkjvQ4O5agwF8EBGgA0RrMZQwQKSXiEHDGGoMUACKwNFJrtK9LhnMVQw0aMgG8pQYwYABV6ob/Xb8CCGb4dJUGMGM3ANd1OBHySpIA7OUGO0MUIv7CP9bKgxRxR7QWzWRChJhjOC+HXBhYuc9joD1xsS1BggkTQ1ZjBDjRnmxysoZrajbPrHZGjx+gaAh+xH+aV8wOmwPtAmzY310YJjnQrFaAauMYLVGDqbYeBZAs1Ni5UxktQYWmsQiG0EQ5kYBPjrTT/xex4M7nkkY8+DgT2PlaTGAL5VxgL430on/GaYROF/WzApJtxjGbVsnIfiesdNZP1NZpyh64yVtI4n7seVrI/X+9AErhpDAfwOI8AmClZjqGABSa+QAyYy1BgggZV3RCa7SvS4ZzFJMNGjIJvEUGPGAQVeqG/12/B4hm/flaDGTGDges9NBX68pII4IUON0cb7emGf7GdDjflZsRfEZk2EkuQ9RhBPEVy4yGlTGLg+kKDGAImkqTETGGrMu368gmJmO9Wmf0yGFq8fAHjIfqpfygecDusDbdLcWP9QcKxTofiQgWuaYDWGzuZd8CyB5qbFyjRJagytNR7E9j5DmRgP+Gu6n/g9TwD3PJmx5wnAnmdIUmMA3yozAPwfpRN+M0yi8H8smBQT7hmMWjbTQ3HNchNZn86MM3SdGZLW8cT9uJL12XofmsNVYyiAZzECLEywGkMFC0h6hRwQxlBjgARWZolMdpXocc9irmCiR0E2l6HGzAQKvFDf6rfh2QzfhktQY+YwcH3ipgI/W1JBnJOhxmgjQi/sn/rZUGMOK/aC2KyJUJJ8wgjizwQXLnLaZwxckRLUGCCRNDVmDkONCffjFRQz23k2/WMytHiNBPCQ/Ty/lA84HdYH2qS5sT5fcKxToZjPwBUlWI2hswkHzxJoblqsRElSY2it2SC2CIYyMRvw1+d+4vc8B9zzp4w9zwH2vECSGgP4VlkA4P8infCbYRKFP1owKSbcCxi1LMZDcS10E1n/nBln6DoLJK3jiftxJeuL9D4Uy1VjKIAXMgJssWA1hgoWkPQKOWAxQ40BElhZKDLZVaLHPYslgokeBdkShhoTAxR4ob7Vb8OLGL5dKkGNiWXg+tJNBX6RpIIYm6HGaCNOL+xf+dlQY35S7AWxWROhJPmSEcRfCy5c5LSvGbiWSVBjgETS1JhYhhqz1I9XUMxsl9v0j8nQ4nUZgIfsl/ulfMDpsD7QJs2N9XjBsU6FIp6Ba4VgNYbOZil4lkBz02JlhSQ1htZaBGKLYygTiwB/rfQTv+dYcM9fMfYcC+x5lSQ1BvCtsgrAvzqd8JthEoV/jWBSTLhXMWpZgofiWusmsr6SGWfoOqskreOJ+3El6+v0PrSeq8ZQAK9lBNgGwWoMFSwg6RVywAaGGgMksLJWZLKrRI97FhsFEz0Kso0MNSYBKPBCfavfhtcxfLtJghqznoFrs5sK/DpJBXF9hhqjjW/0wv6tnw015pBiL4jNmgglyWZGEG8RXLjIaVsYuLZKUGOARNLUmPUMNWaTH6+gmNlus+kfk6HF61YAD9lv80v5gNNhfaBNmhvriYJjnQpFIgPXdsFqDJ3NJvAsgeamxcp2SWoMrbUOxPYNQ5lYB/hrh5/4Pa8H9/wtY8/rgT3vlKTGAL5VdgL4v0sn/GaYROH/XjApJtw7GbVsl4fiSnITWd/BjDN0nZ2S1vHE/biS9d16H9rDVWMogJMYAbZXsBpDBQtIeoUcsJehxgAJrCSJTHaV6HHPYp9gokdBto+hxuwCCrxQ3+q34d0M3+6XoMbsYeD6wU0FfrekgrgnQ43RxgG9sB/0s6HG/KjYC2KzJkJJ8gMjiH8UXLjIaT8ycB2SoMYAiaSpMXsYasx+P15BMf3zcpv+MRlavB4C8JD9T34pH3A6rA+0SXNj/bDgWKdCcZiB62fBagydzX7wLIHmpsXKz5LUGFprN4jtAEOZ2A3464if+D3vAfd8kLHnPcCef5GkxgC+VX4B8B9NJ/xmmEThPyaYFBPuXxi17LiH4jrhJrJ+hBln6Dq/SFrHE/fjStZP6n3oFFeNoQA+wQiw04LVGCpYQNIr5IDTDDUGSGDlhMhkV4ke9yzOCCZ6FGRnGGrMcaDAC/Wtfhs+yfDtrxLUmFMMXGfdVOBPSiqIpzLUGG38phf23/1sqDEHFXtBbNZEKEnOMoL4D8GFi5z2BwPXOQlqDJBImhpziqHG/OrHKyhmtudt+sdkaPF6DsBD9uf9Uj7gdFgfaJPmxvoFwbFOheICA9dFwWoMnc2v4FkCzU2LlYuS1Bha6ySI7TeGMnES8NclP/F7PgXu+XfGnk8Be74sSY0BfKtcBvBfSSf8ZphE4f9TMCkm3JcZteyqh+K65iayfokZZ+g6lyWt44n7cSXr1/U+dIOrxlAAX2ME2E3BagwVLCDpFXLATYYaAySwck1ksqtEj3sWfwkmehRkfzHUmKtAgRfqW/02fJ3h278lqDE3GLhuuanAX5dUEG9kqDHa+Ecv7Lf9bKgxBxR7QWzWRChJbjGC+I7gwkVOu8PAdVeCGgMkkqbG3GCoMX/78QqKme09m/4xGVq83gXwkP09v5QPOB3WB9qkubF+X3CsU6G4z8D1r2A1hs7mb/Asgeamxcq/ktQYWus6iO0fhjJxHfDXAz/xe74B7vk2Y883gD0/lKTGAL5VHgL4Hf7pg98Mkyj8CogfrWWE+yGjlmXyUFxeAK70JOsPmHmCrvNQ0jqeuB9Xsu7t/+jt45/GwmZEmgKYggUNMF/rAaa4gnZa/D4VLCDpFXIAYUKJMZDAipfIZFeJHvcs/MCzQIOTgszPHz9DV9+mZ8Hi7IFuw94M3/oLxkVqgA8DV4CbCrw3k0ig6/hIWsfT1ZhAvbAH+dtQY35Q7AWxWROhJAlgBHFmwYWLnJaZgSsYDD6OGgMkkqbGUEKgaoy/P6+gmNlmsekfk6HFazCAh+yz+Kd8wOmwPtAmzY31rIJjnQpFVgaubOBZomoMnY0/eJZAc9NiJRvz7FFCQ2t5g9gC/fH49wb8ld1f/J59wD0HMfbsA+w5RzqpGWZ1GvCtkgPAnzOd8JthEoX/KcGkmHDnYNSypz0UVy43kfXszDhD18khaR1P3I8rWc+t96E8XDWGAjgXI8DyClZjqGABSa+QA/Iy1BgggZVcIpNdJXrcs8gnmOhRkOVjqDFPAwVeqG/123Buhm+fkaDG5GHgyu+mAp9bUkHMk6HGaKOAXtgL+ttQY/Yr9oLYrIlQkuRnBHEhwYWLnFaIgcspQY0BEklTY/Iw1Jhn/HkFxcy2sE3/mIxH8QrgIfvC/ikfcDqsD7RJc2M9RHCsU6EIYeAqIliNobN5BjxLoLlpsVJEkhpDa+UGsRVgKBO5AX8V9Re/5zzgngsy9pwH2HMxSWoM4FulGIC/eDrhN8MkCn8JwaSYcBdj1LKSHoqrlJvIelFmnKHrFJO0jifux5Wsl9b7UBmuGkMBXIoRYGUFqzFUsICkV8gBZRlqDJDASimRya4SPe5ZhAomehRkoQw1piRQ4IX6Vr8Nl2b4tpwENaYMA1d5NxX40pIKYpkMNUYbFfTCXtHfhhqzT7EXxGZNhJKkPCOIKwkuXOS0SgxclSWoMUAiaWpMGYYaU86fV1DMbKvY9I/J0OK1MoCH7Kv4p3zA6bA+0CbNjfWqgmOdCkVVBq5qgtUYOpty4FkCzU2LlWqS1BhaqzSIrQJDmSgN+Ku6v/g9lwH3XJGx5zLAnmtIUmMA3yo1APzPphN+M0yi8NcUTIoJdw1GLavlobhqu4msV2fGGbpODUnreOJ+XMl6Hb0P1eWqMRTAtRkBVk+wGkMFC0h6hRxQj6HGAAms1BaZ7CrR455FfcFEj4KsPkONqQUUeKG+1W/DdRi+bSBBjanLwPWcmwp8HUkFsW6GGqONhnphf97fhhqzV7EXxGZNhJLkOUYQNxJcuMhpjRi4GktQY4BE0tSYugw1poE/r6CY2Tax6R+TocVrYwAP2TfxT/mA02F9oE2aG+tNBcc6FYqmDFzNBKsxdDYNwLMEmpsWK80kqTG0Vh0QW0OGMlEH8Fdzf/F7rgvu+XnGnusCe24hSY0BfKu0APC3TCf8ZphE4W8lmBQT7haMWtbaQ3G1cRNZb86MM3SdFpLW8cT9uJL1tnofeoGrxlAAt2EEWDvBagwVLCDpFXJAO4YaAySw0kZksqtEj3sW7QUTPQqy9gw1pjVQ4IX6Vr8Nt2X4toMENeYFBq6ObirwbSUVxBcy1BhtdNIL+4v+NtSYPYq9IDZrIpQkHRlB3Flw4SKndWbg6iJBjQESSVNjXmCoMR38eQXFzLarTf+YDC1euwB4yL6rf8oHnA7rA23S3FjvJjjWqVB0Y+DqLliNobPpAJ4l0Ny0WOkuSY2htdqC2DoxlIm2gL9e8he/5xfAPb/I2PMLwJ5flqTGAL5VXgbw90gn/GaYROHvKZgUE+6XGbWsl4fi6u0msv4SM87QdV6WtI4n7seVrPfR+1BfrhpDAdybEWD9BKsxVLCApFfIAf0YagyQwEpvkcmuEj3uWfQXTPQoyPoz1JheQIEX6lv9NtyH4dtXJKgxfRm4XnVTge8jqSD2zVBjtPGaXtgH+NtQY3Yr9oLYrIlQkrzKCOKBggsXOW0gA9cgCWoMkEiaGtOXoca84s8rKGa2g236x2Ro8ToIwEP2g/1TPuB0WB9ok+bG+hDBsU6FYggD11DBagydzSvgWQLNTYuVoZLUGFqrD4jtNYYy0Qfw1zB/8XvuC+55AGPPfYE9D5ekxgC+VYYD+EekE34zTKLwjxRMign3cEYte91Dcb3hJrI+jBln6DrDJa3jiftxJeuj9D40mqvGUAC/wQiwMYLVGCpYQNIr5IAxDDUGSGDlDZHJrhI97lm8KZjoUZC9yVBjXgcKvFDf6rfhUQzfjpWgxoxm4HrLTQV+lKSCODpDjdHG23phH+dvQ41JUuwFsVkToSR5ixHE7wguXOS0dxi4xktQY4BE0tSY0Qw1Zqw/r6CY2U6w6R+TocXreAAP2U/wT/mA02F9oE2aG+sTBcc6FYqJDFyTBKsxdDZjwbMEmpsWK5MkqTG01igQ29sMZWIU4K93/cXveTS453GMPY8G9vyeJDUG8K3yHoD//XTCb4ZJFP7Jgkkx4X6PUcumeCiuD9xE1t9lxhm6znuS1vHE/biS9al6H/qQq8ZQAH/ACLBpgtUYKlhA0ivkgGkMNQZIYOUDkcmuEj3uWUwXTPQoyKYz1JgpQIEX6lv9NjyV4dsZEtSYDxm4PnJTgZ8qqSB+mKHGaONjvbDP9LehxuxS7AWxWROhJPmIEcSzBBcuctosBq7ZEtQYIJE0NeZDhhozw59XUMxs59j0j8nQ4nU2gIfs5/infMDpsD7QJs2N9TDBsU6FIoyBa65gNYbOZgZ4lkBz02JlriQ1htaaCmL7mKFMTAX8Fe4vfs8fgnueydjzh8CeP5GkxgC+VT4B8EekE34zTKLwfyqYFBPuTxi17DMPxRXpJrIezowzdJ1PJK3jiftxJevz9D40n6vGUABHMgIsSrAaQwULSHqFHBDFUGOABFYiRSa7SvS4Z/G5YKJHQfY5Q435DCjwQn2r34bnMXy7QIIaM5+B6ws3Ffh5kgri/Aw1RhvRemGP8behxnyv2AtisyZCSfIFI4gXCi5c5LSFDFyLJKgxQCJpasx8hhqzwJ9XUMxsY236x2Ro8boIwEP2sf4pH3A6rA+0SXNjfbHgWKdCsZiBa4lgNYbOZgF4lkBz02JliSQ1htaaB2KLZigT8wB/LfUXv+f54J5jGHueD+z5S0lqDOBb5UsAf1w64TfDJAr/V4JJMeH+klHLvvZQXMvcRNaXMuMMXedLSet44n5cyfpyvQ/Fc9UYCuBljABbIViNoYIFJL1CDljBUGOABFaWiUx2lehxz2KlYKJHQbaSocZ8DRR4ob7Vb8PLGb5dJUGNiWfgWu2mAr9cUkGMz1BjtLFGL+wJ/jbUmO8Ue0Fs1kQoSVYzgnit4MJFTlvLwLVOghoDJJKmxsQz1JhV/ryCYma73qZ/TIYWr+sAPGS/3j/lA06H9YE2aW6sbxAc61QoNjBwbRSsxtDZrALPEmhuWqxslKTG0FrLQWxrGMrEcsBfm/zF7zke3HMCY8/xwJ43S1JjAN8qmwH836QTfjNMovB/K5gUE+7NjFq2xUNxbXUTWd/EjDN0nc2S1vHE/biS9W16H0rkqjEUwFsZAbZdsBpDBQtIeoUcsJ2hxgAJrGwVmewq0eOexQ7BRI+CbAdDjdkCFHihvtVvw9sYvt0pQY1JZOD6zk0FfpukgpiYocZo43u9sO/yt6HG7FTsBbFZE6Ek+Y4RxEmCCxc5LYmBa7cENQZIJE2NSWSoMTuRWzBgu8emf0yGFq+7ATxkv8c/5QNOh/WBNmlurO8VHOtUKPYycO0TrMbQ2ewEzxJoblqs7JOkxtBa20Bs3zOUiW2Av/b7i99zIrjnXYw9JwJ7/kGSGgP4VvkBwH8gnfCbYRKF/6BgUky4f2DUsh89FNchN5H1/cw4Q9f5QdI6nrgfV7L+k96HDnPVGArgQ4wA+1mwGkMFC0h6hRzwM0ONARJYOSQy2VWixz2LI4KJHgXZEYYa8yNQ4IX6Vr8N/8Tw7S8S1JjDDFxH3VTgf5JUEA9nqDHaOKYX9uP+NtSYHYq9IDZrIpQkRxlBfEJw4SKnnWDgOilBjQESSVNjDjPUmF/8eQXFzPaUTf+YDC1eTwJ4yP6Uf8oHnA7rA23S3Fg/LTjWqVCcZuA6I1iNobP5BTxLoLlpsXJGkhpDa/0EYjvGUCZ+Avz1q7/4PR8G93ycsefDwJ7PSlJjAN8qZwH8v6UTfjNMovD/LpgUE+6zjFr2h4fiOucmsv4rM87Qdc5KWscT9+NK1s/rfegCV42hAD7HCLCLgtUYKlhA0ivkgIsMNQZIYOWcyGRXiR73LC4JJnoUZJcYaswfQIEX6lv9Nnye4dvLEtSYCwxcV9xU4M9LKogXMtQYbfypF/ar/jbUmO2KvSA2ayKUJFcYQXxNcOEip11j4LouQY0BEklTYy4w1JjL/ryCYmZ7w6Z/TIYWr9cBPGR/wz/lA06H9YE2aW6s3xQc61QobjJw/SVYjaGzuQyeJdDctFj5S5IaQ2udB7H9yVAmzgP++ttf/J4vgHu+ytjzBWDPtySpMYBvlVsA/n/SCb8ZJlH4bwsmxYT7FqOW3fFQXHfdRNb/ZsYZus4tSet44n5cyfo9vQ/d56oxFMB3GQH2r2A1hgoWkPQKOeBfhhoDJLByV2Syq0SPexYPBBM9CrIHDDXmDlDghfpWvw3fY/j2oQQ15j4DlyPAPQX+nqSCeD9DjXn0wwB9LsCGGpOo2AtisyZCSeIIwIPYy3oQswoXOc2Lgcs7APMXR40BEklTY+4z1JiH/ryCYmbrY9M/JkOLV28AD9n7BKR8wOmwPtAmzY11X8GxToXCl4HLDzxLVI2hs0HikOyB5qbFih/z7FFCQ2sheUv2dC5o/N8D/OUfIH7P98E9Z2Ls+T6w5wBwz8kDVWMA3yoBQL0KTCf8ZphE4Q8C8aO1jHAHMGpZZg/FFewmsu7PjDN0nQBJ63jiflzJeha9D2UNSGNhMyJNARzMCLBsILlAmwAVLCDpFXJAtgCcGAMJrASLTHaV6HHPIrtgokdBlj0AP8PMQIEX6lv9NpyF4dscgnGRGpCVgSunmwp8FkkFMaukdTxdjXlKL+xP21Fjtin2gtisiVCS5GQEcS7BhYuclouBK7cENQZIJE2NoYRA1ZgcAbyCYmabx6Z/TIYWr7kBPGSfh3kjR5s0N9bzCo51KhR5GbjyCVZj6GxygGcJNDctVvJJUmNorSwgtqcYykQWwF/PBIjfc1Zwz08z9pwV2HN+SWoM4FslP4C/QDrhN8MkCn9BwaSYcOdn1LJCHorL6Say/gwzztB18ktaxxP340rWC+t9KISrxmgBzAiwIoLVGCpYQNIr5IAiDDUGSGDFKTLZVaLHPYuigokeBVlRhhpTCCjwQn2r34YLM3xbTIIaE8LAVdxNBb6wpIIYkqHGaKOEXthLBthQY7Yq9oLYrIlQkhRnBHEpwYWLnFaKgau0BDUGSCRNjQlhqDHFAngFxcy2jE3/mAwtXksDeMi+TEDKB5wO6wNt0txYLys41qlQlGXgChWsxtDZFAPPEmhuWqyESlJjaK3CILYSDGWiMOCvcgHi9xwC7rkkY88hwJ7LS1JjAN8q5QH8FdIJvxkmUfgrCibFhLs8o5ZV8lBcld1E1ssx4wxdp7ykdTxxP65kvYreh6py1RgK4MqMAKsmWI2hggUkvUIOqMZQY4AEViqLTHaV6HHPorpgokdBVp2hxlQCCrxQ3+q34SoM39aQoMZUZeB61k0Fvoqkglg1Q43RRk29sNcKsKHGbFHsBbFZE6EkeZYRxLUFFy5yWm0GrjoS1BggkTQ1pipDjakRwCsoZrZ1bfrHZGjxWgfAQ/Z1A1I+4HRYH2iT5sZ6PcGxToWiHgNXfcFqDJ1NDfAsgeamxUp9SWoMrVUFxFaToUxUAfzVIED8nquCe67F2HNVYM/PSVJjAN8qzwH4G6YTfjNMovA/L5gUE+7nGLWskYfiauwmst6AGWfoOs9JWscT9+NK1pvofagpV42hAG7MCLBmgtUYKlhA0ivkgGYMNQZIYKWxyGRXiR73LJoLJnoUZM0ZakwjoMAL9a1+G27C8G0LCWpMUwaulm4q8E0kFcSmGWqMNlrphb11gA015lvFXhCbNRFKkpaMIG4juHCR09owcLWVoMYAiaSpMU0ZakyLAF5BMbN9waZ/TIYWr20BPGT/QkDKB5wO6wNt0txYbyc41qlQtGPgai9YjaGzaQGeJdDctFhpL0mNobWagNhaMZSJJoC/OgSI33NTcM+tGXtuCuy5oyQ1BvCt0hHA3ymd8JthEoX/RcGkmHB3ZNSyzh6Kq4ubyHoHZpyh63SUtI4n7seVrHfV+1A3rhpDAdyFEWDdBasxVLCApFfIAd0ZagyQwEoXkcmuEj3uWbwkmOhRkL3EUGM6AwVeqG/123BXhm9flqDGdGPg6uGmAt9VUkHslqHGaKOnXth7BdhQY75R7AWxWROhJOnBCOLeggsXOa03A1cfCWoMkEiaGtONoca8HMArKGa2fW36x2Ro8doHwEP2fQNSPuB0WB9ok+bGej/BsU6Foh8DV3/BagydzcvgWQLNTYuV/pLUGFqrK4itJ0OZ6Ar465UA8XvuBu65F2PP3YA9vypJjQF8q7wK4H8tnfCbYRKFf4BgUky4X2XUsoEeimuQm8j6K8w4Q9d5VdI6nrgfV7I+WO9DQ7hqDAXwIEaADRWsxlDBApJeIQcMZagxQAIrg0Qmu0r0uGcxTDDRoyAbxlBjBgIFXqhv9dvwYIZvh0tQY4YwcI1wU4EfLKkgDslQY7QxUi/srwfYUGM2K/aC2KyJUJKMYATxG4ILFzntDQauURLUGCCRNDVmCEONGR7AKyhmtqNt+sdkaPE6CsBD9qMDUj7gdFgfaJPmxvoYwbFOhWIMA9ebgtUYOpvh4FkCzU2LlTclqTG01mAQ20iGMjEY8NfYAPF7HgLu+XXGnocAe35LkhoD+FZ5C8D/djrhN8MkCv84waSYcL/FqGXveCiu8W4i62OZcYau85akdTxxP65kfYLehyZy1RgK4PGMAJskWI2hggUkvUIOmMRQY4AEVsaLTHaV6HHP4l3BRI+C7F2GGvMOUOCF+la/DU9g+PY9CWrMRAau991U4CdIKogTM9QYbUzWC/uUABtqzCbFXhCbNRFKkvcZQfyB4MJFTvuAgWuqBDUGSCRNjZnIUGPeC+AVFDPbD236x2Ro8ToVwEP2HwakfMDpsD7QJs2N9WmCY50KxTQGrumC1Rg6m/fAswSamxYr0yWpMbTWBBDbZIYyMQHw14wA8XueCO55CmPPE4E9fyRJjQF8q3wE4P84nfCbYRKFf6ZgUky4P2LUslkeimu2m8j6DGacoet8JGkdT9yPK1mfo/ehMK4aQwE8mxFgcwWrMVSwgKRXyAFzGWoMkMDKbJHJrhI97lmECyZ6FGThDDVmFlDghfpWvw3PYfj2EwlqTBgDV4SbCvwcSQUxLEON0canemH/LMCGGrNRsRfEZk2EkiSCEcSRggsXOS2SgWueBDUGSCRNjQljqDGfBPAKipntfJv+MRlavM4D8JD9/ICUDzgd1gfapLmxHiU41qlQRDFwfS5YjaGz+QQ8S6C5abHyuSQ1htaaA2L7lKFMzAH8tSBA/J7DwD1/xthzGLDnLySpMYBvlS8A/NHphN8Mkyj8MYJJMeH+glHLFnoorkVuIusLmHGGrvOFpHU8cT+uZD1W70OLuWoMBfAiRoAtEazGUMECkl4hByxhqDFAAiuLRCa7SvS4Z7FUMNGjIFvKUGMWAgVeqG/123Asw7dfSlBjFjNwxbmpwMdKKoiLM9QYbXylF/avA2yoMRsUe0Fs1kQoSeIYQbxMcOEipy1j4FouQY0BEklTYxYz1JgvA3gFxcw23qZ/TIYWr8sBPGQfH5DyAafD+kCbNDfWVwiOdSoUKxi4VgpWY+hsvgTPEmhuWqyslKTG0FqxILavGMpELOCvVQHi97wY3PPXjD0vBva8WpIaA/hWWQ3gX5NO+M0wicKfIJgUE+7VjFq21kNxrXMTWV/FjDN0ndWS1vHE/biS9fV6H9rAVWMogNcxAmyjYDWGClYC0gQCHmFCiTGQwMo6kcmuEj3uWWwSTPQoyDYx1Ji1QIEX6lv9Nrye4dvNEtSYDQxc37ipwK+XVBA3ZKgx2vhWL+xbAmyoMesVe0Fs1kQoSb5hBPFWwYWLnLaVgWubBDUGSCRNjdnAUGM2B/AKipltok3/mAwtXrcBeMg+MSDlA06H9YE2aW6sbxcc61QotjNw7RCsxtDZbAbPEmhuWqzskKTG0FrrQWzfMpSJ9YC/dgaI3/MGcM9bGHveAOz5O0lqDOBb5TsA//fphN8Mkyj8uwSTYsL9HaOWJXkort1uIus7mXGGrvOdpHU8cT+uZH2P3of2ctUYCuDdjADbJ1iNoYIFJL1CDtjHUGOABFZ2i0x2lehxz2K/YKJHQbafocYkAQVeqG/12/Aehm9/kKDG7GXgOuCmAr9HUkHcm6HGaOOgXth/DLChxqxT7AWxWROhJDnACOJDggsXOe0QA9dPEtQYIJE0NWYvQ435IYBXUMxsD9v0j8nQ4vUnRMpXHmFyYOs8Wgz5jdqkubH+s+BYp0LxMwPXEcFqDJ3ND+BZAs1Ni5UjktQYWmsPiO0gQ5nYA/jrlwDxe94L7vlHxp73Ans+KkmNAXyrHAXwH0sn/GaYROE/LpgUE+6jjFp2wkNxnXQTWf+FGWfoOkclreOJ+3El66f0PnSaq8ZQAJ9kBNgZwWoMFSwg6RVywBmGGgMksHJSZLKrRI97Fr8KJnoUZL8y1JgTQIEX6lv9NnyK4duzEtSY0wxcv7mpwJ+SVBBPZ6gx2vhdL+x/BNhQY9Yq9oLYrIlQkvzGCOJzggsXOe0cA9d5CWoMkEiaGnOaocacDeAVFDPbCzb9YzK0eD0P4CH7CwEpH3A6rA+0SXNj/aLgWKdCcZGB65JgNYbO5ix4lkBz02LlkiQ1htY6BWL7naFMnAL8dTlA/J5Pg3v+g7Hn08Cer0hSYwDfKlcA/H+mE34zTKLwXxVMign3FUYtu+ahuK67iaxfZsYZus4VSet44n5cyfoNvQ/d5KoxFMDXGQH2l2A1hgoWkPQKOeAvhhoDJLByXWSyq0SPexZ/CyZ6FGR/M9SYa0CBF+pb/TZ8g+HbWxLUmJsMXP+4qcDfkFQQb2aoMdq4rRf2OwE21JgExV4QmzURSpJ/GEF8V3DhIqfdZeC6J0GNARJJU2NuMtSYWwG8gmJme9+mf0yGFq/3ADxkfz8g5QNOh/WBNmlurP8rONapUPzLwPVAsBpDZ3MLPEuguWmx8kCSGkNr3QCx3WYoEzcAfz0MEL/nm+Ce7zD2fBPYsyOQ17RRNeYhkrOB1vEr6YTfDJMo/JlA/GgtI9yEB61lXh6KyxvAlZ5kHa0N3HW4+fj/wn5cybpP4KO3b+D/vvT4wmZEmgLYmxFgfoHA5hx4E6CCBSS9Qg4gTCgxBhJY8RaZ7CrR456FP3gWaHBSkPkH4mfoBRR4ob7Vb8M+DN8GCMZFaoAvA1egmwq8j6TC6ytpHU9XY4L0wp450IYas0axF8RmTYSSJJARxMGCCxc5LZiBKwsYfBw1BkgkTY2hhEDVmIBAXkExs81q0z8mQ4vXLAAess8amPIBp8P6QJs0N9azCY51KhTZGLiyg2eJqjF0NgHgWQLNTYuV7Myzh/9lhgqWt2QfFIjHvw/grxyB4vfsC+45M2PPvsCec0pSYwDfKjkB/E+lE34zTKLwPy2YFBPunIxalstDceV2E1nPwYwzdJ2cktbxxP24kvU8eh/Ky1VjKIBzMwIsn2A1hgoWkPQKOSAfQ40BEljJLTLZVaLHPYtnBBM9CrJnGGpMLqDAC/WtfhvOw/BtfglqTF4GrgJuKvB5JBXEvBlqjDYK6oW9UKANNWa1Yi+IzZoIJUkBRhA7BRcucpqTgauwBDUGSCRNjcnLUGPyAwW4AGAbYtM/JkOL18IAHrIPCUz5gNNhfaBNmhvrRQTHOhWKIgxcRQWrMXQ2+cGzBJqbFitFJakxtFYeEFtBhjKRB/BXsUDxe84L7rkQY895gT0Xl6TGAL5VigP4S6QTfjNMovCXFEyKCXdxRi0r5aG4SruJrBdjxhm6TnFJ63jiflzJehm9D5XlqjEUwKUZARYqWI2hggUkvUIOCGWoMUACK6VFJrtK9LhnUU4w0aMgK8dQY0oBBV6ob/XbcBmGb8tLUGPKMnBVcFOBLyOpIJbNUGO0UVEv7JUCbagxqxR7QWzWRChJKjCCuLLgwkVOq8zAVUWCGgMkkqbGlGWoMeUDeQXFzLaqTf+YDC1eqwB4yL5qYMoHnA7rA23S3FivJjjWqVBUY+CqLliNobMpD54l0Ny0WKkuSY2htcqA2CoylIkygL9qBIrfc1lwz5UYey4L7PlZSWoM4FvlWQB/zXTCb4ZJFP5agkkx4X6WUctqeyiuOm4i6zWYcYau86ykdTxxP65kva7eh+px1RgK4DqMAKsvWI2hggUkvUIOqM9QY4AEVuqITHaV6HHPooFgokdB1oChxtQGCrxQ3+q34boM3z4nQY2px8DV0E0Fvq6kglgvQ43RxvN6YW8UaEONWanYC2KzJkJJ0pARxI0FFy5yWmMGriYS1BggkTQ1ph5DjXkukFdQzGyb2vSPydDitQmAh+ybBqZ8wOmwPtAmzY31ZoJjnQpFMwau5oLVGDqb58CzBJqbFivNJakxtFZdENvzDGWiLuCvFoHi91wP3HMjxp7rAXtuKUmNAXyrtATwt0on/GaYROFvLZgUE+6WjFrWxkNxtXUTWW/BjDN0nZaS1vHE/biS9Rf0PtSOq8ZQALdlBFh7wWoMFSwg6RVyQHuGGgMksNJWZLKrRI97Fh0EEz0Ksg4MNaYNUOCF+la/Db/A8G1HCWpMOwauTm4q8C9IKojtMtQYbbyoF/bOgTbUmBWKvSA2ayKUJJ0YQdxFcOEip3Vh4OoqQY0BEklTY9ox1JiOgbyCYmbbzaZ/TIYWr10BPGTfLTDlA06H9YE2aW6sdxcc61QoujNwvSRYjaGz6QieJdDctFh5SZIaQ2u9AGJ7kaFMvAD46+VA8XtuB+65M2PP7YA995CkxgC+VXoA+HumE34zTKLw9xJMigl3D0Yt6+2huPq4iay/zIwzdJ0ektbxxP24kvW+eh/qx1VjKID7MAKsv2A1hgoWkPQKOaA/Q40BEljpIzLZVaLHPYtXBBM9CrJXGGpMb6DAC/Wtfhvuy/DtqxLUmH4MXK+5qcD3lVQQ+2WoMdoYoBf2gYE21Jh4xV4QmzURSpLXGEE8SHDhIqcNYuAaLEGNARJJU2P6MdSYVwN5BcXMdohN/5gMLV4HA3jIfkhgygecDusDbdLcWB8qONapUAxl4BomWI2hs3kVPEuguWmxMkySGkNr9QWxDWAoE30Bfw0PFL/nfuCeBzL23A/Y8whJagzgW2UEgH9kOuE3wyQK/+uCSTHhHsGoZW94KK5RbiLrw5lxhq4zQtI6nrgfV7I+Wu9DY7hqDAXwKEaAvSlYjaGCBSS9Qg54k6HGAAmsjBKZ7CrR457FWMFEj4JsLEONeQMo8EJ9q9+GRzN8+5YENWYMA9fbbirwoyUVxDEZaow2xumF/Z1AG2rMcsVeEJs1EUqStxlBPF5w4SKnjWfgmiBBjQESSVNjxjDUmLcCeQXFzHaiTf+YDC1eJwB4yH5iYMoHnA7rA23S3FifJDjWqVBMYuB6V7AaQ2fzFniWQHPTYuVdSWoMrTUaxDaOoUyMBvz1XqD4PY8B9/wOY89jgD2/L0mNAXyrvA/gn5xO+M0wicI/RTApJtzvM2rZBx6Ka6qbyPp7zDhD13lf0jqeuB9Xsv6h3oemcdUYCuCpjACbLliNoYIFJL1CDpjOUGOABFamikx2lehxz2KGYKJHQTaDocZ8ABR4ob7Vb8MfMnz7kQQ1ZhoD18duKvAfSiqI0zLUGG3M1Av7rEAbaswyxV4QmzURSpKPGUE8W3DhIqfNZuCaI0GNARJJU2OmMdSYjwJ5BcXMNsymf0yGFq9zADxkHxaY8gGnw/pAmzQ31ucKjnUqFHMZuMIFqzF0Nh+BZwk0Ny1WwiWpMbTWhyC2mQxl4kPAX58Eit/zNHDPsxh7ngbsOUKSGgP4VokA8H+aTvjNMInC/5lgUky4Ixi1LNJDcc1zE1n/hBln6DoRktbxxP24kvX5eh+K4qoxFMDzGAH2uWA1hgoWkPQKOeBzhhoDJLAyT2Syq0SPexYLBBM9CrIFDDUmEijwQn2r34bnM3z7hQQ1JoqBK9pNBX6+pIIYlaHGaCNGL+wLA22oMV8r9oLYrIlQkkQzgniR4MJFTlvEwBUrQY0BEklTY6IYaswXgbyCYma72KZ/TIYWr7EAHrJfHJjyAafD+kCbNDfWlwiOdSoUSxi4lgpWY+hsvgDPEmhuWqwslaTG0FrzQWwxDGViPuCvLwPF7zkK3PNCxp6jgD3HSVJjAN8qcQD+r9IJvxkmUfi/FkyKCXcco5Yt81Bcy91E1r9kxhm6TpykdTxxP65kPV7vQyu4agwF8HJGgK0UrMZQwQKSXiEHrGSoMUACK8tFJrtK9LhnsUow0aMgW8VQY5YBBV6ob/XbcDzDt6slqDErGLjWuKnAx0sqiCsy1BhtJOiFfW2gDTXmK8VeEJs1EUqSNYwgXie4cJHT1jFwrZegxgCJpKkxKxhqzOpAXkExs91g0z8mQ4vX9cjtRnmEyYGt82gx5Ddqk+bG+kbBsU6FYiMD1ybBagydzWrwLIHmpsXKJklqDK0VD2JLYCgT8YC/NgeK3/MKcM9rGXteAez5G0lqDOBb5RsA/7fphN8Mkyj8WwSTYsL9DaOWbfVQXNvcRNY3M+MMXecbSet44n5cyXqi3oe2c9UYCuBtjADbIViNoYIFJL1CDtjBUGOABFa2iUx2lehxz2KnYKJHQbaTocZsBQq8UN/qt+FEhm+/k6DGbGfg+t5NBT5RUkHcnqHGaGOXXtiTAm2oMXGKvSA2ayKUJN8zgni34MJFTtvNwLVHghoDJJKmxmxnqDHfBfIKipntXpv+MRlavO5B/qxceYTJga3zaDHkN2qT5sb6PsGxToViHwPXfsFqDJ3Nd+BZAs1Ni5X9ktQYWisRxLaLoUwkAv76IVD8nreDe05i7Hk7sOcDktQYwLfKAQD/wXTCb4ZJFP4fBZNiwn2AUcsOeSiun9xE1n9gxhm6zgFJ63jiflzJ+mG9D/3MVWMogH9iBNgRwWoMFSwg6RVywBGGGgMksPKTyGRXiR73LH4RTPQoyH5hqDGHgAIv1Lf6bfgww7dHJagxPzNwHXNTgT8sqSD+nKHGaOO4XthPBNpQY75U7AWxWROhJDnGCOKTggsXOe0kA9cpCWoMkEiaGvMzQ405GsgrKGa2p236x2Ro8XoKwEP2pwNTPuB0WB9ok+bG+hnBsU6F4gwD16+C1Rg6m6PgWQLNTYuVXyWpMbTWYRDbcYYycRjw19lA8Xv+GdzzCcaefwb2/JskNQbwrfIbgP/3dMJvhkkU/j8Ek2LC/Rujlp3zUFzn3UTWzzLjDF3nN0nreOJ+XMn6Bb0PXeSqMRTA5xkBdkmwGkMFC0h6hRxwiaHGAAmsnBeZ7CrR457FZcFEj4LsMkONOQcUeKG+1W/DFxi+vSJBjbnIwPWnmwr8BUkF8WKGGqONq3phvxZoQ41ZqtgLYrMmQknyJyOIrwsuXOS06wxcNySoMUAiaWrMRYYacyWQV1DMbG/a9I/J0OL1BoCH7G8GpnzA6bA+0CbNjfW/BMc6FYq/GLj+FqzG0NlcAc8SaG5arPwtSY2htS6A2K4ylIkLgL9uBYrf80Vwz9cYe74I7PkfSWoM4FvlHwD/7XTCb4ZJFP47gkkx4f6HUcvueiiue24i67eYcYau84+kdTxxP65k/b7eh/7lqjEUwPcYAfZAsBpDBQtIeoUc8IChxgAJrNwTmewq0eOexUPBRI+C7CFDjbkLFHihvtVvw/cZvnUEicVFasC/DFwKgCs9C/x9SQXx3ww15tH/P+jR2yvIhhqzRLEXxGZNhJJECcKD2Nt6ELMKFznNm4HLB0x6jhoDJJKmxvzLUGNcixdSUMxsfW36x2Ro8eoD4CF736CUDzgd1gfapLmx7ic41qlQ+DFw+YNniaoxdDYO8CyB5qbFij/z7FFCQ2sheUv2dC5o/N8HiFNAkPg9/wvu2Yux53+BPQeCe04eqBoD+FYJBGI8KJ3wm2EShT+zYFJMuAMZtSzYQ3FlcRNZD2DGGbpOoKR1PHE/rmQ9q96HsgWlsbAZkaYAzsIIsOwguUCbABUsIOkVckD2IJwYAwmsZBGZ7CrR455FDsFEj4IsRxB+hsFAgRfqW/02nJXh25wS1JhsDFxPuanAZ5VUELNJWsfT1Zin9cKey44as1ixF8RmTYSS5ClGEOcWXLjIabkZuPJIUGOARNLUGEoIVI3JGcQrKGa2eW36x2Ro8ZoHwEP2eZk3crRJc2M9n+BYp0KRj4HrGcFqDJ1NTvAsgeamxcozktQYWisriO1phjKRFfBX/iDxe84G7jkXY8/ZgD0XkKTGAL5VCgD4C6YTfjNMovAXEkyKCXcBRi1zeiiuwm4i6/mZcYauU0DSOp64H1eyHqL3oSJcNYYCuDAjwIoKVmOoYAFJr5ADijLUGCCBlcIik10letyzKCaY6FGQFWOoMU6gwAv1rX4bDmH4trgENaYIA1cJNxX4EEkFsUiGGqONknphLxVkQ42JVewFsVkToSQpwQji0oILFzmtNANXGQlqDJBImhpThKHGFA/iFRQz27I2/WMytHgtA+Ah+7JBKR9wOqwPtElzYz1UcKxToQhl4ConWI2hsykOniXQ3LRYKSdJjaG1QkBsJRnKRAjgr/JB4vdcBNxzKcaeiwB7riBJjQF8q1QA8FdMJ/xmmEThrySYFBPuCoxaVtlDcVVxE1kvz4wzdJ0KktbxxP24kvWqeh+qxlVjKICrMAKsumA1hgoWkPQKOaA6Q40BElipIjLZVaLHPYsagokeBVkNhhpTGSjwQn2r34arMnz7rAQ1phoDV003FfiqkgpitQw1Rhu19MJeO8iGGrNIsRfEZk2EkqQmI4jrCC5c5LQ6DFx1JagxQCJpakw1hhrzbBCvoJjZ1rPpH5OhxWtdAA/Z1wtK+YDTYX2gTZob6/UFxzoVivoMXA0EqzF0Ns+CZwk0Ny1WGkhSY2itqiC2Wgxloirgr+eCxO+5Grjn2ow9VwP23FCSGgP4VmkI4H8+nfCbYRKFv5FgUky4GzJqWWMPxdXETWT9OWacoes0lLSOJ+7Hlaw31ftQM64aQwHchBFgzQWrMVSwgKRXyAHNGWoMkMBKE5HJrhI97lm0EEz0KMhaMNSYxkCBF+pb/TbclOHblhLUmGYMXK3cVOCbSiqIzTLUGG201gt7myAbasxCxV4QmzURSpJWjCBuK7hwkdPaMnC9IEGNARJJU2OaMdSYlkG8gmJm286mf0yGFq8vAHjIvl1QygecDusDbdLcWG8vONapULRn4OogWI2hs2kJniXQ3LRY6SBJjaG1moLYWjOUiaaAvzoGid9zM3DPbRh7bgbsuZMkNQbwrdIJwP9iOuE3wyQKf2fBpJhwd2LUsi4eiqurm8h6R2acoet0krSOJ+7Hlax30/tQd64aQwHclRFgLwlWY6hgAUmvkANeYqgxQAIrXUUmu0r0uGfxsmCiR0H2MkON6QIUeKG+1W/D3Ri+7SFBjenOwNXTTQW+m6SC2D1DjdFGL72w9w6yocbEKPaC2KyJUJL0ZARxH8GFi5zWh4GrrwQ1phvSePQigaoxPYJ4BcXMtp9N/5gMLV77AnjIvl9QygecDusDbdLcWO8vONapUPRn4HpFsBpDZ9MDPEuguWmx8ookNYbW6gZi68VQJroB/no1SPyeu4N77s3Yc3dgz69JUmMA3yqvAfgHpBN+M0yi8A8UTIoJ92uMWjbIQ3ENdhNZf5UZZ+g6r0laxxP340rWh+h9aChXjaEAHswIsGGC1RgqWEDSK+SAYQw1BkhgZbDIZFeJHvcshgsmehRkwxlqzCCgwAv1rX4bHsLw7QgJasxQBq6RbirwQyQVxKEZaow2XtcL+xtBNtSYaMVeEJs1EUqSkYwgHiW4cJHTRjFwjZagxgCJpKkxQxlqzIggXkExsx1j0z8mQ4vX0QAesh8TlPIBp8P6QJs0N9bfFBzrVCjeZOAaK1iNobMZAZ4l0Ny0WBkrSY2htYaA2F5nKBNDAH+9FSR+z0PBPb/B2PNQYM9vS1JjAN8qbwP4x6UTfjNMovC/I5gUE+63GbVsvIfimuAmsv4WM87Qdd6WtI4n7seVrE/U+9AkrhpDATyBEWDvClZjqGABSa+QA95lqDFAAisTRCa7SvS4Z/GeYKJHQfYeQ40ZDxR4ob7Vb8MTGb59X4IaM4mBa7KbCvxESQVxUoYao40pemH/IMiGGvOFYi+IzZoIJclkRhBPFVy4yGlTGbg+lKDGAImkqTGTGGrM+0G8gmJmO82mf0yGFq8fAnjIflpQygecDusDbdLcWJ8uONapUExn4JohWI2hs3kfPEuguWmxMkOSGkNrTQSxTWEoExMBf30UJH7Pk8A9f8DY8yRgzx9LUmMA3yofA/hnphN+M0yi8M8STIoJ98eMWjbbQ3HNcRNZ/4gZZ+g6H0taxxP340rWw/Q+NJerxlAAz2EEWLhgNYYKFpD0CjkgnKHGAAmszBGZ7CrR457FJ4KJHgXZJww1ZjZQ4IX6Vr8NhzF8GyFBjZnLwPWpmwp8mKSCODdDjdHGZ3phjwyyocYsUOwFsVkToST5lBHE8wQXLnLaPAau+RLUGCCRNDVmLkONiQjiFRQz2yib/jEZWrzOB/CQfVRQygecDusDbdLcWP9ccKxToficgWuBYDWGziYCPEuguWmxskCSGkNrhYHYPmMoE2GIehUkfs9zwT1HMvY8F9hztCQ1BvCtEg3gj0kn/GaYROFfKJgUE+5oRi1b5KG4Yt1E1r9gxhm6TrSkdTxxP65kfbHeh5Zw1RgK4FhGgC0VrMZQwQKSXiEHLGWoMUACK7Eik10letyz+FIw0aMg+5KhxiwCCrxQ3+q34cUM38ZJUGOWMHB95aYCv1hSQVySocZo42u9sC8LsqHGfK7YC2KzJkJJ8hUjiJcLLlzktOUMXPES1BggkTQ1ZglDjYkL4hUUM9sVNv1jMrR4jQfwkP2KoJQPOB3WB9qkubG+UnCsU6FYycC1SrAaQ2cTB54l0Ny0WFklSY2htRaD2L5mKBOLAX+tDhK/5yXgnpcx9rwE2PMaSWoM4FtlDYA/IZ3wm2EShX+tYFJMuNcwatk6D8W13k1kfTUzztB11khaxxP340rWN+h9aCNXjaEAXs8IsE2C1RgqWEDSK+SATQw1BkhgZb3IZFeJHvcsNgsmehRkmxlqzDqgwAv1rX4b3sDw7TcS1JiNDFzfuqnAb5BUEDdmqDHa2KIX9q1BNtSYKMVeEJs1EUqSbxlBvE1w4SKnbWPgSpSgxgCJpKkxGxlqzDdBvIJiZrvdpn9MhhaviQAest8elPIBp8P6QJs0N9Z3CI51KhQ7GLh2ClZj6Gy+Ac8SaG5arOyUpMbQWhtAbFsYysQGwF/fBYnf80Zwz1sZe94I7Pl7SWoM4FvlewD/rnTCb4ZJFP4kwaSYcH/PqGW7PRTXHjeR9e+YcYau872kdTxxP65kfa/eh/Zx1RgK4D2MANsvWI2hggUkvUIO2M9QY4AEVvaITHaV6HHP4gfBRI+C7AeGGrMbKPBCfavfhvcyfHtAghqzj4HroJsK/F5JBXFfhhqjjR/1wn4oyIYaM1+xF8RmTYSS5CAjiH8SXLjIaT8xcB2WoMYAiaSpMfsYasyBIF5BMbP92aZ/TIYWr4cBPGT/c1DKB5wO6wNt0txYPyI41qlQHGHg+kWwGkNncwA8S6C5abHyiyQ1htbaC2L7kaFM7AX8dTRI/J73gXs+xNjzPmDPxySpMYBvlWMA/uPphN8Mkyj8JwSTYsJ9jFHLTnoorlNuIutHmXGGrnNM0jqeuB9Xsn5a70NnuGoMBfApRoD9KliNoYIFJL1CDviVocYACaycEpnsKtHjnsVZwUSPguwsQ405CRR4ob7Vb8OnGb79TYIac4aB63c3FfjTkgrimQw1Rht/6IX9XJANNWaeYi+IzZoIJcnvjCA+L7hwkdPOM3BdkKDGAImkqTFnGGrMb0G8gmJme9Gmf0yGFq8XADxkfzEo5QNOh/WBNmlurF8SHOtUKC4xcF0WrMbQ2fwGniXQ3LRYuSxJjaG1ToPY/mAoE6cBf10JEr/nM+CezzH2fAbY85+S1BjAt8qfAP6r6YTfDJMo/NcEk2LC/Sejll33UFw33ETWrzDjDF3nT0nreOJ+XMn6Tb0P/cVVYyiAbzAC7G/BagwVLCDpFXLA3ww1Bkhg5YbIZFeJHvcsbgkmehRktxhqzHWgwAv1rX4bvsnw7T8S1Ji/GLhuu6nA35RUEP/KUGO0cUcv7HeDbKgxkYq9IDZrIpQktxlBfE9w4SKn3WPgui9BjQESSVNj/mKoMf8E8QqKme2/Nv1jMrR4vQ/gIft/g1I+4HRYH2iT5sb6A8GxToXiAQPXQ8FqDJ3NP+BZAs1Ni5WHktQYWusmiO0OQ5m4CfjLkVn8nv8C93yXsee/gD0r4J6TB6rGAL5VXDGZ4c+UTvjNMInC7wXiR2sZ4SY8aC3z9lBcPgCu9CTrDmacoesoktbxxP24knXfzI/efpnTWNiMSFMA+zACzB9IdFfQTovfp4IFJL1CDiBMKDEGEljxEZnsKtHjnkUAeBZocFKQBWTGz9AbKPBCfavfhn0Zvg0UjIvUAD8GriA3FXhfSQXRT9I6nq7GZNYLe3BmG2rMZ4q9IDZrIpQkQYwgziK4cJHTsjBwZRV4w0lWY4BE0tQYSghUjQnMzCsoZrbZbPrHZGjxmhXAQ/bZMqd8wOmwPtAmzY317IJjnQpFdgauHOBZomoMnU0geJZAc9Ni5f+09xXgVlVd12cRUrfDIjwqgknYYJEGYXcQCiIGbYCtgA02YHdid7fYIrZid3fXv+d23+/u9373rnXG2Geus9//O+t5zoNy99xrzLnGHGue8X7ftYo8e3Sgkb2WALGVlOD8XwKoV3WJfs6twJxLiZxbATnXeHJjgNqaGgB/bZ7wuzBp4V9SeSgW3DWEli2VUlxLF2hYryZ5hu5T42mfNOYTH9aXie6hZVk3Rgi8NEGw9spujAgW0PRGCtCecGOABjZLazZ7MOixZ9FBedATknUg3JilAIFXrW30bXgZorYdPbgxyxK4OhVI4JfxJIjLFt2YcC0XCXu2JIEbM88kI7HrEpEm6USQeHll4ZKiLU/gWsGDGwM0UujGLEu4MR1LOEFxPbtiwvo4VsjXFQA88vyKJfUvyGZyX+glzXK9szLXRSg6E7hWUnZj5Gw6gmcJXG4hV1by5MbIXsuA2JYjnIllgHp1KdHPeVkw5yyR87JAzl09uTFAbU1XAP/KecLvwqSFfxXloVhwdyW0bNWU4lqtQMN6F5Jn6D5dPe2Txnziw/rq0T20BuvGCIFXIwjWTdmNEcECmt5IAboRbgzQwGY1zWYPBj32LLorD3pCsu6EG7MqIPCqtY2+Da9O1LaHBzdmDQJXzwIJ/OqeBHGNohsTrjUjYV+rJIEbM9ckI7HrEpEm6UmQeG1l4ZKirU3gWseDGwM0UujGrEG4MT1KOEFxPbtuwvo4VsjXdQA88vy6JfUvyGZyX+glzXJ9PWWui1CsR+BaX9mNkbPpAZ4lcLmFXFnfkxsje60OYluTcCZWB+rVq0Q/5zXAnNcicl4DyLm3JzcGqK3pDeDfIE/4XZi08G+oPBQL7t6Elm2UUlwbF2hY70XyDN2nt6d90phPfFjfJLqH+rBujBB4Y4JgfZXdGBEsoOmNFKAv4cYADWw21mz2YNBjz6Kf8qAnJOtHuDEbAQKvWtvo2/AmRG37e3Bj+hC4BhRI4DfxJIh9im5MuAZGwr5pSQI3Zo5JRmLXJSJNMoAg8WbKwiVF24zAtbkHNwZopNCN6UO4Mf1LOEFxPbtFwvo4VsjXzQE88vwWJfUvyGZyX+glzXJ9kDLXRSgGEbgGK7sxcjb9wbMELreQK4M9uTGy1yYgtoGEM7EJUK8hJfo59wFz3pTIuQ+Q81BPbgxQWzMUwL9lnvC7MGnh30p5KBbcQwkt2zqluLYp0LA+hOQZus9QT/ukMZ/4sL5tdA9tx7oxQuBtCIJtr+zGiGABTW+kANsTbgzQwGYbzWYPBj32LHZQHvSEZDsQbszWgMCr1jb6NrwtUdsdPbgx2xG4diqQwG/rSRC3K7ox4do5EvZdShK4MWebZCR2XSLSJDsRJN5VWbikaLsSuHbz4MYAjRS6MdsRbsyOJZyguJ7dPWF9HCvk624AHnl+95L6F2QzuS/0kma5vocy10Uo9iBwDVN2Y+RsdgTPErjcQq4M8+TGyF7bgth2JpyJbYF6DS/Rz3k7MOddiJy3A3Ie4cmNAWprRgD4R+YJvwuTFv49lYdiwT2C0LK9UoprVIGG9eEkz9B9RnjaJ435xIf10dE9tDfrxgiBRxEEG6PsxohgAU1vpABjCDcGaGAzSrPZg0GPPYt9lAc9Idk+hBuzFyDwqrWNvg2PJmo71oMbszeBa98CCfxoT4K4d9GNCdd+kbDvX5LAjTnLJCOx6xKRJtmXIPEBysIlRTuAwDXOgxsDNFLoxuxNuDFjSzhBcT07PmF9HCvk6zgAjzw/vqT+BdlM7gu9pFmuT1DmugjFBALXRGU3Rs5mLHiWwOUWcmWiJzdG9hoNYtuPcCZGA/WaVKKf895gzvsTOe8N5DzZkxsD1NZMBvBPyRN+FyYt/AcqD8WCezKhZQelFNfBBRrWJ5E8Q/eZ7GmfNOYTH9YPie6hqawbIwQ+mCDYNGU3RgQLaHojBZhGuDFAA5uDNZs9GPTYszhUedATkh1KuDEHAQKvWtvo2/AhRG0P8+DGTCVwHV4ggT/EkyBOLbox4ToiEvYjSxK4MWeaZCR2XSLSJIcTJD5KWbikaEcRuI724MYAjRS6MVMJN+awEk5QXM8ek7A+jhXy9WgAjzx/TEn9C7KZ3Bd6SbNcP1aZ6yIUxxK4piu7MXI2h4FnCVxuIVeme3JjZK9DQGxHEM7EIUC9ZpTo5zwVzPlIIuepQM4zPbkxQG3NTAD/cXnC78Kkhf945aFYcM8ktOyElOI6sUDD+gySZ+g+Mz3tk8Z84sP6SdE9dDLrxgiBTyQIdoqyGyOCBTS9kQKcQrgxQAObEzWbPRj02LOYpTzoCclmEW7MCYDAq9Y2+jZ8ElHb2R7cmJMJXKcWSOBP8iSIJxfdmHCdFgn76SUJ3JgzTDISuy4RaZJTCRKfoSxcUrQzCFxnenBjgEYK3ZiTCTdmdgknKM7/vTxhfRwr5OuZAB55/qyS+hdkM7kv9JJmuX62MtdFKM4mcM1RdmPkbGaDZwlcbiFX5nhyY2Svk0BspxHOxElAveaW6Od8Mpjz6UTOJwM5z/PkxgC1NfMA/OfkCb8Lkxb+c5WHYsE9j9Cy81KK6/wCDetzSZ6h+8zztE8a84kP6xdE99CFrBsjBD6fINhFym6MCBbQ9EYKcBHhxgANbM7XbPZg0GPP4mLlQU9IdjHhxpwHCLxqbaNvwxcQtb3EgxtzIYHr0gIJ/AWeBPHCohsTrssiYb+8JIEbc7pJRmLXJSJNcilB4iuUhUuKdgWB60oPbgzQSKEbcyHhxlxSwgmK69mrEtbHsUK+XgngkeevKql/QTaT+0IvaZbrVytzXYTiagLXNcpujJzNJeBZApdbyJVrPLkxstcFILbLCGfiAqBe15bo53whmPPlRM4XAjnP9+TGALU18wH81+UJvwuTFv7rlYdiwT2f0LIbUorrxgIN69eSPEP3me9pnzTmEx/Wb4ruoZtZN0YIfCNBsFuU3RgRLKDpjRTgFsKNARrY3KjZ7MGgx57FrcqDnpDsVsKNuQEQeNXaRt+GbyJqe5sHN+ZmAtftBRL4mzwJ4s1FNyZcd0TCfmdJAjfmNJOMxK5LRJrkdoLEdykLlxTtLgLX3R7cGKCRQjfmZsKNua2EExTXs/ckrI9jhXy9G8Ajz99TUv+CbCb3hV7SLNfvVea6CMW9BK77lN0YOZvbwLMELreQK/d5cmNkr5tAbHcQzsRNQL3uL9HP+WYw5zuJnG8Gcn7AkxsD1NY8AOB/ME/4XZi08D+kPBQL7gcILXs4pbgeKdCwfj/JM3SfBzztk8Z84sP6o9E99BjrxgiBHyEI9riyGyOCBTS9kQI8TrgxQAObRzSbPRj02LNYoDzoCckWEG7Mw4DAq9Y2+jb8KFHbJzy4MY8RuJ4skMA/6kkQHyu6MeF6KhL2p0sSuDGnmmQkdl0i0iRPEiR+Rlm4pGjPELie9eDGAI0UujGPEW7MEyWcoLiefS5hfRwr5OuzAB55/rmS+hdkM7kv9JJmuf68MtdFKJ4ncC1UdmPkbJ4AzxK43EKuLPTkxshej4LYniKciUeBer1Qop/zY2DOTxM5PwbkvMiTGwPU1iwC8L+YJ/wuTFr4X1IeigX3IkLLXk4prlcKNKy/QPIM3WeRp33SmE98WH81uodeY90YIfArBMFeV3ZjRLCApjdSgNcJNwZoYPOKZrMHgx57Fm8oD3pCsjcIN+ZlQOBVaxt9G36VqO2bHtyY1whciwsk8K96EsTXim5MuN6KhP3tkgRuzGyTjMSuS0SaZDFB4neUhUuK9g6B610PbgzQSKEb8xrhxrxZwgmK69n3EtbHsUK+vgvgkeffK6l/QTaT+0IvaZbr7ytzXYTifQLXB8pujJzNm+BZApdbyJUPPLkxsterILa3CGfiVaBeH5bo5/wamPPbRM6vATl/5MmNAWprPgLwf5wn/C5MWvg/UR6KBfdHhJZ9mlJcnxVoWP+Q5Bm6z0ee9kljPvFh/fPoHvqCdWOEwJ8RBPtS2Y0RwQKa3kgBviTcGKCBzWeazR4MeuxZfKU86AnJviLcmE8BgVetbfRt+HOitl97cGO+IHB9UyCB/9yTIH5RdGPC9W0k7N+VJHBjZplkJHZdItIk3xAk/l5ZuKRo3xO4fvDgxgCNFLoxXxBuzNclnKC4nv0xYX0cK+TrDwAeef7HkvoXZDO5L/SSZrn+kzLXRSh+InD9rOzGyNl8DZ4lcLmFXPnZkxsje30OYvuWcCY+B+r1S4l+zl+AOX9H5PwFkPOvntwYoLbmVwD/b3nC78Kkhf935aFYcP9KaNkfKcX1Z4GG9V9InqH7/OppnzTmEx/W/4ruob9ZN0YI/CdBsH+U3RgRLKDpjRTgH8KNARrY/KnZ7MGgx55FplR30AtJVoqf4R+AwKvWNvo2/BdRW1Oqi0vcgL8JXM0AXPkU+L88CeLfRTcmXM1L//2zRWkCN+YUk4zErktEmqRZKU7ilsrCJUVrSeBaAmx6xo0BGil0Y/4m3Ji4eCGC4nq2VcL6OFbI1yUAPPJ8q9L6F2QzuS/0kma53lqZ6yIUrQlcbcCzRN0YORsDniVwuYVcaUOePTrQyF5I38rzzUtx/v8FDE5tS/Vz/hvMuQWR899Azu3AnOsW6sYAtTXtAI6X5Am/C5MW/lLloVhwtyO0rCyluMoLNKy3JXmG7tPO0z5pzCc+rFdE91BlaRMbuwZpIXA5QbAqcLhALwERLKDpjRSgqhQfjIEGNuWazR4MeuxZVCsPekKyasKNKQMEXrW20bfhCqK2NR7cmEoCV22BBL7CkyBWeton7W7MkpGwL5XEjTnZJCOx6xKRJqklSLy0snBJ0ZYmcC3jwY0BGil0Y6QhUDemppQTFNezyyasj2OFfF0GwCPPL0t+I0cvaZbr7ZW5LkLRnsDVQdmNkbOpAc8SuNxCrnTw5MbIXhUgtiUJZ6ICqFfHUv2cK8GclyJyrgRy7uTJjQFqazoB+JfLE34XJi38WeWhWHB3IrRs+ZTiWqFAw3pHkmfoPp087ZPGfOLD+orRPdSZdWOEwCsQBFtJ2Y0JBQvYQwqwEuHGAA1sVtBs9mDQY8+ii/KgJyTrQrgxywMCr1rb6NvwikRtu3pwYzoTuFYukMCv6EkQOxfdmHCtEgn7qqUJ3JiTTDISuy4RaZKVCRKvpixcUrTVCFyre3BjgEYK3ZjOhBvTtZQTFNezaySsj2OFfF0dwCPPr1Fa/4JsJveFXtIs17spc12EohuBq7uyGyNn0xU8S+ByC7nS3ZMbI3utCGJbhXAmVgTq1aNUP+fOYM6rEjl3BnLu6cmNAWpregL418wTfhcmLfxrKQ/FgrsnoWVrpxTXOgUa1nuQPEP36elpnzTmEx/W143uofVYN0YIvA5BsPWV3RgRLKDpjRRgfcKNARrYrKPZ7MGgx55FL+VBT0jWi3Bj1gYEXrW20bfhdYna9vbgxqxH4NqgQAK/ridBXK/oxoRrw0jYNypN4MacaJKR2HWJSJNsQJB4Y2XhkqJtTODaxIMbAzRS6MasR7gxvUs5QXE92ydhfRwr5OsmAB55vk9p/QuymdwXekmzXO+rzHURir4Ern7KboycTW/wLIHLLeRKP09ujOy1LohtQ8KZWBeoV/9S/ZzXA3PeiMh5PSDnAZ7cGKC2ZgCAf2Ce8LswaeHfVHkoFtwDCC3bLKW4Ni/QsN6f5Bm6zwBP+6Qxn/iwvkV0Dw1i3Rgh8OYEwQYruzEiWEDTGynAYMKNARrYbK7Z7MGgx57FEOVBT0g2hHBjNgMEXrW20bfhLYjaDvXgxgwicG1ZIIHfwpMgDiq6MeHaKhL2rUsTuDEnmGQkdl0i0iRbEiTeRlm4pGjbELi29eDGAI0UujGDCDdmaCknKK5nt0tYH8cK+botgEee3660/gXZTO4LvaRZrm+vzHURiu0JXDsouzFyNkPBswQut5ArO3hyY2SvLUBsWxHOxBZAvXYs1c95EJjz1kTOg4Ccd/LkxgC1NTsB+HfOE34XJi38uygPxYJ7J0LLdk0prt0KNKzvSPIM3WcnT/ukMZ/4sL57dA/twboxQuDdCIINU3ZjRLCApjdSgGGEGwM0sNlNs9mDQY89i+HKg56QbDjhxuwKCLxqbaNvw7sTtR3hwY3Zg8A1skACv7snQdyj6MaEa89I2PcqTeDGHG+Skdh1iUiTjCRIPEpZuKRoowhcoz24MUAjhW7MHoQbM6KUExTXs3snrI9jhXwdDeCR5/curX9BNpP7Qi9plutjlLkuQjGGwLWPshsjZzMCPEvgcgu5so8nN0b22h3EtifhTOwO1GtsqX7Oe4A570XkvAeQ876e3BigtmZfAP9+ecLvwqSFf3/loVhw70to2QEpxTWuQMP6WJJn6D77etonjfnEh/Xx0T00gXVjhMDjCIJNVHZjRLCApjdSgImEGwM0sBmn2ezBoMeexSTlQU9INolwYw4ABF61ttG34fFEbSd7cGMmELimFEjgx3sSxAlFNyZcB0bCflBpAjfmOJOMxK5LRJpkCkHig5WFS4p2MIHrEA9uDNBIoRszgXBjJpdyguJ6dmrC+jhWyNdDADzy/NTS+hdkM7kv9JJmuT5NmesiFNMIXIcquzFyNpPBswQut5Arh3pyY2Sv8SC2AwlnYjxQr8NK9XOeAOZ8EJHzBCDnwz25MUBtzeEA/iPyhN+FSQv/kcpDseA+nNCyo1KK6+gCDeuHkTxD9znc0z5pzCc+rB8T3UPHsm6MEPhogmDTld0YESyg6Y0UYDrhxgANbI7WbPZg0GPPYobyoCckm0G4MUcBAq9a2+jb8DFEbWd6cGOOJXAdVyCBP8aTIB5bdGPCdXwk7CeUJnBjZppkJHZdItIkxxEkPlFZuKRoJxK4TvLgxgCNFLoxxxJuzEzkWzDw7MkJ6+NYIV9PAvDI8yeX1r8gm8l9oZc0y/VTlLkuQnEKgWuWshsjZzMTPEvgcgu5MsuTGyN7HQNiO55wJo4B6jW7VD/nY8GcTyByPhbI+VRPbgxQW3MqgP+0POF3YdLCf7ryUCy4TyW07IyU4jqzQMP6bJJn6D6netonjfnEh/WzonvobNaNEQKfSRBsjrIbI4IFNL2RAswh3Biggc2Zms0eDHrsWcxVHvSEZHMJN+YMQOBVaxt9Gz6LqO08D27M2QSucwok8Gd5EsSzi25MuM6NhP280gRuzAyTjMSuS0Sa5ByCxOcrC5cU7XwC1wUe3BigkUI35mzCjZlXygmK69kLE9bHsUK+XgDgkecvLK1/QTaT+0IvaZbrFylzXYTiIgLXxcpujJzNPPAsgcst5MrFntwY2essENu5hDNxFlCvS0r1cz4bzPk8IuezgZwv9eTGALU1lwL4L8sTfhcmLfyXKw/FgvtSQsuuSCmuKws0rF9C8gzd51JP+6Qxn/iwflV0D13NujFC4CsJgl2j7MaIYAFNb6QA1xBuDNDA5krNZg8GPfYsrlUe9IRk1xJuzBWAwKvWNvo2fBVR2/ke3JirCVzXFUjgr/IkiFcX3ZhwXR8J+w2lCdyY6SYZiV2XiDTJdQSJb1QWLinajQSumzy4MUAjhW7M1YQbM7+UExTXszcnrI9jhXy9CcAjz99cWv+CbCb3hV7SLNdvUea6CMUtBK5bld0YOZv54FkCl1vIlVs9uTGy11UgtusJZ+IqoF63lernfDWY8w1EzlcDOd/uyY0BamtuB/DfkSf8Lkxa+O9UHooF9+2Elt2VUlx3F2hYv43kGbrP7Z72SWM+8WH9nugeupd1Y4TAdxMEu0/ZjRHBApreSAHuI9wYoIHN3ZrNHgx67FncrzzoCcnuJ9yYuwCBV61t9G34HqK2D3hwY+4lcD1YIIG/x5Mg3lt0Y8L1UCTsD5cmcGOONclI7LpEpEkeJEj8iLJwSdEeIXA96sGNARopdGPuJdyYB0o5QXE9+1jC+jhWyNdHATzy/GOl9S/IZnJf6CXNcv1xZa6LUDxO4Fqg7MbI2TwAniVwuYVcWeDJjZG97gGxPUQ4E/cA9XqiVD/ne8GcHyZyvhfI+UlPbgxQW/MkgP+pPOF3YdLC/7TyUCy4nyS07JmU4nq2QMP6EyTP0H2e9LRPGvOJD+vPRffQ86wbIwR+liDYQmU3RgQLaHojBVhIuDFAA5tnNZs9GPTYs3hBedATkr1AuDHPAAKvWtvo2/BzRG0XeXBjnidwvVgggX/OkyA+X3RjwvVSJOwvlyZwY44xyUjsukSkSV4kSPyKsnBJ0V4hcL3qwY0BGil0Y54n3JhFpZyguJ59LWF9HCvk66sAHnn+tdL6F2QzuS/0kma5/roy10UoXidwvaHsxsjZLALPErjcQq684cmNkb2eA7G9RDgTzwH1erNUP+fnwZxfJnJ+Hsh5sSc3BqitWQzgfytP+F2YtPC/rTwUC+7FhJa9k1Jc7xZoWH+T5Bm6z2JP+6Qxn/iw/l50D73PujFC4HcJgn2g7MaIYAFNb6QAHxBuDNDA5l3NZg8GPfYsPlQe9IRkHxJuzDuAwKvWNvo2/B5R2488uDHvE7g+LpDAv+dJEN8vujHh+iQS9k9LE7gxR5tkJHZdItIkHxMk/kxZuKRonxG4PvfgxgCNFLox7xNuzEelnKC4nv0iYX0cK+Tr5wAeef6L0voXZDO5L/SSZrn+pTLXRSi+JHB9pezGyNl8BJ4lcLmFXPnKkxsje70HYvuEcCbeA+r1dal+zu+DOX9K5Pw+kPM3ntwYoLbmGwD/t3nC78Kkhf875aFYcH9DaNn3KcX1Q4GG9a9JnqH7fONpnzTmEx/Wf4zuoZ9YN0YI/ANBsJ+V3RgRLKDpjRTgZ8KNARrY/KDZ7MGgx57FL8qDnpDsF8KN+R4QeNXaRt+GfyRq+6sHN+YnAtdvBRL4Hz0J4k9FNyZcv0fC/kdpAjfmKJOMxK5LRJrkN4LEfyoLlxTtTwLXXx7cGKCRQjfmJ8KN+bWUExTXs38nrI9jhXz9C8Ajz/9dWv+CbCb3hV7SLNf/Uea6CMU/BK5MGVYv1I2Rs/kVPEvgcgu5IjlkGuDKZcH/kUiD9a08/zvhTPwI1MuU6ef8E5jzH0TOPwE5NwNzrluoGwPU1sQxufA3zxN+FyYt/C1A/KiWCW7Bg2pZy5TiWgLAlc9h3ZA8Q/dp5mmfNOYTH9ZbRfdQ67ImNnYN0kLgJQiCtQEaPQ46m+P7RbCApjdSAMGEDsZAA5slNJs9GPTYs2gLngVKTiFZ2zL8DFsCAq9a2+jbcCuitu2UcYkb0JrAVVIggW/lSRBbe9on7W5MaSTsZWUJ3JgjTTISuy4RaZISgsTlysIlRSsncFUofsOpc2OARgrdGGkI1I1pV8YJiuvZyoT1cayQrxUAHnm+kvxGjl7SLNerlLkuQlFF4KpWdmPkbNqBZwlcbiFXqj25MbJXKxBbaRnO/1ZAvWrK9HNuDeZcRuTcGsi51pMbA9TW1AL4l8wTfhcmLfxLKQ/FgruW0LKlU4prmQIN6zUkz9B9aj3tk8Z84sP6stE91J51Y4TAyxAE66DsxohgAU1vpAAdCDcGaGCzjGazB4MeexYdlQc9IVlHwo1ZGhB41dpG34aXJWrbyYMb057AtVyBBH5ZT4LYvujG/Pv+SNiXL0vgxhxhkpHYdYlIkyxHkHgFZeGSoq1A4FrRgxsDNFLoxrQn3JhOZZyguJ7tnLA+jhXydUUAjzzfuaz+BdlM7gu9pFmur6TMdRGKlQhcXZTdGDmbTuBZApdbyJUuntwY2WtZEFuWcCaWBerVtUw/5/ZgzssTObcHcl7ZkxsD1NasDOBfJU/4XZi08K+qPBQL7pUJLVstpbhWL9Cw3pXkGbrPyp72SWM+8WF9jege6sa6MULg1QmCdVd2Y0SwgKY3UoDuhBsDNLBZXbPZg0GPPYseyoOekKwH4casBgi8am2jb8NrELXt6cGN6UbgWrNAAr+GJ0HsVnRjwrVWJOxrlyVwYw43yUjsukSkSdYkSLyOsnBJ0dYhcK3rwY0BGil0Y7oRbkzPMk5QXM+ul7A+jhXydV0Ajzy/Xln9C7KZ3Bd6SbNcX1+Z6yIU6xO4eim7MXI2PcGzBC63kCu9PLkxstcaILa1CGdiDaBevcv0c+4G5rw2kXM3IOcNPLkxQG3NBgD+DfOE34VJC/9GykOx4N6A0LKNU4prkwIN671JnqH7bOBpnzTmEx/W+0T3UF/WjRECb0IQrJ+yGyOCBTS9kQL0I9wYoIHNJprNHgx67Fn0Vx70hGT9CTdmY0DgVWsbfRvuQ9R2gAc3pi+Ba2CBBL6PJ0HsW3RjwrVpJOyblSVwYw4zyUjsukSkSQYSJN5cWbikaJsTuLbw4MYAjRS6MX0JN2ZAGScormcHJayPY4V83QLAI88PKqt/QTaT+0IvaZbrg5W5LkIxmMA1RNmNkbMZAJ4lcLmFXBniyY2RvfqA2DYlnIk+QL2Glunn3BfMeTMi575Azlt6cmOA2potAfxb5Qm/C5MW/q2Vh2LBvSWhZdukFNe2BRrWh5I8Q/fZ0tM+acwnPqxvF91D27NujBB4W4JgOyi7MSJYQNMbKcAOhBsDNLDZVrPZg0GPPYsdlQc9IdmOhBuzDSDwqrWNvg1vR9R2Jw9uzPYErp0LJPDbeRLE7YtuTLh2iYR917IEbsyhJhmJXZeINMnOBIl3UxYuKdpuBK7dPbgxQCOFbsz2hBuzUxknKK5n90hYH8cK+bo7gEee36Os/gXZTO4LvaRZrg9T5roIxTAC13BlN0bOZifwLIHLLeTKcE9ujOy1HYhtF8KZ2A6o14gy/Zy3B3Pelch5eyDnkZ7cGKC2ZiSAf8884Xdh0sK/l/JQLLhHElo2KqW4RhdoWB9B8gzdZ6SnfdKYT3xY3zu6h8awbowQeDRBsH2U3RgRLKDpjRRgH8KNARrYjNZs9mDQY89irPKgJyQbS7gxowCBV61t9G14b6K2+3pwY8YQuPYrkMDv7UkQxxTdmHDtHwn7AWUJ3JhpJhmJXZeINMl+BInHKQuXFG0cgWu8BzcGaKTQjRlDuDH7lnGC4np2QsL6OFbI1/EAHnl+Qln9C7KZ3Bd6SbNcn6jMdRGKiQSuScpujJzNvuBZApdbyJVJntwY2WtvENv+hDOxN1CvyWX6OY8Bcz6AyHkMkPMUT24MUFszBcB/YJ7wuzBp4T9IeSgW3FMILTs4pbgOKdCwPpnkGbrPFE/7pDGf+LA+NbqHprFujBD4EIJghyq7MSJYByGXQNm/mNDBGGhgc4hmsweDHnsWhykPekKywwg35mBA4FVrG30bnkrU9nAPbsw0AtcRBRL4qZ4EcVrRjQnXkZGwH1WWwI2ZapKR2HWJSJMcQZD4aGXhkqIdTeA6xoMbAzRS6MZMI9yYw8s4QXE9e2zC+jhWyNdjADzy/LFl9S/IZnJf6CXNcn26MtdFKKYTuGYouzFyNoeDZwlcbiFXZnhyY2SvqSC2IwlnYipQr5ll+jlPA3M+ish5GpDzcZ7cGKC25jgA//F5wu/CpIX/BOWhWHAfR2jZiSnFdVKBhvWZJM/QfY7ztE8a84kP6ydH99AprBsjBD6JINgsZTdGBAtoeiMFmEW4MUADm5M0mz0Y9NizmK086AnJZhNuzImAwKvWNvo2fDJR21M9uDGnELhOK5DAn+xJEE8pujHhOj0S9jPKErgxh5hkJHZdItIkpxEkPlNZuKRoZxK4zvLgxgCNFLoxpxBuzKllnKC4nj07YX0cK+TrWYiVb/7FlMH2+XczJCa4pFmuz1HmugjFHALXXGU3Rs7mVPAsgcst5MpcT26M7HUyiO10wpk4GajXvDL9nE8Bcz6DyPkUIOdzPLkxQG3NOQD+c/OE34VJC/95ykOx4D6H0LLzU4rrggIN6/NInqH7nONpnzTmEx/WL4zuoYtYN0YIfAFBsIuV3RgRLKDpjRTgYsKNARrYXKDZ7MGgx57FJcqDnpDsEsKNOR8QeNXaRt+GLyRqe6kHN+YiAtdlBRL4Cz0J4kVFNyZcl0fCfkVZAjfmYJOMxK5LRJrkMoLEVyoLlxTtSgLXVR7cGKCRQjfmIsKNubSMExTXs1cnrI9jhXy9CsAjz19dVv+CbCb3hV7SLNevUea6CMU1BK5rld0YOZtLwbMELreQK9d6cmNkrwtBbJcTzsSFQL3ml+nnfBGY8xVEzhcBOV/nyY0BamuuA/Bfnyf8Lkxa+G9QHooF93WElt2YUlw3FWhYn0/yDN3nOk/7pDGf+LB+c3QP3cK6MULgmwiC3arsxohgAU1vpAC3Em4M0MDmJs1mDwY99ixuUx70hGS3EW7MjYDAq9Y2+jZ8M1Hb2z24MbcQuO4okMDf7EkQbym6MeG6MxL2u8oSuDEHmWQkdl0i0iR3ECS+W1m4pGh3E7ju8eDGAI0UujG3EG7M7WWcoLievTdhfRwr5Os9AB55/t6y+hdkM7kv9JJmuX6fMtdFKO4jcN2v7MbI2dwOniVwuYVcud+TGyN73Qxiu5NwJm4G6vVAmX7Ot4A530XkfAuQ84Oe3BigtuZBAP9DecLvwqSF/2HloVhwP0ho2SMpxfVogYb1B0ieofs86GmfNOYTH9Yfi+6hx1k3Rgj8KEGwBcpujAgW0PRGCrCAcGOABjaPajZ7MOixZ/GE8qAnJHuCcGMeAQRetbbRt+HHiNo+6cGNeZzA9VSBBP4xT4L4eNGNCdfTkbA/U5bAjTnQJCOx6xKRJnmKIPGzysIlRXuWwPWcBzcGaKTQjXmccGOeLOMExfXs8wnr41ghX58D8Mjzz5fVvyCbyX2hlzTL9YXKXBehWEjgekHZjZGzeRI8S+ByC7nygic3RvZ6DMT2NOFMPAbUa1GZfs6Pgzk/Q+T8OJDzi57cGKC25kUA/0t5wu/CpIX/ZeWhWHC/SGjZKynF9WqBhvVFJM/QfV70tE8a84kP669F99DrrBsjBH6VINgbym6MCBbQ9EYK8AbhxgANbF7VbPZg0GPP4k3lQU9I9ibhxrwCCLxqbaNvw68RtV3swY15ncD1VoEE/jVPgvh60Y0J19uRsL9TlsCNmWKSkdh1iUiTvEWQ+F1l4ZKivUvges+DGwM0UujGvE64MYvLOEFxPft+wvo4VsjX9wA88vz7ZfUvyGZyX+glzXL9A2Wui1B8QOD6UNmNkbNZDJ4lcLmFXPnQkxsje70GYnubcCZeA+r1UZl+zq+DOb9D5Pw6kPPHntwYoLbmYwD/J3nC78Kkhf9T5aFYcH9MaNlnKcX1eYGG9Y9InqH7fOxpnzTmEx/Wv4juoS9ZN0YI/DlBsK+U3RgRLKDpjRTgK8KNARrYfK7Z7MGgx57F18qDnpDsa8KN+QwQeNXaRt+GvyBq+40HN+ZLAte3BRL4LzwJ4pdFNyZc30XC/n1ZAjdmsklGYtclIk3yLUHiH5SFS4r2A4HrRw9uDNBIoRvzJeHGfFPGCYrr2Z8S1sexQr7+COCR538qq39BNpP7Qi9plus/K3NdhOJnAtcvym6MnM034FkCl1vIlV88uTGy1xcgtu8IZ+ILoF6/lunn/CWY8/dEzl8COf/myY0Bamt+A/D/nif8Lkxa+P9QHooF92+Elv2ZUlx/FWhY/5XkGbrPb572SWM+8WH97+ge+od1Y4TAfxEEy5RjwwV6CYhgAU1vwgKU44Mx0MDmL81mDwY99iwMeBYoOYVkphw/wz8BgVetbfRt+G+its3KdXGJG/APgas5gCufAv+3J0H8p+jGhKtF+b9/tixP4MZMMslI7LpEpEmal+MkXkJZuKRoSxC4WoFNz7gxQCOFbsw/hBsTFy9EUFzPtk5YH8cK+doKwCPPty6vf0E2k/tCL2mW622UuS5C0YbA1RY8S9SNkbNpBp4lcLmFXGlLnj060MheSN/K8y3Kcf7/DQxO7cr1c/4HzLklkfM/QM4lYM51C3VjgNqaEoDjpXnC78Kkhb9MeSgW3CWElpWnFFdFgYb1diTP0H1KPO2Txnziw3pldA9VlTexsWuQFgJXEASrVnZjRLCApjdSgGrCjQEa2FRoNnsw6LFnUaM86AnJagg3phwQeNXaRt+GK4na1npwY6oIXEsWSOArPQlilad90u7GLBUJ+9JJ3JiJJhmJXZeINMmSBImXURYuKdoyBK5lPbgxQCOFbow0BOrG1JZzguJ6tn3C+jhWyNdlATzyfHvyGzl6SbNc76DMdRGKDgSujspujJxNLXiWwOUWcqWjJzdG9qoEsS1FOBOVQL06levnXAXmvDSRcxWQ83Ke3BigtmY5AH82T/hdmLTwL688FAvu5QgtWyGluFYs0LDeieQZus9ynvZJYz7xYb1zdA+txLoxQuAVCYJ1UXZjRLCApjdSgC6EGwM0sFlRs9mDQY89i67Kg56QrCvhxqwACLxqbaNvw52J2q7swY1ZicC1SoEEvrMnQVyp6MaEa9VI2FcrT+DGTDDJSOy6RKRJViFIvLqycEnRVidwreHBjQEaKXRjViLcmJXLOUFxPdstYX0cK+TrGgAeeb5bef0LspncF3pJs1zvrsx1EYruBK4eym6MnM3K4FkCl1vIlR6e3BjZqzOIbVXCmegM1KtnuX7OK4E5r0bkvBKQ85qe3BigtmZNAP9aecLvwqSFf23loVhwr0lo2TopxbVugYb1niTP0H3W9LRPGvOJD+vrRffQ+qwbIwRelyBYL2U3RgQLaHojBehFuDFAA5t1NZs9GPTYs+itPOgJyXoTbsw6gMCr1jb6NrweUdsNPLgx6xO4NiyQwK/nSRDXL7ox4dooEvaNyxO4MeNNMhK7LhFpkg0JEm+iLFxStE0IXH08uDFAI4VuzPqEG7NBOScormf7JqyPY4V87QPgkef7lte/IJvJfaGXNMv1fspcF6HoR+Dqr+zGyNlsAJ4lcLmFXOnvyY2RvdYDsW1EOBPrAfUaUK6f8/pgzhsTOa8P5DzQkxsD1NYMBPBvmif8Lkxa+DdTHooF90BCyzZPKa4tCjSsDyB5hu4z0NM+acwnPqwPiu6hwawbIwTegiDYEGU3RgQLaHojBRhCuDFAA5stNJs9GPTYsxiqPOgJyYYSbszmgMCr1jb6NjyIqO2WHtyYwQSurQok8IM8CeLgohsTrq0jYd+mPIEbM84kI7HrEpEm2Yog8bbKwiVF25bAtZ0HNwZopNCNGUy4MVuWc4Lienb7hPVxrJCv2wF45Pnty+tfkM3kvtBLmuX6DspcF6HYgcC1o7IbI2ezJXiWwOUWcmVHT26M7DUIxLY14UwMAuq1U7l+zoPBnLchch4M5LyzJzcGqK3ZGcC/S57wuzBp4d9VeSgW3DsTWrZbSnHtXqBhfSeSZ+g+O3vaJ435xIf1PaJ7aBjrxgiBdycINlzZjRHBApreSAGGE24M0MBmd81mDwY99ixGKA96QrIRhBuzGyDwqrWNvg3vQdR2pAc3ZhiBa88CCfwengRxWNGNCddekbCPKk/gxhxgkpHYdYlIk+xJkHi0snBJ0UYTuPb24MYAjRS6McMIN2ZkOScormfHJKyPY4V83RvAI8+PKa9/QTaT+0IvaZbr+yhzXYRiHwLXWGU3Rs5mJHiWwOUWcmWsJzdG9toDxLYX4UzsAdRr33L9nIeBOY8ich4G5LyfJzcGqK3ZD8C/f57wuzBp4T9AeSgW3PsRWjYupbjGF2hY35fkGbrPfp72SWM+8WF9QnQPTWTdGCHweIJgk5TdGBEsoOmNFGAS4cYADWzGazZ7MOixZzFZedATkk0m3JhxgMCr1jb6NjyBqO0UD27MRALXgQUS+AmeBHFi0Y0J10GRsB9cnsCN2d8kI7HrEpEmOZAg8SHKwiVFO4TANdWDGwM0UujGTCTcmCnlnKC4np2WsD6OFfJ1KvLtxvyLKYPt8+9mSExwSbNcP1SZ6yIUhxK4DlN2Y+RspoBnCVxuIVcO8+TGyF4TQGwHEc7EBKBeh5fr5zwRzPlgIueJQM5HeHJjgNqaIwD8R+YJvwuTFv6jlIdiwX0EoWVHpxTXMQUa1g8neYbuc4SnfdKYT3xYPza6h6azbowQ+BiCYDOU3RgRLKDpjRRgBuHGAA1sjtFs9mDQY89ipvKgJySbSbgxRwMCr1rb6NvwsURtj/PgxkwncB1fIIE/1pMgTi+6MeE6IRL2E8sTuDH7mWQkdl0i0iTHEyQ+SVm4pGgnEbhO9uDGAI0UujHTCTfmuHJOUFzPnpKwPo4V8vVk5H8rN/9iymD7/LsZEhNc0izXZylzXYRiFoFrtrIbI2dzHHiWwOUWcmW2JzdG9joWxHYC4UwcC9Tr1HL9nKeDOZ9I5DwdyPk0T24MUFtzGoD/9Dzhd2HSwn+G8lAsuE8jtOzMlOI6q0DD+qkkz9B9TvO0TxrziQ/rZ0f30BzWjRECn0UQbK6yGyOCBTS9kQLMJdwYoIHNWZrNHgx67FnMUx70hGTzCDfmTEDgVWsbfRs+m6jtOR7cmDkErnMLJPBnexLEOUU3JlznRcJ+fnkCN2Zfk4zErktEmuRcgsQXKAuXFO0CAteFHtwYoJFCN2YO4cacU84JiuvZixLWx7FCvl4I4JHnLyqvf0E2k/tCL2mW6xcrc12E4mIC1yXKboyczTngWQKXW8iVSzy5MbLX2SC28whn4mygXpeW6+c8B8z5fCLnOUDOl3lyY4DamssA/JfnCb8Lkxb+K5SHYsF9GaFlV6YU11UFGtYvJXmG7nOZp33SmE98WL86uoeuYd0YIfBVBMGuVXZjRLCApjdSgGsJNwZoYHOVZrMHgx57FvOVBz0h2XzCjbkSEHjV2kbfhq8manudBzfmGgLX9QUS+Ks9CeI1RTcmXDdEwn5jeQI3ZqxJRmLXJSJNcj1B4puUhUuKdhOB62YPbgzQSKEbcw3hxlxXzgmK69lbEtbHsUK+3gzgkedvKa9/QTaT+0IvaZbrtypzXYTiVgLXbcpujJzNdeBZApdbyJXbPLkxstfVILYbCGfiaqBet5fr53wNmPONRM7XADnf4cmNAWpr7gDw35kn/C5MWvjvUh6KBfcdhJbdnVJc9xRoWL+d5Bm6zx2e9kljPvFh/d7oHrqPdWOEwPcQBLtf2Y0RwQKa3kgB7ifcGKCBzT2azR4MeuxZPKA86AnJHiDcmLsBgVetbfRt+F6itg96cGPuI3A9VCCBv9eTIN5XdGPC9XAk7I+UJ3Bj9jHJSOy6RKRJHiJI/KiycEnRHiVwPebBjQEaKXRj7iPcmAfLOUFxPft4wvo4VsjXxwA88vzj5fUvyGZyX+glzXJ9gTLXRSgWELieUHZj5GweBM8SuNxCrjzhyY2Rve4FsT1MOBP3AvV6slw/5/vAnB8hcr4PyPkpT24MUFvzFID/6Tzhd2HSwv+M8lAsuJ8itOzZlOJ6rkDD+pMkz9B9nvK0TxrziQ/rz0f30ELWjRECP0cQ7AVlN0YEC2h6IwV4gXBjgAY2z2k2ezDosWexSHnQE5ItItyYZwGBV61t9G34eaK2L3pwYxYSuF4qkMA/70kQFxbdmHC9HAn7K+UJ3JgxJhmJXZeINMlLBIlfVRYuKdqrBK7XPLgxQCOFbsxCwo15sZwTFNezryesj2OFfH0NwCPPv15e/4JsJveFXtIs199Q5roIxRsErjeV3Rg5mxfBswQut5Arb3pyY2Sv50FsLxPOxPNAvRaX6+e8EMz5FSLnhUDOb3lyY4DamrcA/G/nCb8Lkxb+d5SHYsH9FqFl76YU13sFGtYXkzxD93nL0z5pzCc+rL8f3UMfsG6MEPg9gmAfKrsxIlhA0xspwIeEGwM0sHlPs9mDQY89i4+UBz0h2UeEG/MuIPCqtY2+Db9P1PZjD27MBwSuTwok8O97EsQPim5MuD6NhP2z8gRuzN4mGYldl4g0yScEiT9XFi4p2ucEri88uDFAI4VuzAeEG/NxOScorme/TFgfxwr5+gWAR57/srz+BdlM7gu9pFmuf6XMdRGKrwhcXyu7MXI2H4NnCVxuIVe+9uTGyF7vg9g+JZyJ94F6fVOun/MHYM6fETl/AOT8rSc3Bqit+RbA/12e8LswaeH/XnkoFtzfElr2Q0px/VigYf0bkmfoPt962ieN+cSH9Z+ie+hn1o0RAv9IEOwXZTdGBAtoeiMF+IVwY4AGNj9qNnsw6LFn8avyoCck+5VwY34ABF61ttG34Z+I2v7mwY35mcD1e4EE/idPgvhz0Y0J1x+RsP9ZnsCNGW2Skdh1iUiT/E6Q+C9l4ZKi/UXg+tuDGwM0UujG/Ey4Mb+Vc4LievafhPVxrJCvfwN45Pl/yutfkM3kvtBLmuV6pkKX66FQVOC4TAVWL9SNkbP5DTxL4HILuSI5ZBrgymWhA43s9ROI7Q/CmfgJqFezCv2cfwZz/pPI+Wcg5+ZgznULdWOA2po4Jhf+FnnC78Kkhb8liB/VMsHdnNCyJVKKqxWAK5/DejOSZ+g+zT3tk8Z84sN66+gealPRxMauQVoI3IogWFtwuEAvAREsoOmNFEAwoYMx0MCmlWazB4MeexbtlAc9IVm7CvwMlwAEXrW20bfh1kRtS5RxiRvQhsBVWiCBb+1JENt42iftbkxZJOzlFQncmFEmGYldl4g0SSlB4gpl4ZKiVRC4KhW/4dS5MUAjhW6MNATqxpRUcILierYqYX0cK+RrJYBHnq+qqH9BNpP7Qi9pluvVylwXoagmcNUouzFyNiXgWQKXW8iVGk9ujOzVGsRWVoHzvzVQr9oK/ZzbgDmXEzm3AXJe0pMbA9TWLAngXypP+F2YtPAvrTwUC+4lCS1bJqW4li3QsF5L8gzdZ0lP+6Qxn/iw3j66hzpUNLGxa5AWAi9LEKyjshsjggU0vZECdCTcGKCBzbKazR4MeuxZdFIe9IRknQg3ZhlA4FVrG30bbk/UdjkPbkwHAle2QALf3pMgdii6MeFaPhL2FSoSuDF7mWQkdl0iYZMQJF5RWbikaCsSuDp7cGOARgrdmA6EG7McIMBZ4NmVEtbHsUK+dgbwyPMrVdS/IJvJfaGXNMv1LspcF6HoQuDqquzGyNksB54lcLmFXOnqyY2RvdqD2JavwPnfHqjXyhX6OXcAc16ByLkDkPMqntwYoLZmFQD/qnnC78KkhX815aFYcK9CaNnqKcW1RoGG9ZVJnqH7rOJpnzTmEx/Wu0X3UPeKJjZ2DdJC4DUIgvVQdmNEsICmN1KAHoQbAzSwWUOz2YNBjz2LnsqDnpCsJ+HGrA4IvGpto2/D3YjarunBjelO4FqrQALfzZMgdi+6MeFaOxL2dSoSuDF7mmQkdl0i0iRrESReV1m4pGjrErjW8+DGAI0UujHdCTdmzQpOUFzPrp+wPo4V8nU9AI88v35F/QuymdwXekmzXO+lzHURil4Ert7KboyczZrgWQKXW8iV3p7cGNmrG4ht7Qqc/92Aem1QoZ9zdzDndYicuwM5b+jJjQFqazYE8G+UJ/wuTFr4N1YeigX3hoSWbZJSXH0KNKxvQPIM3WdDT/ukMZ/4sN43uof6VTSxsWuQFgL3IQjWX9mNEcECmt5IAfoTbgzQwKaPZrMHgx57FgOUBz0h2QDCjdkEEHjV2kbfhvsStR3owY3pR+DatEAC39eTIPYrujHh2iwS9s0rErgxI00yErsuEWmSTQkSb6EsXFK0LQhcgzy4MUAjhW5MP8KNGVjBCYrr2cEJ6+NYIV8HAXjk+cEV9S/IZnJf6CXNcn2IMtdFKIYQuIYquzFyNgPBswQut5ArQz25MbJXXxDbZhU4//sC9dqyQj/nfmDOmxM59wNy3sqTGwPU1mwF4N86T/hdmLTwb6M8FAvurQgt2zaluLYr0LC+JckzdJ+tPO2Txnziw/r20T20Q0UTG7sGaSHwdgTBdlR2Y0SwgKY3UoAdCTcGaGCznWazB4MeexY7KQ96QrKdCDdmW0DgVWsbfRvenqjtzh7cmB0IXLsUSOC39ySIOxTdmHDtGgn7bhUJ3JgRJhmJXZeINMkuBIl3VxYuKdruBK49PLgxQCOFbswOhBuzcwUnKK5nhyWsj2OFfN0DwCPPD6uof0E2k/tCL2mW68OVuS5CMZzANULZjZGz2Rk8S+ByC7kiOWQa4MploQON7LU9iE3OBeV/fA+nW1Khn/MOYM67ETnvAOS8J5hz3ULdGKC2Zk8A/155wu/CpIV/FIgf1TLBLXhQLRudUlx7A7jyOayPJHmG7rOnp33SmE98WB8T3UP7VDSxsWuQFgLvTRBsLNDocdDZHN8vggU0vZECjK3AB2Oggc3ems0eDHrsWewLngVKTiHZvhX4GY4GBF61ttG34TFEbfdTxiVuwD4Erv0LJPBjPAniPp72Sbsbc0Ak7OMqErgxw00yErsuEWmS/QkSj1cWLinaeALXBMVvOHVuDNBIoRsjDYG6MftVcILienZiwvo4VsjXCQAeeX5iRf0LspncF3pJs1yfpMx1EYpJBK7J4FmiboyczX7gWQKXW8iVyZ7cGNlrDIjtgAqc/2OAek2p0M95HzDncUTO+wA5H+jJjQFqaw4E8B+UJ/wuTFr4D1YeigX3gYSWHZJSXFMLNKxPIXmG7nOgp33SmE98WJ8W3UOHVjSxsWuQFgJPJQh2mLIbI4IFNL2RAhxGuDFAA5upms0eDHrsWRyuPOgJyQ4n3JhDAIFXrW30bXgaUdsjPLgxhxK4jiyQwE/zJIiHFt2YcB0VCfvRFQncmGEmGYldl4g0yZEEiY9RFi4p2jEErmM9uDFAI4VuzKGEG3NEBScormenJ6yPY4V8PRbAI89Pr6h/QTaT+0IvaZbrM5S5LkIxg8A1U9mNkbM5AjxL4HILuTLTkxsje00DsR1VgfN/GlCv4yr0cz4UzPloIudDgZyP9+TGALU1xwP4T8gTfhcmLfwnKg/Fgvt4QstOSimukws0rB9H8gzd53hP+6Qxn/iwfkp0D82qaGJj1yAtBD6ZINhsZTdGBAtoeiMFmE24MUADm5M1mz0Y9NizOFV50BOSnUq4MScBAq9a2+jb8ClEbU/z4MbMInCdXiCBP8WTIM4qujHhOiMS9jMrErgxe5hkJHZdItIkpxMkPktZuKRoZxG4zvbgxgCNFLoxswg35rQKTlBcz85JWB/HCvl6NoBHnp9TUf+CbCb3hV7SLNfnKnNdhGIugWueshsjZ3MaeJbA5RZyZZ4nN0b2OgXEdkYFzv9TgHqdU6Gf8yww5zOJnGcBOZ/ryY0BamvOBfCflyf8Lkxa+M9XHooF97mEll2QUlwXFmhYP4fkGbrPuZ72SWM+8WH9ougeuriiiY1dg7QQ+EKCYJcouzEiWEDTGynAJYQbAzSwuVCz2YNBjz2LS5UHPSHZpYQbcwEg8Kq1jb4NX0TU9jIPbszFBK7LCyTwF3kSxIuLbky4roiE/cqKBG7M7iYZiV2XiDTJ5QSJr1IWLinaVQSuqz24MUAjhW7MxYQbc1kFJyiuZ69JWB/HCvl6NYBHnr+mov4F2UzuC72kWa5fq8x1EYprCVzzld0YOZvLwLMELreQK/M9uTGy10UgtisqcP5fBNTrugr9nC8Gc76SyPliIOfrPbkxQG3N9QD+G/KE34VJC/+NykOx4L6e0LKbUorr5gIN69eRPEP3ud7TPmnMJz6s3xLdQ7dWNLGxa5AWAt9MEOw2ZTdGBAtoeiMFuI1wY4AGNjdrNnsw6LFncbvyoCcku51wY24CBF61ttG34VuI2t7hwY25lcB1Z4EE/hZPgnhr0Y0J112RsN9dkcCN2c0kI7HrEpEmuZMg8T3KwiVFu4fAda8HNwZopNCNuZVwY+6o4ATF9ex9CevjWCFf7wXwyPP3VdS/IJvJfaGXNMv1+5W5LkJxP4HrAWU3Rs7mDvAsgcst5MoDntwY2esWENtdFTj/bwHq9WCFfs63gjnfTeR8K5DzQ57cGKC25iEA/8N5wu/CpIX/EeWhWHA/RGjZoynF9ViBhvUHSZ6h+zzkaZ805hMf1h+P7qEFFU1s7BqkhcCPEQR7QtmNEcECmt5IAZ4g3Biggc1jms0eDHrsWTypPOgJyZ4k3JhHAYFXrW30bfhxorZPeXBjFhC4ni6QwD/uSRAXFN2YcD0TCfuzFQncmF1NMhK7LhFpkqcJEj+nLFxStOcIXM97cGOARgrdmAWEG/NUBScormcXJqyPY4V8fR7AI88vrKh/QTaT+0IvaZbrLyhzXYTiBQLXImU3Rs7mKfAsn67AuLLIkxsjez0OYnumAuf/40C9XqzQz3kBmPOzRM4LgJxf8uTGALU1LwH4X84TfhcmLfyvKA/FgvslQsteTSmu1wo0rL9I8gzd5yVP+6Qxn/iw/np0D71R0cTGrkFaCPwaQbA3ld0YESyg6Y0U4E3CjQEa2Lym2ezBoMeexWLlQU9ItphwY14FBF61ttG34deJ2r7lwY15g8D1doEE/nVPgvhG0Y0J1zuRsL9bkcCN2cUkI7HrEpEmeZsg8XvKwiVFe4/A9b4HNwZopNCNeYNwY96q4ATF9ewHCevjWCFf3wfwyPMfVNS/IJvJfaGXNMv1D5W5LkLxIYHrI2U3Rs7mLfAsgcst5MpHntwY2et1ENs7FTj/Xwfq9XGFfs5vgDm/S+T8BpDzJ57cGKC25hMA/6d5wu/CpIX/M+WhWHB/QmjZ5ynF9UWBhvWPSZ6h+3ziaZ805hMf1r+M7qGvKprY2DVIC4G/IAj2tbIbI4IFNL2RAnxNuDFAA5svNJs9GPTYs/hGedATkn1DuDGfAwKvWtvo2/CXRG2/9eDGfEXg+q5AAv+lJ0H8qujGhOv7SNh/qEjgxuxskpHYdYlIk3xHkPhHZeGSov1I4PrJgxsDNFLoxnxFuDHfVnCC4nr254T1cayQrz8BeOT5nyvqX5DN5L7QS5rl+i/KXBeh+IXA9auyGyNn8y14lsDlFnLlV09ujOz1JYjt+wqc/18C9fqtQj/nr8CcfyBy/grI+XdPbgxQW/M7gP+PPOF3YdLC/6fyUCy4fye07K+U4vq7QMP6byTP0H1+97RPGvOJD+v/1N1DlU1s7BqkhcB/EwQzldhwgV4CIlhA0xspgGBCB2Oggc3fms0eDHrsWTQDzwIlp5CsWSV+hn8BAq9a2+jb8D9EbZtX6uISNyDkLoirBYArnwL/jydBzFT62SftbkzLSNiXqEzgxuxkkpHYdYlIk7QgSNxKWbikaK0IXK1B8jFuDNBIoRsjDYG6MXHxQgTF9WybhPVxrJCvrQE88nybyvoXZDO5L/SSZrneVpnrIhRtCVztwLNE3Rg5m+bgWQKXW8iVduTZowON7IX0rTzfshLn/z/A4FRSqZ9zBjyPJYicMwBHSsnhAHVjgNqaUgB/WZ7wuzBp4S9XHooFdymhZRUpxVVZoGG9hOQZuk+pp33SmE98WK+K7qFq1o0RAlcSBKtRdmNEsICmN1KAGsKNARrYVGo2ezDosWdRqzzoCclqCTemAhB41dpG34ariNou6cGNqSZwLVUgga/yJIjVRTcmXEtHwr5MZQI3ZkeTjMSuS0SaZCmCxMsqC5cUbVkCV3sPbgzQSKEbU024MUtWcoLierZDwvo4VsjX9gAeeb5DZf0LspncF3pJs1zvqMx1EYqOBK5Oym6MnM2S4FkCl1vIlU6e3BjZqwrEtjThTFQB9VquUj/najDnZYicq4Gcs57cGKC2JgvgXz5P+F2YtPCvoDwUh7gJLVsxpbg6F2hYX47kGbpP1tM+acwnPqyvFN1DXVg3RgjcmSBYV2U3RgQLaHojBehKuDFAA5vOms0eDHrsWaysPOgJyVYm3JgVAYFXrW30bXglorareHBjuhC4Vi2QwK/kSRC7FN2YcK0WCfvqlQncmB1MMhK7LhFpklUJEq+hLFxStDUIXN08uDFAI4VuTBfCjVmlkhMU17PdE9bHsUK+dgPwyPPdK+tfkM3kvtBLmuV6D2Wui1D0IHD1VHZj5GxWAc8SuNxCrvT05MbIXiuB2FYjnImVgHqtWamfcxcw59WJnLsAOa/lyY0BamvWAvCvnSf8Lkxa+NdRHooF91qElq2bUlzrFWhYX5PkGbrPWp72SWM+8WF9/ege6sW6MULg9QiC9VZ2Y0SwgKY3UoDehBsDNLBZT7PZg0GPPYsNlAc9IdkGhBuzLiDwqrWNvg2vT9R2Qw9uTC8C10YFEvj1PQlir6IbE66NI2HfpDKBG7O9SUZi1yUiTbIRQeI+ysIlRetD4OrrwY0BGil0Y3oRbsyGlZyguJ7tl7A+jhXytS+AR57vV1n/gmwm94Ve0izX+ytzXYSiP4FrgLIbI2ezIXiWwOUWcmWAJzdG9lofxLYx4UysD9RrYKV+zr3AnDchcu4F5LypJzcGqK3ZFMC/WZ7wuzBp4d9ceSgW3JsSWrZFSnENKtCwPpDkGbrPpp72SWM+8WF9cHQPDWHdGCHwIIJgQ5XdGBEsoOmNFGAo4cYADWwGaTZ7MOixZ7Gl8qAnJNuScGO2AARetbbRt+HBRG238uDGDCFwbV0ggR/sSRCHFN2YcG0TCfu2lQncmO1MMhK7LhFpkq0JEm+nLFxStO0IXNt7cGOARgrdmCGEG7NVJScozv+9PGF9HCvk6/YAHnl+h8r6F2QzuS/0kma5vqMy10UodiRw7aTsxsjZbAWeJXC5hVzZyZMbI3sNBrFtQzgTg4F67Vypn/MQMOdtiZyHADnv4smNAWprdgHw75on/C5MWvh3Ux6KBfcuhJbtnlJcexRoWN+Z5Bm6zy6e9kljPvFhfVh0Dw1n3Rgh8B4EwUYouzEiWEDTGynACMKNARrY7KHZ7MGgx57FSOVBT0g2knBjdgcEXrW20bfhYURt9/TgxgwncO1VIIEf5kkQhxfdmHCNioR9dGUCN2Zbk4zErktEmmQvgsR7KwuXFG1vAtcYD24M0EihGzOccGP2rOQExfXsPgnr41ghX8cAeOT5fSrrX5DN5L7QS5rl+lhlrotQjCVw7avsxsjZ7AmeJXC5hVzZ15MbI3sNA7GNIpyJYUC99qvUz3k4mPNoIufhQM77e3JjgNqa/QH8B+QJvwuTFv5xykOx4N6f0LLxKcU1oUDD+n4kz9B99ve0TxrziQ/rE6N7aBLrxgiBJxAEm6zsxohgAU1vpACTCTcGaGAzQbPZg0GPPYspyoOekGwK4caMBwRetbbRt+GJRG0P9ODGTCJwHVQggZ/oSRAnFd2YcB0cCfshlQncmG1MMhK7LhFpkoMIEk9VFi4p2lQC1zQPbgzQSKEbM4lwYw6s5ATF9eyhCevjWCFfpwF45PlDK+tfkM3kvtBLmuX6YcpcF6E4jMB1uLIbI2dzIHiWwOUWcuVwT26M7DURxHYw4UxMBOp1RKV+zpPAnA8hcp4E5HykJzcGqK05EsB/VJ7wuzBp4T9aeSgW3EcSWnZMSnEdW6Bh/QiSZ+g+R3raJ435xIf16dE9NIN1Y4TAxxIEm6nsxohgAU1vpAAzCTcGaGBzrGazB4MeexbHKQ96QrLjCDfmGEDgVWsbfRueTtT2eA9uzAwC1wkFEvjpngRxRtGNCdeJkbCfVJnAjdnaJCOx6xKRJjmBIPHJysIlRTuZwHWKBzcGaKTQjZlBuDHHV3KC4np2VsL6OFbI11MAPPL8rMr6F2QzuS/0kma5PluZ6yIUswlcpyq7MXI2x4NnCVxuIVdO9eTGyF7TQWwnEs7EdKBep1Xq5zwDzPkkIucZQM6ne3JjgNqa0wH8Z+QJvwuTFv4zlYdiwX06oWVnpRTX2QUa1k8jeYbuc7qnfdKYT3xYnxPdQ3NZN0YIfDZBsHnKbowIFtD0Rgowj3BjgAY2Z2s2ezDosWdxjvKgJyQ7h3BjzgIEXrW20bfhOURtz/XgxswlcJ1XIIGf40kQ5xbdmHCdHwn7BZUJ3JitTDISuy4RaZLzCBJfqCxcUrQLCVwXeXBjgEYK3Zi5hBtzbiUnKK5nL05YH8cK+XoRgEeev7iy/gXZTO4LvaRZrl+izHURiksIXJcquzFyNueCZwlcbiFXLvXkxshec0Bs5xPOxBygXpdV6uc8F8z5AiLnuUDOl3tyY4DamssB/FfkCb8Lkxb+K5WHYsF9OaFlV6UU19UFGtYvI3mG7nO5p33SmE98WL8muoeuZd0YIfDVBMHmK7sxIlhA0xspwHzCjQEa2Fyt2ezBoMeexXXKg56Q7DrCjbkKEHjV2kbfhq8hanu9BzfmWgLXDQUS+Gs8CeK1RTcmXDdGwn5TZQI3ZkuTjMSuS0Sa5AaCxDcrC5cU7WYC1y0e3BigkUI35lrCjbm+khMU17O3JqyPY4V8vQXAI8/fWln/gmwm94Ve0izXb1PmugjFbQSu25XdGDmb68GzBC63kCu3e3JjZK9rQGw3Es7ENUC97qjUz/laMOebiJyvBXK+05MbA9TW3AngvytP+F2YtPDfrTwUC+47CS27J6W47i3QsH4HyTN0nzs97ZPGfOLD+n3RPXQ/68YIge8lCPaAshsjggU0vZECPEC4MUADm3s1mz0Y9NizeFB50BOSPUi4MfcAAq9a2+jb8H1EbR/y4MbcT+B6uEACf58nQby/6MaE65FI2B+tTODGDDXJSOy6RKRJHiZI/JiycEnRHiNwPe7BjQEaKXRj7ifcmIcqOUFxPbsgYX0cK+Tr4wAeeX5BZf0LspncF3pJs1x/QpnrIhRPELieVHZj5GweAs8SuNxCrjzpyY2Rve4DsT1COBP3AfV6qlI/5/vBnB8lcr4fyPlpT24MUFvzNID/mTzhd2HSwv+s8lAsuJ8mtOy5lOJ6vkDD+lMkz9B9nva0TxrziQ/rC6N76AXWjRECP08QbJGyGyOCBTS9kQIsItwYoIHN85rNHgx67Fm8qDzoCcleJNyY5wCBV61t9G14IVHblzy4MS8QuF4ukMAv9CSILxTdmHC9Egn7q5UJ3JghJhmJXZeINMnLBIlfUxYuKdprBK7XPbgxQCOFbswLhBvzUiUnKK5n30hYH8cK+fo6gEeef6Oy/gXZTO4LvaRZrr+pzHURijcJXIuV3Rg5m5fAswQut5Ariz25MbLXQhDbK4QzsRCo11uV+jm/AOb8KpHzC0DOb3tyY4DamrcB/O/kCb8Lkxb+d5WHYsH9NqFl76UU1/sFGtbfInmG7vO2p33SmE98WP8guoc+ZN0YIfD7BME+UnZjRLCApjdSgI8INwZoYPO+ZrMHgx57Fh8rD3pCso8JN+Y9QOBVaxt9G/6AqO0nHtyYDwlcnxZI4D/wJIgfFt2YcH0WCfvnlQncmMEmGYldl4g0yacEib9QFi4p2hcEri89uDFAI4VuzIeEG/NJJScorme/Slgfxwr5+iWAR57/qrL+BdlM7gu9pFmuf63MdRGKrwlc3yi7MXI2n4BnCVxuIVe+8eTGyF4fgNg+I5yJD4B6fVupn/OHYM6fEzl/COT8nSc3Bqit+Q7A/32e8LswaeH/QXkoFtzfEVr2Y0px/VSgYf1bkmfoPt952ieN+cSH9Z+je+gX1o0RAv9EEOxXZTdGBAtoeiMF+JVwY4AGNj9pNnsw6LFn8ZvyoCck+41wY34EBF61ttG34Z+J2v7uwY35hcD1R4EE/mdPgvhL0Y0J15+RsP9VmcCNGWSSkdh1iUiT/EGQ+G9l4ZKi/U3g+seDGwM0UujG/EK4Mb9XcoLiejZTlaw+jhXy9R8AjzwvmDLYPv9uhsQElzTLdVOly3URCtkDxdUMPEvUjZGz+R08S+ByC7nSjDx7dKCRvX4Gsf1JOBM/A/VqXqWf8y9gzn8ROf8C5NwCzLluoW4MUFsTx+TC3zJP+F2YtPAvAeJHtUxwtyC0rFVKcbUGcOVzWG9O8gzdp4WnfdKYT3xYbxPdQ22rmtjYNUgLgVsTBGsHDhfoJSCCBTS9kQIIJnQwBhrYtNZs9mDQY8+iRHnQE5KVVOFn2AoQeNXaRt+G2xC1LVXGJW5AWwJXWYEEvo0nQWzraZ+0uzHlkbBXVCVwY7YwyUjsukSkScoIElcqC5cUrZLAVaX4DafOjQEaKXRjpCFQN6a0ihMU17PVym6M8LUKwCPPV3tyY1iu1yhzXYSihsBVq+zGyNmUgmcJXG4hV2o9uTGyVxsQW3kVzv82QL2WrNLPuS2YcwWRc1sg56U8uTFAbc1SAP6l84TfhUkL/zLKQ7HgXorQsmVTiqt9gYb1JUmeofss5WmfNOYTH9Y7RPdQR9aNEQK3JwjWSdmNEcECmt5IAToRbgzQwKa9ZrMHgx57FsspD3pCsuUIN2ZZQOBVaxt9G+5A1DbrwY3pSOBavkAC38GTIHYsujHhWiES9hWrErgxm5tkJHZdItIkyxMk7qwsXFK0zgSulTy4MUAjhW5MR8KNyVZxguJ6tkvC+jhWyNeVADzyfJeq+hdkM7kv9JJmud5VmesiFF0JXCsruzGh9oBnCVxuIVdW9uTGyF4dQGwrEM5EB6Beq1Tp59wRzHlFIueOQM6renJjgNqaVQH8q+UJvwuTFv7VlYdiwb0qoWVrpBRXtwIN66uQPEP3WdXTPmnMJz6sd4/uoR6sGyME7kYQrKeyGyOCBTS9kQL0JNwYoIFNN81mDwY99izWVB70hGRrEm7MGoDAq9Y2+jbcnajtWh7cmB4ErrULJPDdPQlij6IbE651ImFftyqBG7OZSUZi1yUiTbI2QeL1lIVLirYegWt9D24M0EihG9ODcGPWquIExfVsr4T1cayQr+sDeOT5XlX1L8hmcl/oJc1yvbcy10UoehO4NlB2Y+Rs1gLPErjcQq5s4MmNkb26g9jWIZyJ7kC9NqzSz7kHmPO6RM49gJw38uTGALU1GwH4N84TfhcmLfybKA/FgnsjQsv6pBRX3wIN6xuSPEP32cjTPmnMJz6s94vuof6sGyME7ksQbICyGyOCBTS9kQIMINwYoIFNX81mDwY99iwGKg96QrKBhBvTBxB41dpG34b7EbXd1IMb05/AtVmBBL6fJ0HsX3RjwrV5JOxbVCVwYzY1yUjsukSkSTYjSDxIWbikaIMIXIM9uDFAI4VuTH/CjdkU+RYMPDskYX0cK+TrYACPPD+kqv4F2UzuC72kWa4PVea6CMVQAteWym6MnM2m4FkCl1vIlS09uTGyVz8Q2+aEM9EPqNdWVfo59wdz3oLIuT+Q89ae3BigtmZrAP82ecLvwqSFf1vloVhwb01o2XYpxbV9gYb1rUieofts7WmfNOYTH9Z3iO6hHVk3Rgi8PUGwnZTdGBEsoOmNFGAnwo0BGthsr9nswaDHnsXOyoOekGxnwo3ZDhB41dpG34Z3IGq7iwc3ZkcC164FEvgdPAnijkU3Jly7RcK+e1UCN2agSUZi1yUiTbIrQeI9lIVLirYHgWuYBzcGaKTQjdmRcGN2qeIExfXs8IT1cayQr8MAPPL88Kr6F2QzuS/0kma5PkKZ6yIUIwhcI5XdGDmbXcCzBC63kCsjPbkxstcOILbdCGdiB6Bee1bp57wjmPPuRM47Ajnv5cmNAWpr9gLwj8oTfhcmLfyjlYdiwb0XoWV7pxTXmAIN63uSPEP32cvTPmnMJz6s7xPdQ2NZN0YIPIYg2L7KbowIFtD0RgqwL+HGAA1sxmg2ezDosWexn/KgJyTbj3Bj9gYEXrW20bfhfYja7u/BjRlL4DqgQAK/jydBHFt0Y8I1LhL28VUJ3JgBJhmJXZeINMkBBIknKAuXFG0CgWuiBzcGaKTQjRlLuDH7V3GC4np2UsL6OFbI14kAHnl+UlX9C7KZ3Bd6SbNcn6zMdRGKyQSuKcpujJzN/uBZApdbyJUpntwY2WsfENs4wpnYB6jXgVX6OY8Fcx5P5DwWyPkgT24MUFtzEID/4Dzhd2HSwn+I8lAsuA8itGxqSnFNK9CwfiDJM3Sfgzztk8Z84sP6odE9dBjrxgiBpxEEO1zZjRHBApreSAEOJ9wYoIHNNM1mDwY99iyOUB70hGRHEG7MVEDgVWsbfRs+lKjtkR7cmMMIXEcVSOAP9SSIhxXdmHAdHQn7MVUJ3Jj+JhmJXZeINMlRBImPVRYuKdqxBK7pHtwYoJFCN+Ywwo05sooTFNezMxLWx7FCvk4H8MjzM6rqX5DN5L7QS5rl+kxlrotQzCRwHafsxsjZHAmeJXC5hVw5zpMbI3sdCmI7mnAmDgXqdXyVfs6HgTkfQ+R8GJDzCZ7cGKC25gQA/4l5wu/CpIX/JOWhWHCfQGjZySnFdUqBhvXjSZ6h+5zgaZ805hMf1mdF99Bs1o0RAp9CEOxUZTdGBAtoeiMFOJVwY4AGNqdoNnsw6LFncZryoCckO41wY04GBF61ttG34VlEbU/34MbMJnCdUSCBn+VJEGcX3ZhwnRkJ+1lVCdyYfiYZiV2XiDTJGQSJz1YWLina2QSuOR7cGKCRQjdmNuHGnF7FCYrr2bkJ6+NYIV/nAHjk+blV9S/IZnJf6CXNcn2eMtdFKOYRuM5RdmPkbE4HzxK43EKunOPJjZG9ZoHYziSciVlAvc6t0s95NpjzWUTOs4Gcz/PkxgC1NecB+M/PE34XJi38FygPxYL7PELLLkwprosKNKyfS/IM3ec8T/ukMZ/4sH5xdA9dwroxQuCLCIJdquzGiGABTW+kAJcSbgzQwOYizWYPBj32LC5THvSEZJcRbsyFgMCr1jb6NnwxUdvLPbgxlxC4riiQwF/sSRAvKbox4boyEvarqhK4MX1NMhK7LhFpkisIEl+tLFxStKsJXNd4cGOARgrdmEsIN+byKk5QXM9em7A+jhXy9RoAjzx/bVX9C7KZ3Bd6SbNcn6/MdRGK+QSu65TdGDmby8GzBC63kCvXeXJjZK+LQWxXEs7ExUC9rq/Sz/kSMOeriJwvAXK+wZMbA9TW3ADgvzFP+F2YtPDfpDwUC+4bCC27OaW4binQsH49yTN0nxs87ZPGfOLD+q3RPXQb68YIgW8hCHa7shsjggU0vZEC3E64MUADm1s0mz0Y9NizuEN50BOS3UG4MTcDAq9a2+jb8K1Ebe/04MbcRuC6q0ACf6snQbyt6MaE6+5I2O+pSuDG9DHJSOy6RKRJ7iJIfK+ycEnR7iVw3efBjQEaKXRjbiPcmDurOEFxPXt/wvo4VsjX+wA88vz9VfUvyGZyX+glzXL9AWWui1A8QOB6UNmNkbO5EzxL4HILufKgJzdG9roVxHY34UzcCtTroSr9nG8Dc76HyPk2IOeHPbkxQG3NwwD+R/KE34VJC/+jykOx4H6Y0LLHUorr8QIN6w+RPEP3edjTPmnMJz6sL4juoSdYN0YI/DhBsCeV3RgRLKDpjRTgScKNARrYPK7Z7MGgx57FU8qDnpDsKcKNeQwQeNXaRt+GFxC1fdqDG/MEgeuZAgn8Ak+C+ETRjQnXs5GwP1eVwI3ZxCQjsesSkSZ5hiDx88rCJUV7nsC10IMbAzRS6MY8QbgxT1dxguJ69oWE9XGskK8LATzy/AtV9S/IZnJf6CXNcn2RMtdFKBYRuF5UdmPkbJ4GzxK43EKuvOjJjZG9FoDYniWciQVAvV6q0s/5CTDn54icnwByftmTGwPU1rwM4H8lT/hdmLTwv6o8FAvulwktey2luF4v0LD+EskzdJ+XPe2Txnziw/ob0T30JuvGCIFfJwi2WNmNEcECmt5IARYTbgzQwOZ1zWYPBj32LN5SHvSEZG8RbsxrgMCr1jb6NvwGUdu3PbgxbxK43imQwL/hSRDfLLox4Xo3Evb3qhK4MRubZCR2XSLSJO8QJH5fWbikaO8TuD7w4MYAjRS6MW8SbszbVZyguJ79MGF9HCvk6wcAHnn+w6r6F2QzuS/0kma5/pEy10UoPiJwfazsxsjZvA2eJXC5hVz52JMbI3u9AWJ7l3Am3gDq9UmVfs5vgjm/R+T8JpDzp57cGKC25lMA/2d5wu/CpIX/c+WhWHB/SmjZFynF9WWBhvVPSJ6h+3zqaZ805hMf1r+K7qGvWTdGCPwlQbBvlN0YESyg6Y0U4BvCjQEa2Hyp2ezBoMeexbfKg56Q7FvCjfkCEHjV2kbfhr8iavudBzfmawLX9wUS+K88CeLXRTcmXD9Ewv5jVQI3ZiOTjMSuS0Sa5HuCxD8pC5cU7ScC188e3BigkUI35mvCjfmuihMU17O/JKyPY4V8/RnAI8//UlX/gmwm94Ve0izXf1XmugjFrwSu35TdGDmb78CzBC63kCu/eXJjZK+vQGw/EM7EV0C9fq/Sz/lrMOcfiZy/BnL+w5MbA9TW/AHg/zNP+F2YtPD/pTwUC+4/CC37O6W4/inQsP47yTN0nz887ZPGfOLDeqY6ekF1Exu7Bmkh8D8EwZpVY8MFegmIYAFNb6QAggkdjIEGNv9oNnsw6LFn0Rw8C5ScQrLm1fgZ/g0IvGpto2/Dkgda2xbVurjEDTAErpYArnwKfAasR30gto/xtE/a3ZglImFvVZ3AjdnQJCOx6xKRJmlJkLi1snBJ0VoTuNqA5GPcGKCRQjdGGgJ1Y+LihQiK69m2CevjWCFf2wB45Pm21fUvyGZyX+glzXK9nTLXRSjaEbhKwLNE3Rg5mxbgWQKXW8iVEvLs0YFG9sqA2JaoxvmfAepVWq2fswFzbkXkbICcy8jhAHVjgNqaMgB/eZ7wuzBp4a9QHooFdxmhZZUpxVVVoGG9lOQZuk+Zp33SmE98WK+O7qEa1o0RAlcRBKtVdmNEsICmN1KAWsKNARrYVGk2ezDosWexpPKgJyRbknBjKgGBV61t9G24mqjtUh7cmBoC19IFEvhqT4JYU3RjwrVMJOzLVidwYzYwyUjsukSkSZYmSNxeWbikaO0JXB08uDFAI4VuTA3hxixVzQmK69mOCevjWCFfOwB45PmO1fUvyGZyX+glzXK9kzLXRSg6EbiWU3Zj5GyWAs8SuNxCriznyY2RvapBbMsQzkQ1UK9stX7ONWDOyxI51wA5L+/JjQFqa5YH8K+QJ/wuTFr4V1QeigX38oSWdU4prpUKNKxnSZ6h+yzvaZ805hMf1rtE91BX1o0RAq9EEGxlZTdGBAtoeiMFWJlwY4AGNitpNnsw6LFnsYryoCckW4VwYzoDAq9a2+jbcBeitqt6cGO6ErhWK5DAd/EkiF2Lbky4Vo+EfY3qBG5Mb5OMxK5LRJpkNYLE3ZSFS4rWjcDV3YMbAzRS6MZ0JdyYVas5QXE92yNhfRwr5Gt3AI8836O6/gXZTO4LvaRZrvdU5roIRU8C15rKboyczargWQKXW8iVNT25MbJXFxDb6oQz0QWo11rV+jl3BXNeg8i5K5Dz2p7cGKC2Zm0A/zp5wu/CpIV/XeWhWHCvTWjZeinFtX6BhvW1SJ6h+6ztaZ805hMf1ntF91Bv1o0RAq9PEGwDZTdGBGtd5BKo/hcTOhgDDWzW12z2YNBjz2JD5UFPSLYh4casBwi8am2jb8O9iNpu5MGN6U3g2rhAAt/LkyD2Lrox4dokEvY+1QncmF4mGYldl4g0ycYEifsqC5cUrS+Bq58HNwZopNCN6U24MRtVc4LierZ/wvo4VsjXfgAeeb5/df0LspncF3pJs1wfoMx1EYoBBK6Bym6MnM1G4FkCl1vIlYGe3BjZqxeIbRPCmegF1GvTav2ce4M59yFy7g3kvJknNwaordkMwL95nvC7MGnh30J5KBbcmxFaNiiluAYXaFjflOQZPER72ieN+cSH9SHRPTSUdWOEwIMJgm2p7MaIYAFNb6QAWxJuDNDAZrBmsweDHnsWWykPekKyrQg3ZhAg8Kq1jb4NDyFqu7UHN2YogWubAgn8EE+COLToxoRr20jYt6tO4Masb5KR2HWJSJNsQ5B4e2XhkqJtT+DawYMbAzRS6MYMJdyYras5QXE9u2PC+jhWyNcdECvf/Ispg+3z72ZITHBJs1zfSZnrIhQ7Ebh2VnZj5Gy2Bs8SuNxCruzsyY2RvYaA2LYlnIkhQL12qdbPeSiY83ZEzkOBnHf15Mbsgmg0gH+3POF3YdLCv7vyUCy4dyW0bI+U4hpWoGF9F5Jn6D67etonjfnEh/Xh0T00gnVjhMDDCIKNVHZjRLCApjdSgJGEGwM0sBmm2ezBoMeexZ7Kg56QbE/CjdkDEHjV2kbfhocTtd3LgxszgsA1qkACP9yTII4oujHhGh0J+97VCdyY9UwyErsuEWmSUQSJxygLlxRtDIFrHw9uDNBIoRszgnBj9qrmBMX17NiE9XGskK/7AHjk+bHV9S/IZnJf6CXNcn1fZa6LUOxL4NpP2Y2Rs9kLPEvgcgu5sp8nN0b2Gg5iG004E8OBeu1frZ/zCDDnvYmcRwA5H+DJjQFqaw4A8I/LE34XJi3845WHYsF9AKFlE1KKa2KBhvX9SZ6h+xzgaZ805hMf1idF99Bk1o0RAk8kCDZF2Y0RwQKa3kgBphBuDNDAZqJmsweDHnsWByoPekKyAwk3ZgIg8Kq1jb4NTyJqe5AHN2YygevgAgn8JE+COLnoxoTrkEjYp1YncGPWNclI7LpEpEkOJkg8TVm4pGjTCFyHenBjgEYK3ZjJhBtzUDUnKK5nD0tYH8cK+XoogEeeP6y6/gXZTO4LvaRZrh+uzHURisMJXEcouzFyNgeBZwlcbiFXjvDkxshek0BshxDOxCSgXkdW6+c8Gcx5KpHzZCDnozy5MUBtzVEA/qPzhN+FSQv/McpDseA+itCyY1OKa3qBhvUjSZ6h+xzlaZ805hMf1mdE99BM1o0RAk8nCHacshsjggU0vZECHEe4MUADm+mazR4MeuxZHK886AnJjifcmGMBgVetbfRteAZR2xM8uDEzCVwnFkjgZ3gSxJlFNyZcJ0XCfnJ1AjdmHZOMxK5LRJrkRILEpygLlxTtFALXLA9uDNBIoRszk3BjTqjmBMX17OyE9XGskK+zADzy/Ozq+hdkM7kv9JJmuX6qMtdFKE4lcJ2m7MbI2ZwAniVwuYVcOc2TGyN7zQCxnUQ4EzOAep1erZ/zTDDnk4mcZwI5n+HJjQFqa84A8J+ZJ/wuTFr4z1IeigX3GYSWnZ1SXHMKNKyfTvIM3ecMT/ukMZ/4sD43uofmsW6MEHgOQbBzlN0YESyg6Y0U4BzCjQEa2MzRbPZg0GPP4lzlQU9Idi7hxpwNCLxqbaNvw3OJ2p7nwY2ZR+A6v0ACP9eTIM4rujHhuiAS9gurE7gxa5tkJHZdItIk5xMkvkhZuKRoFxG4LvbgxgCNFLox8wg35rxqTlBcz16SsD6OFfL1YgCPPH9Jdf0LspncF3pJs1y/VJnrIhSXErguU3Zj5GzOA88SuNxCrlzmyY2RveaC2C4gnIm5QL0ur9bPeR6Y84VEzvOAnK/w5MYAtTVXAPivzBN+FyYt/FcpD8WC+wpCy65OKa5rCjSsX07yDN3nCk/7pDGf+LB+bXQPzWfdGCHwNQTBrlN2Y0SwgKY3UoDrCDcGaGBzjWazB4MeexbXKw96QrLrCTfmakDgVWsbfRu+lqjtDR7cmPkErhsLJPDXehLE+UU3Jlw3RcJ+c3UCN2Ytk4zErktEmuRGgsS3KAuXFO0WAtetHtwYoJFCN2Y+4cbcUM0JiuvZ2xLWx7FCvt4K4JHnb6uuf0E2k/tCL2mW67crc12E4nYC1x3KboyczQ3gWQKXW8iVOzy5MbLXtSC2mwhn4lqgXndW6+c8H8z5ZiLn+UDOd3lyY4DamrsA/HfnCb8Lkxb+e5SHYsF9F6Fl96YU130FGtbvJHmG7nOXp33SmE98WL8/uoceYN0YIfB9BMEeVHZjRLCApjdSgAcJNwZoYHOfZrMHgx57Fg8pD3pCsocIN+ZeQOBVaxt9G76fqO3DHtyYBwhcjxRI4O/3JIgPFN2YcD0aCftj1QncmDVNMhK7LhFpkkcIEj+uLFxStMcJXAs8uDFAI4VuzAOEG/NwNScormefSFgfxwr5ugDAI88/UV3/gmwm94Ve0izXn1TmugjFkwSup5TdGDmbh8GzBC63kCtPeXJjZK/7QWyPEs7E/UC9nq7Wz/kBMOfHiJwfAHJ+xpMbA9TWPAPgfzZP+F2YtPA/pzwUC+5nCC17PqW4FhZoWH+a5Bm6zzOe9kljPvFh/YXoHlrEujFC4IUEwV5UdmNEsICmN1KAFwk3Bmhgs1Cz2YNBjz2Ll5QHPSHZS4Qb8zwg8Kq1jb4Nv0DU9mUPbswiAtcrBRL4FzwJ4qKiGxOuVyNhf606gRvT0yQjsesSkSZ5hSDx68rCJUV7ncD1hgc3Bmik0I1ZRLgxL1dzguJ69s2E9XGskK9vAHjk+Ter61+QzeS+0Eua5fpiZa6LUCwmcL2l7MbI2bwMniVwuYVcecuTGyN7vQBie5VwJl4A6vV2tX7Oi8CcXyNyXgTk/I4nNwaorXkHwP9unvC7MGnhf095KBbc7xBa9n5KcX1QoGH9bZJn6D7veNonjfnEh/UPo3voI9aNEQJ/QBDsY2U3RgQLaHojBfiYcGOABjYfaDZ7MOixZ/GJ8qAnJPuEcGPeBwRetbbRt+EPidp+6sGN+YjA9VmBBP5DT4L4UdGNCdfnkbB/UZ3AjelhkpHYdYlIk3xGkPhLZeGSon1J4PrKgxsDNFLoxnxEuDGfVnOC4nr264T1cayQr18BeOT5r6vrX5DN5L7QS5rl+jfKXBeh+IbA9a2yGyNn8yl4lsDlFnLlW09ujOz1IYjtc8KZ+BCo13fV+jl/BOb8BZHzR0DO33tyY4Damu8B/D/kCb8Lkxb+H5WHYsH9PaFlP6UU188FGta/I3mG7vO9p33SmE98WP8luod+Zd0YIfDPBMF+U3ZjRLCApjdSgN8INwZoYPOzZrMHgx57Fr8rD3pCst8JN+YnQOBVaxt9G/6FqO0fHtyYXwlcfxZI4H/xJIi/Ft2YcP0VCfvf1QncmO4mGYldl4g0yZ8Eif9RFi4p2j8ErkyN3jecOjcGaKTQjfmVcGP+qOYExfWsSVgfxwr5Gj8DFx55XjBlsH3+3QyJCS5pluvNanS5LkIhe6C4moNniboxcjYID+V54HILudKcPHt0oJG9fgGx/VWN8/8XoF4tavRz/hXM+W8i51+BnFuCOdct1I0BamtaAnq1RJ7wuzBp4W8F4ke1THC3JLSsdUpxtQFw5XNYb0HyDN2npad90phPfFhvG91D7Wqa2Ng1SAuB2xAEKwGHC/QSEMECmt5IAQQTOhgDDWzaaDZ7MOixZ1GqPOgJyUpr8DNsDQi8am2jb8NtidqWKeMSN6Adgau8QALf1pMgtvO0T9rdmIpI2CtrErgx3UwyErsuEWmScoLEVcrCJUWrInBVe3BjgEYK3RhpCNSNKavhBMX1bI2yGyN8rQbwyPM1ntwYluu1ylwXoaglcC2p7MbI2ZSBZwlcbiFXlvTkxshebUFsFTU4/9sC9VqqRj/ndmDOlUTO7YCcl/bkxgC1NUsD+JfJE34XJi38yyoPxYJ7aULL2qcUV4cCDetLkTxD91na0z5pzCc+rHeM7qFOrBsjBO5AEGw5ZTdGBAtoeiMFWI5wY4AGNh00mz0Y9NizyCoPekKyLOHGtAcEXrW20bfhjkRtl/fgxnQicK1QIIHv6EkQOxXdmHCtGAl755oEbswaJhmJXZeINMkKBIlXUhYuKdpKBK4uHtwYoJFCN6YT4cYsX8MJiuvZrgnr41ghX7sAeOT5rjX1L8hmcl/oJc1yfWVlrotQrEzgWkXZjZGzWR48S+ByC7myiic3RvbqCGJbkXAmOgL1WrVGP+dOYM6diZw7ATmv5smNAWprVgPwr54n/C5MWvjXUB6KBfdqhJZ1Symu7gUa1lcleYbus5qnfdKYT3xY7xHdQz1ZN0YI3J0g2JrKbowIFtD0RgqwJuHGAA1sums2ezDosWexlvKgJyRbi3BjugECr1rb6NtwD6K2a3twY3oSuNYpkMD38CSIPYtuTLjWjYR9vZoEbszqJhmJXZeINMk6BInXVxYuKdr6BK5eHtwYoJFCN6Yn4casXcMJiuvZ3gnr41ghX3sh327Mv5gy2D7/bobEBJc0y/UNlLkuQrEBgWtDZTdGzmZt8CyByy3kyoae3BjZqweIbV3CmegB1GujGv2ce4I5r0fk3BPIeWNPbgxQW7MxgH+TPOF3YdLC30d5KBbcGxNa1jeluPoVaFjfiOQZus/GnvZJYz7xYb1/dA8NYN0YIXA/gmADld0YESyg6Y0UYCDhxgANbPppNnsw6LFnsanyoCck25RwY/oCAq9a2+jbcH+itpt5cGMGELg2L5DA9/ckiAOKbky4toiEfVBNAjdmNZOMxK5LRJpkc4LEg5WFS4o2mMA1xIMbAzRS6MYMINyYzWo4QXE9OzRhfRwr5OsQ5H8rN/9iymD7/LsZEhNc0izXt1TmugjFlgSurZTdGDmbzcCzBC63kCtbeXJjZK/+ILYtCGeiP1CvrWv0cx4A5jyIyHkAkPM2ntwYoLZmGwD/tnnC78KkhX875aFYcG9DaNn2KcW1Q4GG9a1JnqH7bONpnzTmEx/Wd4zuoZ1YN0YIvANBsJ2V3RgRLKDpjRRgZ8KNARrY7KDZ7MGgx57FLsqDnpBsF8KN2R4QeNXaRt+GdyRqu6sHN2YnAtduBRL4HT0J4k5FNyZcu0fCvkdNAjdmVZOMxK5LRJpkN4LEw5SFS4o2jMA13IMbAzRS6MbsRLgxu9ZwguJ6dkTC+jhWyNfhAB55fkRN/QuymdwXekmzXB+pzHURipEErj2V3Rg5m13BswQut5Are3pyY2SvHUFsuxPOxI5Avfaq0c95JzDnPYicdwJyHuXJjQFqa0YB+EfnCb8Lkxb+vZWHYsE9itCyMSnFtU+BhvW9SJ6h+4zytE8a84kP62Oje2hf1o0RAu9DEGw/ZTdGBAtoeiMF2I9wY4AGNvtoNnsw6LFnsb/yoCck259wY8YAAq9a2+jb8Fiitgd4cGP2JXCNK5DAj/UkiPsW3ZhwjY+EfUJNAjdmFZOMxK5LRJpkHEHiicrCJUWbSOCa5MGNARopdGP2JdyYA2o4QXE9OzlhfRwr5OskAI88P7mm/gXZTO4LvaRZrk9R5roIxRQC14HKboyczQHgWQKXW8iVAz25MbLXWBDbeMKZGAvU66Aa/Zz3BXOeQOS8L5DzwZ7cGKC25mAA/yF5wu/CpIV/qvJQLLgPJrRsWkpxHVqgYf0gkmfoPgd72ieN+cSH9cOie+hw1o0RAh9KEOwIZTdGBAtoeiMFOIJwY4AGNodqNnsw6LFncaTyoCckO5JwY6YBAq9a2+jb8GFEbY/y4MYcTuA6ukACf5gnQTy86MaE65hI2I+tSeDGrGySkdh1iUiTHE2QeLqycEnRphO4ZnhwY4BGCt2Ywwk35qgaTlBcz85MWB/HCvk6A8Ajz8+sqX9BNpP7Qi9pluvHKXNdhOI4Atfxym6MnM1R4FkCl1vIleM9uTGy12EgtmMIZ+IwoF4n1OjnfDiY87FEzocDOZ/oyY0BamtOBPCflCf8Lkxa+E9WHooF94mElp2SUlyzCjSsn0DyDN3nRE/7pDGf+LA+O7qHTmXdGCHwLIJgpym7MSJYQNMbKcBphBsDNLCZpdnswaDHnsXpyoOekOx0wo05BRB41dpG34ZnE7U9w4MbcyqB68wCCfxsT4J4atGNCddZkbCfXZPAjelqkpHYdYlIk5xJkHiOsnBJ0eYQuOZ6cGOARgrdmFMJN+aMGk5QXM/OS1gfxwr5OhfAI8/Pq6l/QTaT+0IvaZbr5yhzXYTiHALXucpujJzNGeBZApdbyJVzPbkxstdsENtZhDMxG6jXeTX6OZ8K5nw2kfOpQM7ne3JjgNqa8wH8F+QJvwuTFv4LlYdiwX0+oWUXpRTXxQUa1s8jeYbuc76nfdKYT3xYvyS6hy5l3Rgh8MUEwS5TdmNEsICmN1KAywg3Bmhgc7FmsweDHnsWlysPekKyywk35iJA4FVrG30bvoSo7RUe3JhLCVxXFkjgL/EkiJcW3ZhwXRUJ+9U1CdyYLiYZiV2XiDTJlQSJr1EWLinaNQSuaz24MUAjhW7MpYQbc0UNJyiuZ+cnrI9jhXy9FsAjz8+vqX9BNpP7Qi9pluvXKXNdhOI6Atf1ym6MnM0V4FkCl1vIles9uTGy1yUgtqsIZ+ISoF431OjnfCmY89VEzpcCOd/oyY0BamtuBPDflCf8Lkxa+G9WHooF942Elt2SUly3FmhYv4HkGbrPjZ72SWM+8WH9tugeup11Y4TAtxIEu0PZjRHBApreSAHuINwYoIHNrZrNHgx67FncqTzoCcnuJNyYWwCBV61t9G34NqK2d3lwY24ncN1dIIG/zZMg3l50Y8J1TyTs99YkcGNWMslI7LpEpEnuJkh8n7JwSdHuI3Dd78GNARopdGNuJ9yYu2o4QXE9+0DC+jhWyNf7ATzy/AM19S/IZnJf6CXNcv1BZa6LUDxI4HpI2Y2Rs7kLPEvgcgu58pAnN0b2ug3Edg/hTNwG1OvhGv2cbwdzvpfI+XYg50c8uTFAbc0jAP5H84TfhUkL/2PKQ7HgfoTQssdTimtBgYb1h0meofs84mmfNOYTH9afiO6hJ1k3Rgi8gCDYU8pujAgW0PRGCvAU4cYADWwWaDZ7MOixZ/G08qAnJHuacGMeBwRetbbRt+EniNo+48GNeZLA9WyBBP4JT4L4ZNGNCddzkbA/X5PAjelskpHYdYlIkzxLkHihsnBJ0RYSuF7w4MYAjRS6MU8SbswzNZyguJ5dlLA+jhXy9QUAjzy/qKb+BdlM7gu9pFmuv6jMdRGKFwlcLym7MXI2z4BnCVxuIVde8uTGyF5PgNieI5yJJ4B6vVyjn/OTYM7PEzk/CeT8iic3BqiteQXA/2qe8LswaeF/TXkoFtyvEFr2ekpxvVGgYf1lkmfoPq942ieN+cSH9Teje2gx68YIgd8gCPaWshsjggU0vZECvEW4MUADmzc0mz0Y9NizeFt50BOSvU24Ma8DAq9a2+jb8JtEbd/x4MYsJnC9WyCBf9OTIC4uujHhei8S9vdrErgxK5pkJHZdItIk7xIk/kBZuKRoHxC4PvTgxgCNFLoxiwk35p0aTlBcz36UsD6OFfL1QwCPPP9RTf0LspncF3pJs1z/WJnrIhQfE7g+UXZj5GzeAc8SuNxCrnziyY2Rvd4Esb1HOBNvAvX6tEY/58Vgzu8TOS8Gcv7MkxsD1NZ8BuD/PE/4XZi08H+hPBQL7s8ILfsypbi+KtCw/inJM3Sfzzztk8Z84sP619E99A3rxgiBvyII9q2yGyOCBTS9kQJ8S7gxQAObrzSbPRj02LP4TnnQE5J9R7gxXwICr1rb6Nvw10Rtv/fgxnxD4PqhQAL/tSdB/KboxoTrx0jYf6pJ4MasYJKR2HWJSJP8QJD4Z2XhkqL9TOD6xYMbAzRS6MZ8Q7gx39dwguJ69teE9XGskK+/AHjk+V9r6l+QzeS+0Eua5fpvylwXofiNwPW7shsjZ/M9eJbA5RZy5XdPbozs9TWI7UfCmfgaqNcfNfo5fwPm/BOR8zdAzn96cmOA2po/Afx/5Qm/C5MW/r+Vh2LB/SehZf+kFFemtjDD+h8kz9B9/vS0TxrziQ/rpjb6u9omNnYN0kJgIQtKsOa5E8zEQWdzfL8IFtD0RgogmNDB+B9kSKrN6DV7MOixZ9ECPAuUnEKyFrX4Gf4DCLxqbaNvw4aobUtlXOIGNCNwLVEggTdgPdh9mnnaJ+1uTKtI2FvXJnBjljfJSOy6RKRJliBI3EZZuKRobQhcbUHyMW4M0EihGxNecA32sYM6/c+4eCGC4nq2XcL6OFbI17YAHnm+XW39C7KZ3Bd6SbNcL1HmughFCYGrFDxL1I2Rs2kJniVwuYVcKSXPHh1oZC8DYmtVi/PfAPUqq9XPuRmYc2si52ZAzuXkcIC6MUBtTTmAvyJP+F2YtPBXKg/Fgruc0LKqlOKqLtCwXkbyDN2n3NM+acwnPqzXRPdQLevGCIGrCYItqezGiGABTW+kAEsSbgzQwKZas9mDQY89i6WUBz0h2VKEG1MFCLxqbaNvwzVEbZf24MbUEriWKZDA13gSxNqiGxOuZSNhb1+bwI3JmmQkdl0i0iTLECTuoCxcUrQOBK6OHtwYoJFCN6aWcGOWruUExfVsp4T1cayQrx0BPPJ8p9r6F2QzuS/0kma5vpwy10UoliNwZZXdGDmbpcGzBC63f7XNkxsje9WA2JYlnIkaxL2q1c+5Fsy5PZFzLZDzCp7cGKC2ZgUA/4p5wu/CpIW/s/JQLLhXILRspZTi6lKgYX15kmfoPit42ieN+cSH9a7RPbQy68YIgbsQBFtF2Y0RwQKa3kgBViHcGKCBTRfNZg8GPfYsVlUe9IRkqxJuzEqAwKvWNvo23JWo7Woe3JiVCVyrF0jgu3oSxJWLbky41oiEvVttAjdmOZOMxK5LRJpkdYLE3ZWFS4rWncDVw4MbAzRS6MasTLgxq9VyguJ6tmfC+jhWyNceAB55vmdt/QuymdwXekmzXF9TmesiFGsSuNZSdmPkbFYDzxK43EKurOXJjZG9uoLY1iCcia5Avdau1c95ZTDnbkTOKwM5r+PJjQFqa9YB8K+bJ/wuTFr411MeigX3OoSWrZ9SXL0KNKyvTfIM3WcdT/ukMZ/4sN47uoc2YN0YIXAvgmAbKrsxIlhA0xspwIaEGwM0sOml2ezBoMeexUbKg56QbCPCjVkfEHjV2kbfhnsTtd3YgxuzAYFrkwIJfG9PgrhB0Y0JV59I2PvWJnBjOplkJHZdItIkmxAk7qcsXFK0fgSu/h7cGKCRQjdmA8KN2biWExTXswMS1sexQr72B/DI8wNq61+QzeS+0Eua5fpAZa6LUAwkcG2q7MbI2WwMniVwuYVc2dSTGyN79Qax9SGcid5AvTar1c95AzDnvkTOGwA5b+7JjQFqazYH8G+RJ/wuTFr4B2kPxbX/njGqZYNTimtIgYb1zUiewcOtr2E9hfnEh/Wh0T20JevGCIGHEATbStmNEcECmt5IAbYi3Biggc0QzWYPBj32LLZWHvSEZFsTbsxgQOBVaxt9Gx5K1HYbD27MlgSubQsk8EM9CeKWRTcmXNtFwr59bQI3pqNJRmLXJSJNsi1B4h2UhUuKtgOBa0cPbgzQSKEbsyXhxmxTywmK69mdEtbHsUK+7gjgked3qq1/QTaT+0IvaZbrOytzXYRiZwLXLspujJzNNuBZApdbyJVdPLkxstdQENt2hDMxFKjXrrX6OW8J5rw9kfOWQM67eXJjgNqa3QD8u+cJvwuTFv49lIdiwb0boWXDUopreIGG9V1JnqH77OZpnzTmEx/WR0T30EjWjRECDycItqeyGyOCBTS9kQLsSbgxQAOb4ZrNHgx67FnspTzoCcn2ItyYYYDAq9Y2+jY8gqjtKA9uzEgC1+gCCfwIT4I4sujGhGvvSNjH1CZwYzqYZCR2XSLSJKMJEu+jLFxStH0IXGM9uDFAI4VuzEjCjRlVywmK69l9E9bHsUK+jgXwyPP71ta/IJvJfaGXNMv1/ZS5LkKxH4Frf2U3Rs5mFHiWwOUWcmV/T26M7DUCxLY34UyMAOp1QK1+ziPBnMcQOY8Ech7nyY0BamvGAfjH5wm/C5MW/gnKQ7HgHkdo2cSU4ppUoGH9AJJn6D7jPO2Txnziw/rk6B6awroxQuBJBMEOVHZjRLCApjdSgAMJNwZoYDNJs9mDQY89i4OUBz0h2UGEGzMREHjV2kbfhicTtT3YgxszhcB1SIEEfrInQZxSdGPCNTUS9mm1CdyY9iYZiV2XiDTJIQSJD1UWLinaoQSuwzy4MUAjhW7MFMKNObiWExTXs4cnrI9jhXw9DMAjzx9eW/+CbCb3hV7SLNePUOa6CMURBK4jld0YOZuDwbMELreQK0d6cmNkr8kgtqmEMzEZqNdRtfo5TwFznkbkPAXI+WhPbgxQW3M0gP+YPOF3YdLCf6zyUCy4jya0bHpKcc0o0LB+FMkzdJ+jPe2Txnziw/rM6B46jnVjhMAzCIIdr+zGiGABTW+kAMcTbgzQwGaGZrMHgx57FicoD3pCshMIN2Y6IPCqtY2+Dc8kanuiBzfmOALXSQUS+JmeBPG4ohsTrpMjYT+lNoEbs6xJRmLXJSJNchJB4lnKwiVFm0Xgmu3BjQEaKXRjjiPcmBNrOUFxPXtqwvo4VsjX2QAeef7U2voXZDO5L/SSZrl+mjLXRShOI3CdruzGyNmcCJ4lcLmFXDndkxsje80EsZ1MOBMzgXqdUauf83FgzqcQOR8H5HymJzcGqK05E8B/Vp7wuzBp4T9beSgW3GcSWjYnpbjmFmhYP4PkGbrPmZ72SWM+8WF9XnQPncO6MULguQTBzlV2Y0SwgKY3UoBzCTcGaGAzV7PZg0GPPYvzlAc9Idl5hBszBxB41dpG34bnEbU934Mbcw6B64ICCfw8T4J4TtGNCdeFkbBfVJvAjVnGJCOx6xKRJrmAIPHFysIlRbuYwHWJBzcGaKTQjTmHcGPOr+UExfXspQnr41ghXy8B8Mjzl9bWvyCbyX2hlzTL9cuUuS5CcRmB63JlN0bO5nzwLIHLLeTK5Z7cGNlrHojtQsKZmAfU64pa/ZzPAXO+iMj5HCDnKz25MUBtzZUA/qvyhN+FSQv/1cpDseC+ktCya1KK69oCDetXkDxD97nS0z5pzCc+rM+P7qHrWDdGCHwtQbDrld0YESyg6Y0U4HrCjQEa2Fyr2ezBoMeexQ3Kg56Q7AbCjbkGEHjV2kbfhucTtb3RgxtzHYHrpgIJ/HxPgnhd0Y0J182RsN9Sm8CNWdokI7HrEpEmuYkg8a3KwiVFu5XAdZsHNwZopNCNuY5wY26s5QTF9eztCevjWCFfbwPwyPO319a/IJvJfaGXNMv1O5S5LkJxB4HrTmU3Rs7mRvAsgcst5MqdntwY2Ws+iO1mwpmYD9Trrlr9nK8Dc76FyPk6IOe7PbkxQG3N3QD+e/KE34VJC/+9ykOx4L6b0LL7Uorr/gIN63eRPEP3udvTPmnMJz6sPxDdQw+ybowQ+H6CYA8puzEiWEDTGynAQ4QbAzSwuV+z2YNBjz2Lh5UHPSHZw4Qbcx8g8Kq1jb4NP0DU9hEPbsyDBK5HCyTwD3gSxAeLbky4HouE/fHaBG7MUiYZiV2XiDTJowSJFygLlxRtAYHrCQ9uDNBIoRvzIOHGPFLLCYrr2ScT1sexQr4+AeCR55+srX9BNpP7Qi9plutPKXNdhOIpAtfTym6MnM0j4FkCl1vIlac9uTGy1wMgtscIZ+IBoF7P1Orn/CCY8+NEzg8COT/ryY0BamueBfA/lyf8Lkxa+J9XHooF97OEli1MKa4XCjSsP0PyDN3nWU/7pDGf+LC+KLqHXmTdGCHwCwTBXlJ2Y0SwgKY3UoCXCDcGaGDzgmazB4MeexYvKw96QrKXCTdmISDwqrWNvg0vImr7igc35kUC16sFEvhFngTxxaIbE67XImF/vTaBG7OkSUZi1yUiTfIqQeI3lIVLivYGgetND24M0EihG/Mi4ca8UssJiuvZxQnr41ghX98E8Mjzi2vrX5DN5L7QS5rl+lvKXBeheIvA9bayGyNn8wp4lsDlFnLl7Ty5MbnstQjM5TXCmbg4k/seizz04otgzq8TOV+SyX0PZDg4OoZj+eCzQvBZMfh0Dj4rBZ8uwadr8Fk5+KwSfFYNPqsFn9WDzxrBp1vw6S6Ygk/P4LNm8Fkr+KwdfNYJPusGn/WCz/rBp1fw6R18Ngg+GwafjYLPxsFnk+DTJ/j0DT79gk//4DMg+AwMPpsGn82Cz+bBZ4vgMyj4DA4+Q4LP0OCzZfDZKvhsHXy2CT7bBp/tgs/2wWeH4LNj8Nkp+OwcfHYJPrsGn92Cz+7BZ4/gMyz4DA8+I4LPyOCzZ/DZK/iMCj6jg8/ewWdM8Nkn+IwNPvsGn/2Cz/7B54DgMy74jA8+E4LPxOAzKfhMDj5Tgs+Bweeg4HNw8Dkk+EwNPtOCz6HB57Dgc3jwOSL4HBl8jorO4pjgc2zwmR58ZgSfmcHnuOBzfPA5IficGHxOCj4nB59Tgs+s4DM7+JwafE4LPqcHnzOCz5nB56zgc3bwmRN85gafecHnnOBzbvA5L/icH3wuCD4XBp+LMv/JGdFJ4ajoWd2AvETwaRV8WgefNsGnbfBpF3xKgk9p8CkLPuXBpyL4VAafquBTHXxqgo9I0JLBZ6ngs3TwWSb4LBt82gefDsGnY/DpFHyWy9T3hvS58L5FbDJvEQn41wt7HbLE/SPaZWKrzPKzpS0/W8Hys87RzyZ8sNoGU3/4YX78Z12inw1rfeF9/Ra1uy7+s66Wn61u+Vk3y8/WtPxsbcvPekYFHbJw5LT5Y3abHv/Z8dGF9eizC9ue8WjnH+I/OyH62YxVz/3+y3vm/MfPTot+NrrTgqMHrXbOX/GfzY1+9vncf7765IPaXvGfXRj97Le1nvx9dv83/wPLzRYst1iwPBb9bOjY67uvevmPzeM/WxD929oHjNiqx9XD743/7DlL3EJL3KuWuNctcYujn5npHy3V5tVuK8Z/9rblne9Y3vmpJe5zS9wPlrifLXH/WOJMi6bjWrdoOq6dJa7GErekJa6jJS5riVvFEreaJW5NS9w6lriNLXF9LHGbWeIGWeK2s8TtYInb3RI33BK3jyVuX0vcREvcFEvc4Za4Iy1xMy1xJ1jiTrfEnWmJO9cSd4El7kpL3NWWuBstcbdY4u61xN1viXvMEveEJe4FS9yLlrg3LHFvWeI+tsR9aon7xhL3vSXuD0vcX5a4Fi2bjmvVsum4CktclSVuGUtcB0vcSpa4rpa4bpa4npa43pa4DS1x/S1xm1ritrLEbWOJ29kSt5slbpQlbm9L3AGWuAmWuKmWuEMtccdY4mZY4mZZ4k61xM2xxJ1jibvUEne5JW6+Je4GS9ydlri7LXEPWeIetcQ9a4l73hL3iiXudUvc+5a4Dy1xX1jivrbE/WKJ+80SF355bSKu+RJNx5VY4soscbWWuKUtcctb4la0xK1qiVvDEreuJW59S9wmlrh+lrjBlrihlrjtLXE7WeJGWOL2tMSNtcTtb4k70BJ3sCXuCEvc0Za4Ey1xJ1vizrDEnW2Ju9ASd7El7ipL3LWWuFstcbdb4u6zxD1oiXvSEve0JW6RJe5lS9zblrh3LXGfWOI+t8T9YIn7yRL3pyXuH0tc61ZNx7Vt1XRcpSWuxhLX0RK3nCWuiyVuFUvcmpa4tS1xG1jiNrbEbWaJ28ISt7UlbjtL3O6WuGGWuNGWuH0scRMtcZMtcdMscYdb4mZa4o63xM22xJ1uiTvXEne+Je4yS9yVlrgbLXE3W+LussTda4l7zBK3wBL3nCXuBUvcG5a4xZa4DyxxH1vivrHEfWeJ+9US94clrkXrpuOWaN10XKklrsISt4wlrr0lbgVL3EqWuG6WuB6WuPUscb0tcf0tcQMtcUMscVtZ4na2xO1qiRtpiRtliTvAEjfeEneQJW6qJe4YS9x0S9xJlrhZlrg5lrh5lriLLHGXWuLmW+Kut8TdZom70xL3kCXuEUvcU5a4Zy1xr1jiXrPEvWOJe98S94Ul7itL3I+WuF8sceH/UN1EXLM2Tce1scSVWOJqLXFLWeI6WeKWt8Staolb3RK3liVuXUvcJpa4vpa4zS1xgy1x21vidrTE7WGJG2GJG2uJ288SN8kSd6Al7ghL3FGWuOMscSda4s6wxJ1liTvPEnehJe4qS9w1lribLHG3WuLus8Q9YIl73BL3pCVukSXuJUvcm5a4ty1xn1jiPrPEfWuJ+8ES96cl7m9LXMu2Tce1btt0XKUlrtoSt6wlrqMlroslbmVLXHdL3JqWuA0scRtZ4gZY4jazxG1tidvWEreLJW53S9xoS9wYS9w4S9xES9w0S9xhlrhjLXEzLXGzLXGnWeLmWuLOtcRdZom7whJ3nSXuRkvcXZa4eyxxD1viHrPEPWeJW2iJe9US94Yl7gNL3EeWuC8tcd9Y4n61xP1uiTPtmo5r0a7puFJLXLklbklL3DKWuBUscZ0tcatZ4rpZ4tazxPWyxPWxxPW3xA2xxG1pidvBErezJW6kJW4vS9y+lrgDLHEHWeIOscQdaYk7xhJ3kiXuFEvcmZa4OZa4iyxxl1jirrbEzbfE3WaJu8MSd78l7iFL3FOWuGcscS9a4l6xxL1jiXvPEvepJe4LS9yPlrifLXF/WeLC/4P1JuLalDQd184SV2WJq7XEdbLEZS1xXS1xq1ri1rLErWOJ29ASt4klbnNL3CBL3DaWuO0tcXtY4oZb4va2xI21xE2yxE2xxB1qiTvCEnecJe4ES9yplrgzLHHnWeIusMRdbom7yhJ3kyXuFkvc3Za4+yxxj1vinrDEPW+JW2SJe9MS95Yl7kNL3CeWuG8tcd9b4n6zxP1piWtZ2nRcq9Km48oscZWWuGUtcR0scSta4rpY4rpb4npa4ta3xG1giRtgidvUEjfUEre1JW4XS9xulrg9LXGjLXHjLHETLHEHW+KmWeKOtcTNsMSdbImbbYmba4k7xxJ3sSXuMkvcdZa4Gyxxt1vi7rLEPWyJe9QS97Ql7jlL3KuWuNctce9a4j6wxH1pifvaEveTJe5XS5wpazqueVnTcW0tcaWWuCUtcUtb4pazxK1giVvNEreGJW5tS9x6lrg+lrh+lrgtLHFDLHE7WOJ2ssQNs8SNtMTta4nb3xI32RJ3kCXuSEvc0Za44y1xJ1nizrTEnW2JO98Sd5El7mpL3LWWuJstcbdZ4u63xD1oiVtgiXvKEveiJe5lS9xiS9w7lrhPLXGfW+K+s8T9aIn7yxL3jyVuifKm49qUNx1XZYmrscS1t8R1ssR1tcStYonrYYlbyxK3oSVuY0vcQEvc5pa4bSxx21nidrXE7WGJ29sSt48lbrwlbpIl7lBL3OGWuOmWuOMscada4k63xM2zxJ1nibvcEnelJe56S9xNlri7LXH3WuIescQ9bol73hL3giXuNUvcm5a4Dy1xH1vivrLEfWuJ+80S94clrllF03EtK5qOK7PEVVjilrLELWuJW9ESt5IlbnVLXHdL3PqWuN6WuL6WuAGWuKGWuK0scTta4naxxO1piRtlidvPEjfOEnewJW6qJe4oS9yxlriTLXGzLHFnWeLmWuIutsRdaom7xhJ3nSXudkvcnZa4ByxxD1vinrbEPWuJe8kS96ol7l1L3PuWuM8scV9a4n6yxP1iifvbEmcqm45rW9l0XIklrtoSt6QlbjlL3PKWuJUtcatZ4ta2xK1ridvIEtfHEreFJW6wJW5bS9wOlrhhlrgRlrgxlrh9LXGTLXEHWuIOs8QdaYk73hJ3oiXuNEvcmZa48y1xF1rirrDEXW2Ju9kSd6sl7h5L3P2WuAWWuCctcQstcS9a4hZb4t62xH1kifvUEvedJe4HS9zvlri/LHFLVDUd17qq6bhyS1yVJa69Ja6jJa6zJa6rJa6HJW5NS1wvS9yGlriBlrjNLHFbWuK2scTtaonb3RK3lyVub0vceEvcREvcIZa4Qy1x0y1xMy1xp1jiTrXEzbPEnWuJu8QSd7kl7npL3I2WuDsscXdb4h6xxD1miXvGEve8Je41S9wblrj3LHEfWuK+ssR9Y4n72RL3myWuWXXTcS2qm45rZ4krs8QtZYlbxhKXtcStaIlb3RLXzRK3jiVufUtcX0tcf0vcIEvcUEvcjpa4nS1xwy1xe1ri9rPEHWCJm2KJO9gSd5Ql7hhL3AmWuJMtcWdZ4uZY4i6wxF1sibvGEjffEneLJe52S9wDlriHLHFPWOKetsS9ZIl7xRL3liXuXUvcZ5a4Lyxx31vifrLE/W2JC39xchNxrWqajmtriau2xNVa4jpY4pazxK1siVvVEtfTEre2JW4jS9wmlrhNLXFbWOK2tcRtb4nbzRI3zBI3xhI31hI3wRI32RJ3mCXuCEvcDEvc8Za40yxxZ1jizrHEnW+Ju8ISd5Ul7gZL3M2WuHsscfdZ4h61xC2wxC20xC2yxL1uiVtsifvIEveJJe5rS9x3lrjfLXF/WuKa1zYdt0Rt03HllrhKS9zSlrj2lrjOlrgulrg1LHE9LHG9LHEbWOL6WeIGWuK2tMRtbYnbyRK3qyVuL0vcaEvc/pa48Za4Qyxx0yxxR1viplviTrHEzbbEnW2Jm2eJu8QSd5kl7lpL3PWWuDsscXdZ4h60xD1iiXvGEvecJe5lS9xrlrj3LHEfWOI+t8R9ZYn72RL3qyXuH0tcsyWbjmu3ZNNxpZa4GkvcUpa4rCVuBUvcKpa41S1x61ji1rPEbWyJ62uJG2SJG2KJ284St6MlbrglbqQlbh9L3H6WuCmWuIMscYdb4o6yxJ1giTvJEne6Je4sS9wFlriLLHFXWuKuscTdYom7zRJ3ryXuAUvcE5a4pyxxL1jiXrLEvWWJe8cS97El7jNL3PeWuB8tcX9Y4v62xLVaqum4Nks1HVdhiau2xHWwxHWyxK1kiVvZEtfTEreWJa63JW4jS9ymlrjNLXFbWeK2tcTtZonbwxI3yhI3xhI3wRI3yRI31RJ3mCVuhiXuOEvcLEvcaZa4cyxx51niLrXEXWGJu8ESd5Ml7k5L3D2WuEctcY9b4p61xC20xL1uiXvTEve+Je4jS9zXlrhvLXG/WOJ+t8Q1X7rpuJZLNx1XYokrt8QtbYlb1hK3vCWusyVuDUtcd0vcupa4Xpa4fpa4AZa4wZa4LS1xO1nidrHEjbDE7dVEXPTrzTLR/9tIZtTovcYfMGH85NHD9xk7bkqn6G+jXz75P//VQvkP8cnrs5mclmkdi8Pjj9qsdcMXQvGZML7uv/ZIxJvWsRgivu4/zBH+Fz8zTWCRVRL9u4nF1sXIL1Aui/1zeSxG1sDY+0yDn23ayL4JcxpYF9+Ci29Wlfnf+9e9S35plOQYkTZ8puGzcS61jD3TWF0zjfydaeQ9DWsTP4ds9Gd1z8yry72zztTVllx3/FYHTX9n++uOqLl0lU/Kl/76wA0P+m3x+Ia5NLNgL7FgKGkkn3h96nqCq/8hm9XtWYerZeZ/1yv+/hYNnu8Y/dkmtn8cZzZjX2889tMrtw5a84DKBvGy6nKO57n/lH81afno3/9/0SSy/5ol7L9GNamxXrRpUkOOyqrTIZdexTWp7t0JdXrThDU1VZmmNaROk9rHAzL1dWqZabqXWzR4dslYTHUT71si49aG5k3gWCb659aNvENWNpPTMo3tYxrZpzEdi9et0FqVjf7U1qo6TRw77qDRk4IZavyk4dNGTxo//MBxe40fN3nKpJFjx40etXz0UHGoStSs/yNg8cEn16EqLlKlsX+uiMXI+m8Tqboz7R8LyGZyW3WxA/BY05Q4xhu24RnUYWzR4NmlYjE1TbyveQOsjQ1VzZrAsUwTz8UxucStsQHl/3dx+59BbPSY0eNGTRo9OPphUceKOkbEp1rHNomJAqtjGzSrj6nTsbozbJH5z/c39mcm85+1rVt10MobeVddznVn07JBfDaT26qLX4KL/5/BsVX8Lxu8O973AG/+yaVO8fe3aYAF5alp8L66/Rrm13A4b9MIlvJGfhY/o/jP4vu0aWSf4ruK7yq+q/iu4ruK7yq+67/7XUsU3/X/xbv+L/Cr2EPFcyzqRLEf/1vfVeRXkav/F7lanCeK9SrmWKz9f+u7ilwtcuL/Yr2K/Cqe4//FdxV7qMiJ/4u1L+pqsYeK9Sq+y/Wu4nerYo5FjS5y9b/1XUV+FXEV31XsR585Ft9V1JziPVTMsZhjUXOK9SqeY5Ff/73vKnodxRyLmlPUieK7irwv9lCx9sUeKr4rzVwtzhNFThRrX6y9z3cV76FivYo9VHyX611p50Rjv89M3pXN5LYS/s6xv1s3gg2I/6suvi0X3+gv4q2rhfyZbVb/9w1/1ryR2PjvrIw/36VZfdyK0T+Xxd5bF9/wl0M3y/zn/nXv2KjBO1o28o66f28X/XOzRp5tyPWGPGjsbOLP1/0exCWaqEebBvWoe371CL/8nreBzRp/Z7zGcVytm3hn99g7N2/wzrrf4ZiJvbOx3zFX93xZI8+Xxp6pw1PWAEM8tjHsJZn/XPG/a+x8TINn4xhkDWgEU1P/XtLIe5rC0K6R99TpSIsm3tlwz8b4UNenufad63fJbtTguXgv1cWk4XfJDojAxHup7s98/i5Z9v3t7x29cJPFny/Wev+Hrbce2Oy2k5dzvb+ubpMnTpoyI/pBgX8P7uYJfw/u5mn5PbibxuIbYpHV2O/BrYtp+HtwK2MxsjaLva8uPmHem6X09+Aa2+/BXXXDNt9efuIRMzLvXvnFrJ9XvbfPGpWd+lZ2e+ncV9qPm7TbMt/WxQ5sgCmbyWl1qPs9ulMb6F5ci0wTf2Yy/1nLutVwToy/q64+jf1HMTIZnMMtufj/yXOJ+EsbYCN/D23Ov/e27v1tGmBBeWkavK9uv4b51Z1LXe6tG8FS3sjP4mcU/1l8n9aN7FN8V/J3tUzpu4o5/v9Rr/8LuIrv+v+jH4s6UXxXkatFvfeJq3iOxRyL/CreHf+tuIqcKNaryK/iORbfVeyhIif+b9a+qKvFHirWq/gu17uK362KORY1usjV/9Z3FflVxFV8V7EffeZYfFdRc4r3UDHHYo5FzSnWq3iORX79976r6HUUcyxqTlEniu8q8r7YQ8XaF3uo+K40c7U4TxQ5Uax9sfY+31W8h4r1KvZQ8V2udxU5UXxX8V3FdxXfVXxX8V3Fd/3//q7Wjbxb3pXN5Lbq4snfOfY/v/e2NRf/P7/3lvy9uaax3y9bVwv5s1Oz+r+XT9vYz5o3EltXhxYNnh/VrD5u+eif635nasPfxSkrn7/Pru7vl4j9fcN9G/6u3FYNnm34O5fjGJfIA8byRvZp1eC9rS34TYP3NG8krrHf65gUr2kEb0mm8Zo29meu+8TfNSD6M2HvtXdxf+0G3I//LBfu1z3fK8b99Rpw3zTALqtt5n9rXPznA2N/F98/3m8m8781saFOyKfu9/vGf29z/JnWDXKqe37jaGPJ+cjon0sy/1tL694lf9enQT1bx37WvJHYtg32rnt+WKye/RvUs7F6lWX+d20a9kC7GJb4s7L6ZxqvweAYjs2bNb1XHXdLLDnK3w1too5xDPHnGr6jThcau+ca04W6uFx+d3hD7Wlp2aNFI3GN7dFQj+M1axfbv44bJY6ft2skt0wjf9eskedbN5FvppG92zre27KR9zSm720b/Mw08rOG2hPPN977dX2Wq6Y11i8m8595Nfx98a0teZlG4hr2eRx7Swv2xuoX14/Geqy5A3v82Ya1dWlmQ41t7HfdN2sEc8PfS79vI5rZ8J1xLYzjatXEOw+IvfOYBu9s7HfdN/Z7Zeued/2u+4Z6Yftd93Hsufyue5s2N/xd9/0bwdTUv7O/675hbzZv4p0N90R7M67/dbN2nD+Z2P7ZTC7rkM1NDEvdu5s38mRTv6P+iAhH8XfU299f9/ORo0YNP3DcXuPHTZ4yaeTYcaNHdY9+0LpBEHaQiX9h/ZDWDV8IxWeGJPxy3KIunvwF2Y3+wvrGBgjbL6xv7D8csVmDn8WbY/MGP4sPQltEf8Z/8b38c20sRtagGEbT4GeDYz+rw9Q6879FBqjToNYNsILxzaoy/3v/FjFssvrHArKZXN56+p91sQPw2F/rYgeisQH8ul+Ov0r8LzP13KkT/IbCEH+24XDasIdlNfwCGsfYY9SWk97redEqd2498Pajj955j5XX+nTzqXdNOK3/ez+d8c1fB7Sse1fDwTr+ZbbhRdjw3xsbUpr698bOtuHPGqtLsyYwNDbsLtEEhro/BzTynsb+XVZjX3Ib4jc5PNvw321462rf2CXeFN66Z/o3skdTGJrn8F7TCIam6ts80zSfG/sP4tTlmYf/IM6QpMNGt+hP7WFj2eifR42dNHqvKWMPGj187Lgpo8eMnjR84oHjp4wdPW5KXSVax6Lq3oioaV18Oy7+P0450wBL/L3/s2H0Z4tG4kwT/96wM23PNvz7+N+VNPKzundWRX/G8dblURH9GT+Ng0ZPmlLHgroa1sb2YyanGi6+0TOojf1z3XsbTngZYI+6Fe+chqvh2cZvnvifBt/fNIWjsfOuO8ua2N/VNvhZ/VlOGT980shRYw+pbIAyyf/IIov9D63UxZNGcfPG2BC/8+vyaqyCpsGedVjI/8GmrWlk/+YN3tkQQ/yZxlSiWYN/b9Hg75vn8GxjrKn7WXkj+BrGNfyPWDb8u/is33A1rHtDY7nhu+JmSvz5Vg3+nT2jqkb2rMP2/wCIufmGjFoVAA==","debug_symbols":"tb3bjivZcbX7Ln2ti5xxmAe/yg9DkG3ZECBIhiz/wIagd9+VOWd8Y6m1i13NtfZNV/RiVSQ/FkcycjA46m8//cfv/+1//+u3f/jTf/75f376l//zt5/+7S9/+OMf//Bfv/3jn//9d3/9w5//9PGvf/vpuv/T+k//0u03P7Vxvs6Pr/7xdX18jd/8ZNf99e8f/1DfnfPcen38qz3/+vGzbezvbfPjX73+NU6H6B9f2/lq5+vHd8VHL4vzNc/Xfr6O83Wer2t/9et8beerna+nn59+fvr56eenn59+fvrF6RenX5x+cfrF6RenX5x+cfrF6RenX55+efrl6ZenX55+efrl6ZenX55+efr106+ffv3066dfP/366ddPv3769dOvn37j9Bun3zj9xuk3Tr9x+o3Tb5x+4/Qbp988/ebpN0+/efrN02+efvP0m6ffPP3m6bdOv3X6rdNvnX7r9Fun3zr91um3Tr91+rXrqqJVYVV4FVFFVtGrGFXMKqpzq86tOrfq3Kpzq86tOrfq3Kpzq86tOlt1tups1bl000o4rZTTSjqttNNKPK3U00o+rfTTSkCtFNRKQq001EpErVTUSkatdNRKSK2U1EpKrbTUSkyt1NRKTq301EpQrRTVSlKtNNVKVK1U1UpWrXTVSlitlNVKWq201UpcrdTVSl6t9NVKYK0U1kpirTTWSmStVNZKZq101kporZTWSmqttNZKbK3U1kpurfTWSnCtFNdKcq0010p0rVTXSnatdNdKeK2U10p6rbTXSnyt1NdKfq3010qArRTYSoKtNGilQSsNWmnQSoNWGrTSoJUGrTRopUErDVpp0EqDVhq00qCVBq00aKVBKw1aadBKg1YatNKglQaN1y5evHj14uWL1y9ewEqDVhq00qCVBq00aKVBKw1aadBKg1YatNKglQatNGilQQteb6tzadBKg1YatNKglQatNGilQSsNWmnQkpfy6lwatNKglQatNGilQSsNWmnQSoNWGrTOlFCdS4NWGrTSoJUGrTRopUErDVpp0EqDNhhAqnNp0EqDVhq00qCVBq00aKVBKw1aadAms011Lg1aadBKg1YatNKglQatNGilQSsN2mJsYm6qwak06KVBLw16adBLg14a9NKglwa9NOiNkaw6lwa9NOilQS8NemnQS4NeGvTSoJcG3Zj2qnNp0EuDXhr00qCX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770+bI5fYmfv9SkbU5Dz2T5z/BJz/BLbe68nSxY2xy+xvff6sDl+ie29182GX2J773Wz4ZfY3nvdmMYUtPdeN6YxBe29141pYsMvsbP3ukumIHexudjwS2zvvZ6AXLHhl9jee91s+CW29143G36J7b3XzYZfYnvvdWMGU9Dee92YwRS09143ZogNv8TO3usumYI8xZZiwy+xvfd6Un/Fhl9ie+91s+GX2N573Wz4Jbb3XjcbfontvdeN2ZmC9t7rxuxMQXvvdWMOseGX2Nl73SVTkA+xDbHhl9jeez1RxmLDL7G997rZ8Ets771uNvwS23uvmw2/xPbe68acTEF773VjTqagvfe6MZfY8Evs7L3ukinIl9iW2PBLbO+9nnxm2EJ+yd57fdhCfsnee33YQn7J3nt92EJ+yd57zf1jTEF77/XB3HuvD+bee30w997rwxbyS87e6y6ZgoLP9lnILwn5JXvv9WRNi01+yd573WzyS/be62aTX7L3Xjeb/JK997oxjSlo771uTGcK2nuvG9PFJr/k7L3ukikoXGzyS0J+yd57PQHaYpNfsvdeN5v8kr33utnkl+y9180mv2TvvW7MZArae68bM5mC9t7rxkyxyS85e6+7ZAqKFJv8kpBfsvdeTyq42OSX7L3XzSa/ZO+9bjb5JXvvdbPJL9l7rxtzMAXtvdeNOZiC9t7rxhxik19y9l53yRQUQ2zyS0J+yd57PVHnYpNfsvdeN5v8kr33utnkl+y9180mv2TvvW7MxRS091435mIK2nuvG3OJTX7J2XvdJVNQ8tk+S/klKb9k772e/HbYUn7J3nt92FJ+yd57fdhSfsnee33YUn7J3nt9MPfe64O59177/jGmoL33+mDuvdeHLeWXnL3XpzSmoDSxyS9J+SV773Vjmtjkl+y9180mv2TvvW42+SV773WzyS/Ze68b05mC9t7rxnSmoL33ujFdbPJLzt7rLpmCMsQmvyTll+y9140ZYpNfsvdeN5v8kr33utnkl+y9180mv2TvvW7MZArae68bM5mC9t7rxkyxyS85e6+7ZArKLjb5JSm/ZO+9bswuNvkle+91s8kv2Xuvm01+yd573WzyS/be68YcTEF773VjDqagvfe6MafY5JecvdddMgXlFJv8kpRfsvdeN+YUm/ySvfe62eSX7L3XzSa/ZO+9bjb5JXvvdWMu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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a vector.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_vector();\n    /// assert_eq(vector, &[1, 2]);\n    /// ```\n    #[builtin(as_vector)]\n    pub fn as_vector(self) -> [T] {}\n\n    /// Returns this array as a vector.\n    /// This method is deprecated in favor of `as_vector`.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_slice();\n    /// assert_eq(vector, &[1, 2]);\n    /// ```\n    #[builtin(as_vector)]\n    #[deprecated(\"This method has been renamed to `as_vector`\")]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\nfn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use babyjubjub::BabyJubJubPoint;\nuse ecrecover::ecrecover;\nuse oprf::blinded_query::blinded_query;\n\n/// This directory contains an implementation of the proof flow for the blinded query for the OPRF-based service,\n/// using a Noir implementation of [ECRecover](https://github.com/colinnielsen/ecrecover-noir)\n/// which derives an address from the public key and verifies the given signature.\n/// The general idea is that only a client who controls the private key corresponding to the public key\n/// can produce a valid signature for the fixed message, and thus only such a client can derive the correct proof for their address.\n///\n/// 1. **Client message signing (wallet)**\n///    - The client signs a fixed message with their wallet.\n///    - The hashed message is provided to the circuit as a **public input**.\n///\n/// 2. **In-circuit verification**\n///    - The client provides the following as **private inputs**:\n///      - public key\n///      - signature\n///      - random field element `beta` (blinding factor)\n///    - The circuit verifies the signature against the public key and recovers/derives\n///      the wallet address.\n///\n/// 3. **Encode, blind, and query OPRF**\n///    - The recovered address is **encoded to the curve** (BabyJubJub here).\n///    - The encoded point is **blinded** using `beta` to get `b_q`.\n///    - The blinded point is sent to the OPRF nodes as the client's query input.\n///\nfn main(\n    hashed_message: pub [u8; 32],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64],\n    beta: Field,\n) -> pub BabyJubJubPoint {\n    // The function ecrecover takes in a hashed message, a public key (x and y coordinates) and a signature, verifies the signature and returns the recovered ETH address, which is used as the input to the OPRF protocol.\n    let address = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n\n    // Generate the query proof point.\n    blinded_query(beta, address)\n}\n\n#[test]\nfn test_main() {\n    let signature = [\n        34, 94, 125, 19, 113, 129, 1, 254, 222, 37, 77, 59, 21, 235, 106, 193, 166, 124, 104, 4,\n        118, 162, 234, 211, 115, 66, 94, 150, 59, 199, 57, 183, 59, 250, 14, 152, 118, 130, 19, 3,\n        212, 55, 92, 127, 128, 188, 84, 190, 85, 212, 225, 151, 89, 155, 47, 162, 87, 134, 208, 226,\n        7, 161, 5, 168,\n    ];\n    let beta = 1498760273557913456370459222027449040163634869948415528344868600761947487523;\n    let hashed_message = [\n        218, 239, 222, 213, 190, 193, 112, 62, 182, 226, 19, 202, 51, 169, 222, 157, 155, 222, 83,\n        32, 18, 31, 187, 249, 49, 128, 244, 131, 204, 206, 107, 226,\n    ];\n    let pub_key_x = [\n        158, 30, 136, 123, 120, 204, 6, 226, 64, 216, 96, 95, 238, 120, 20, 91, 44, 2, 181, 15, 171,\n        210, 100, 74, 243, 208, 255, 91, 222, 248, 18, 190,\n    ];\n    let pub_key_y = [\n        151, 145, 124, 206, 255, 36, 241, 99, 254, 200, 250, 151, 236, 57, 81, 36, 165, 7, 139, 205,\n        215, 77, 194, 49, 9, 177, 21, 157, 90, 29, 26, 7,\n    ];\n\n    let expected_query_request = BabyJubJubPoint::new(\n        20769343801606875644580992560767002733477266146250829360177308891153456763932,\n        717924508062895681512301498190527672768108096190869247123342479357366276555,\n    );\n\n    let result = main(hashed_message, pub_key_x, pub_key_y, signature, beta);\n    assert(\n        (result.x == expected_query_request.x) & (result.y == expected_query_request.y),\n        \"Query request point does not match expected value\",\n    );\n}\n","path":"/home/gruber/Work/oprf-testnet/noir/blinded_query_proof/src/main.nr"},"53":{"source":"// Hash to Curve for BabyJubJub\n// Implements the Elligator2 method from RFC 9380\n// https://www.rfc-editor.org/rfc/rfc9380.html\n\nuse super::BabyJubJubPoint;\nuse poseidon2::bn254::perm;\n\ncomptime global Z: Field = 5;\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\nfn hash_to_field(input: Field) -> Field {\n    // element 0 is the DS string \"OPRF_HashToField_BabyJubJub\"\n    let hash_input = [32627786498498119128812045057993354633158048678109587794777765218, input, 0];\n    let hash_result = perm::x5_3(hash_input);\n\n    hash_result[1]\n}\n\nfn is_zero(x: Field) -> bool {\n    x == 0\n}\n\nunconstrained fn inverse_or_zero_unconstrained(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n\nfn inverse_or_zero(x: Field) -> Field {\n    // SAFETY: We constrain the inverse below\n    let inv = unsafe { inverse_or_zero_unconstrained(x) };\n    let is_zero = 1 - x * inv;\n    // Constraint strategy:\n    // if x != 0\n    //  then is_zero must be 0 due to constraint 1 => x * inv = 1, therefore inv is the inverse of x\n    // if x == 0\n    //  then is_zero must be 1 due to the definition above, since x = 0. inv could be anything, but we enforce inv = 0 in constraints 2 below\n\n    // These are the two constraints enforcing above logic:\n    // One of x or is_zero must be zero\n    assert(x * is_zero == 0, \"InverseOrZero zero constraint 1 failed\");\n    // One of inv or is_zero must be zero\n    assert(inv * is_zero == 0, \"InverseOrZero zero constraint 2 failed\");\n    inv\n}\n\nfn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\nunconstrained fn legendre(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        pow(x, (0 - 1) / 2)\n    }\n}\n\nunconstrained fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// Check if a field element is a quadratic residue or zero\nfn is_quadratic_residue_or_zero(x: Field) -> bool {\n    // SAFETY:\n    // Constraint strategy, from (<https://eprint.iacr.org/2021/984.pdf>, page 4):\n    // Let l = Legendre(a) in { -1, 0, 1 }.\n    // Introduce a witness b intended to be a square root:\n    // Enforce: l(l-1)(b^2 - n*a) + (l+1)(b^2 - a) == 0\n    // For l =  1: (l(l-1)) = 0 and (l+1) = 2 => b^2 = a\n    // For l = -1: (l(l-1)) = 2 and (l+1) = 0 => b^2 = n*a\n    // For l =  0: (l(l-1)) = 0 and (l+1) = 1 => b^2 = a (which forces a to be 0 or a quadratic residue)\n    // Note that the above checks from the paper would also allow for a=0,b=0, but l=-1.\n    // Therefore we add another constraint enforcing a=0 => l=0, see below.\n    let l = unsafe { legendre(x) };\n    assert(l * (l - 1) * (l + 1) == 0, \"l must be in {-1,0,1}\"); // l in {-1,0,1}\n\n    // n is the smallest non-quadratic residue in BN254\n    let n = 5;\n    let na = n * x;\n    let sqrt_in = if (l == -1) { na } else { x };\n    // SAFETY: We constrain b to be the square root of either na or a, depending on the value of l.\n    let b = unsafe { sqrt(sqrt_in) };\n\n    let s_na = l * (l - 1); // 0 when l in {0,1}, 2 when l = -1\n    let s_a = l + 1; // 0 when l = -1, 1 when l = 0, 2 when l = 1\n\n    let b2 = b * b;\n    let c_na = b2 - na;\n    let c_a = b2 - x;\n    assert(s_na * c_na + s_a * c_a == 0, \"b must be a square root of na or a\");\n\n    // Constraint a=0 => l=0\n    // at least one of l and (isZero(a)) need to be 0\n    // This disallows the case of l!=0 and a==0, the case l==0 and a==0 is as expected, same with l!=0 and a!=0.\n    // There is still the case of l==0 and a!=0 which would be allowed by this and would give an invalid legendre symbol for a.\n    // However we enforce in that case (l = 0) that a = b^2, which still produces the correct high-level output for this gadget, since l in {0,1} and we do not directly return l.\n    assert((x == 0) as Field * l == 0);\n    l != -1\n}\n\nfn sgn0(x: Field) -> bool {\n    x.sgn0() == 1\n}\n\n// Map to Montgomery curve using Elligator2\n// https://www.rfc-editor.org/rfc/rfc9380.html#name-elligator-2-method\n// Montgomery curve: K * t^2 = s^3 + J * s^2 + s\n// For BabyJubJub: K=1, J=168698, so curve is: t^2 = s^3 + 168698*s^2 + s\npub fn map_to_curve_elligator2(input: Field) -> (Field, Field) {\n    let k = 1;\n    let c1 = 168698;\n    let c2 = 1;\n\n    let u = input;\n\n    let tv1_0 = Z * u * u;\n    let e = is_zero(tv1_0 + 1);\n\n    let tv1 = if e { 0 } else { tv1_0 };\n\n    let tv1_plus_1 = tv1 + 1;\n    let x1_inv = inverse_or_zero(tv1_plus_1);\n    let x1 = -c1 * x1_inv;\n\n    let gx1_0 = (x1 + c1) * x1;\n    let gx1 = (gx1_0 + c2) * x1;\n\n    let x2 = -x1 - c1;\n    let gx2 = tv1 * gx1;\n\n    // Step 6-7: If is_square(gx1), use x1 and sqrt(gx1), else use x2 and sqrt(gx2)\n    let gx1_is_square = is_quadratic_residue_or_zero(gx1);\n\n    let x = if gx1_is_square { x1 } else { x2 };\n    let gx = if gx1_is_square { gx1 } else { gx2 };\n\n    // Compute y = sqrt(gx)\n    // Safety: sqrt is unconstrained but verified by y^2 = gx constraint below\n    let mut y = unsafe { sqrt(gx) };\n    assert(y * y == gx, \"y must be a square root of gx\");\n\n    // Adjust sign of y according to spec:\n    // If gx1 is square: sgn0(y) == 1\n    // Else: sgn0(y) == 0\n    let y_sgn = sgn0(y);\n    let should_negate = if gx1_is_square {\n        !y_sgn // Want sgn0(y) == 1, so negate if currently 0\n    } else {\n        y_sgn // Want sgn0(y) == 0, so negate if currently 1\n    };\n\n    if should_negate {\n        y = -y;\n    }\n\n    // Step 8-9: s = x * K, k = y * k\n    let s = x * k;\n    let t = y * k;\n\n    // Step 10: return (s, t)\n    (s, t)\n}\n\nfn rational_map_mont_to_twisted_edwards(s: Field, t: Field) -> (Field, Field) {\n    // tv1 = s + 1\n    let tv1 = s + 1;\n\n    // tv2 = InverseOrZero(tv1 * t)\n    let tv2 = inverse_or_zero(tv1 * t);\n\n    // v = tv1 * tv2\n    let v = tv1 * tv2;\n\n    // w = tv2 * t\n    let w = tv2 * t;\n\n    // tv11 = s - 1\n    let tv11 = s - 1;\n\n    // e = IsZero(tv2)\n    let e = is_zero(tv2);\n\n    // out[0] = s * v\n    let out_x = s * v;\n\n    // out[1] = if e then 1 else w * tv11\n    let out_y = if e { 1 } else { w * tv11 };\n\n    (out_x, out_y)\n}\n\n// Map to Twisted Edwards curve\nfn map_to_curve_twisted_edwards(input: Field) -> (Field, Field) {\n    let (mont_s, mont_t) = map_to_curve_elligator2(input);\n    rational_map_mont_to_twisted_edwards(mont_s, mont_t)\n}\n\nfn clear_cofactor_baby_jubjub(x: Field, y: Field) -> (Field, Field) {\n    let point = BabyJubJubPoint::new(x, y);\n    let result = point.multiply_by_cofactor();\n\n    (result.x, result.y)\n}\n\n// Main encode to curve function\npub fn encode(input: Field) -> (Field, Field) {\n    // u = HashToField(input)\n    let u = hash_to_field(input);\n\n    // q = MapToCurveTwistedEdwards(u)\n    let (q_x, q_y) = map_to_curve_twisted_edwards(u);\n\n    // Clear cofactor (multiply by 8)\n    let (out_x, out_y) = clear_cofactor_baby_jubjub(q_x, q_y);\n\n    (out_x, out_y)\n}\n\n#[test]\nfn test_encode_to_curve_kat0() {\n    let input = 0x03e4070110668921a99c37627dedddb5ab65fae33c19e24d9ee19d7065fdeca8;\n    let (x, y) = encode(input);\n\n    assert(\n        x == 10317659717708787122683977912952208883341451354299498236440964928299898571531,\n        \"encode x mismatch for test vector\",\n    );\n    assert(\n        y == 2771878628977713302835201233169750856073682825638128695522023521672351725258,\n        \"encode y mismatch for test vector\",\n    );\n}\n\n#[test]\nfn test_encode_to_curve_kat1() {\n    let input = 0x42;\n    let (x, y) = encode(input);\n    assert(\n        x == 16453178030699411958341692808730701741568100876455568813278163225032347056514,\n        \"encode x mismatch for test vector\",\n    );\n    assert(\n        y == 5447922750205248208490261749483809853022174346498064122782172531486866662376,\n        \"encode y mismatch for test vector\",\n    );\n}\n\n#[test]\nfn test_encode_to_curve_kat2() {\n    let input = 0;\n    let (x, y) = encode(input);\n    assert(\n        x == 16605852874433019712683889710166313607515083375138125349412270828059484170936,\n        \"encode x mismatch for test vector\",\n    );\n    assert(\n        y == 12075050546928691602283582412953179086742727007172364313655633055645374686589,\n        \"encode y mismatch for test vector\",\n    );\n}\n","path":"/home/gruber/nargo/github.com/TaceoLabs/oprf-nr/main/babyjubjub/src/hash_to_curve.nr"},"54":{"source":"// BabyJubJub Curve Implementation for Noir\n// Based on EIP-2494 and Circom implementation\n// Curve equation: a*x^2 + y^2 = 1 + d*x^2*y^2\n// where a = 168700, d = 168696\n\nuse escalar_mul_fix::generator_mul_fix;\nuse std::{field::bn254, static_assert};\n\nmod tests;\npub mod hash_to_curve;\npub(crate) mod montgomery;\npub(crate) mod window_table;\npub(crate) mod escalar_mul_fix;\n\n// BabyJubJub curve constants\nglobal BABYJUBJUB_A: Field = 168700;\nglobal BABYJUBJUB_D: Field = 168696;\n\n// Identity point (0, 1)\nglobal BABYJUBJUB_IDENTITY_X: Field = 0;\nglobal BABYJUBJUB_IDENTITY_Y: Field = 1;\n\nglobal BABYJUBJUB_GENERATOR_X: Field =\n    5299619240641551281634865583518297030282874472190772894086521144482721001553;\nglobal BABYJUBJUB_GENERATOR_Y: Field =\n    16950150798460657717958625567821834550301663161624707787222815936182638968203;\n\n// Scalar field order (Fr) - prime order of BabyJubJub's scalar field\nglobal BABYJUBJUB_Fr: Field =\n    2736030358979909402780800718157159386076813972158567259200215660948447373041;\n\nglobal BABYJUBJUB_CHARACTERISTIC: [u1; 251] = [\n    1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0,\n    0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0,\n    0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0,\n    0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1,\n    1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,\n    0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0,\n    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0,\n    0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1,\n];\n\n/// Represents a point on the BabyJubJub curve\npub struct BabyJubJubPoint {\n    pub x: Field,\n    pub y: Field,\n}\n\nimpl BabyJubJubPoint {\n    /// Creates a new BabyJubJub point\n    pub fn new(x: Field, y: Field) -> Self {\n        BabyJubJubPoint { x, y }\n    }\n\n    /// Creates the identity point\n    pub fn identity() -> Self {\n        BabyJubJubPoint { x: BABYJUBJUB_IDENTITY_X, y: BABYJUBJUB_IDENTITY_Y }\n    }\n\n    /// Creates the generator point\n    pub fn generator() -> Self {\n        BabyJubJubPoint { x: BABYJUBJUB_GENERATOR_X, y: BABYJUBJUB_GENERATOR_Y }\n    }\n\n    /// Checks if the point is on the BabyJubJub curve\n    /// Curve equation: a*x^2 + y^2 = 1 + d*x^2*y^2\n    pub fn is_on_curve(self) -> bool {\n        let lhs = BABYJUBJUB_A * self.x * self.x + self.y * self.y;\n        let rhs = 1 + BABYJUBJUB_D * self.x * self.x * self.y * self.y;\n        lhs == rhs\n    }\n\n    /// Checks if the point is the identity element\n    pub fn is_identity(self) -> bool {\n        let x_eq = self.x == BABYJUBJUB_IDENTITY_X;\n        let y_eq = self.y == BABYJUBJUB_IDENTITY_Y;\n        x_eq & y_eq\n    }\n\n    /// Checks if the point is not the identity element\n    pub fn is_not_identity(self) -> bool {\n        !self.is_identity()\n    }\n\n    /// Multiplies the point by the cofactor (8 for BabyJubJub over BN254)\n    pub fn multiply_by_cofactor(self) -> Self {\n        self.double().double().double()\n    }\n\n    unconstrained fn add_unconstrained(self, other: BabyJubJubPoint) -> (Field, Field) {\n        let beta = self.x * other.y;\n        let gamma = self.y * other.x;\n        let delta = (-BABYJUBJUB_A * self.x + self.y) * (other.x + other.y);\n        let tau = beta * gamma;\n\n        let denominator1 = 1 + BABYJUBJUB_D * tau;\n        let denominator2 = 1 - BABYJUBJUB_D * tau;\n\n        let x = (beta + gamma) / denominator1;\n        let y = (delta + BABYJUBJUB_A * beta - gamma) / denominator2;\n        (x, y)\n    }\n\n    /// Point addition on BabyJubJub (twisted Edwards).\n    /// Precondition: both points must lie on the BabyJubJub curve.\n    pub fn add(self, other: BabyJubJubPoint) -> Self {\n        let beta = self.x * other.y;\n        let gamma = self.y * other.x;\n        let delta = (-BABYJUBJUB_A * self.x + self.y) * (other.x + other.y);\n        let tau = beta * gamma;\n\n        let den_x = 1 + BABYJUBJUB_D * tau;\n        let den_y = 1 - BABYJUBJUB_D * tau;\n\n        // Safety: Points lie on the BabyJubJub curve and its TE addition formula is complete.\n        let (x, y) = unsafe { Self::add_unconstrained(self, other) };\n        assert(\n            y * den_y == delta + BABYJUBJUB_A * beta - gamma,\n            \"Edwards add y-coordinate constraint failed\",\n        );\n        assert(x * den_x == beta + gamma, \"Edwards add x-coordinate constraint failed\");\n\n        BabyJubJubPoint { x, y }\n    }\n\n    /// Point negation\n    pub fn negate(self) -> Self {\n        BabyJubJubPoint { x: -self.x, y: self.y }\n    }\n\n    /// Point subtraction: self - other = self + (-other)\n    pub fn subtract(self, other: BabyJubJubPoint) -> Self {\n        self.add(other.negate())\n    }\n\n    /// Point doubling\n    /// Precondition: the point must lie on the BabyJubJub curve.\n    pub fn double(self) -> Self {\n        self.add(self)\n    }\n\n    pub fn scalar_mul(self, scalar: Field) -> Self {\n        // Early termination for zero scalar\n        if scalar == 0 {\n            BabyJubJubPoint::identity()\n        } else {\n            // Decompose scalar into 251 bits (BabyJubJub scalar field size)\n            let bits: [u1; 251] = scalar.to_le_bits();\n            self.scalar_mul_bits(bits)\n        }\n    }\n\n    /// Scalar multiplication with bit array (little-endian)\n    ///\n    /// This is equivalent to ec library's bit_mul but with explicit bit input.\n    /// Useful when you already have the scalar decomposed to bits.\n    ///\n    /// # Arguments\n    /// * `bits` - Scalar in bit representation (little-endian)\n    ///\n    /// For Variable-base: use double-and-add (~N doubles, ~N/2 adds).\n    /// Window-w needs a per-point table (2^w) and a select each window\n    /// so windowing is reserved for fixed-base (generator) where the table is precomputed.\n    pub fn scalar_mul_bits<let N: u32>(self, bits: [u1; N]) -> Self {\n        assert(self.is_on_curve(), \"Point must be on curve\");\n\n        let mut result = BabyJubJubPoint::identity();\n\n        for i in 0..N {\n            result = result.double();\n\n            if bits[N - 1 - i] == 1 {\n                result = result.add(self);\n            }\n        }\n\n        result\n    }\n    /// Base field scalar multiplication\n    pub fn scalar_mul_base_field(self, scalar_fq: Field) -> Self {\n        // Early termination for zero scalar\n        if scalar_fq == 0 {\n            BabyJubJubPoint::identity()\n        } else {\n            // Decompose to 254 bits\n            let bits: [u1; 254] = scalar_fq.to_le_bits();\n\n            self.scalar_mul_bits(bits)\n        }\n    }\n\n    /// Validates that a field element is in the BabyJubJub scalar field Fr\n    pub fn validate_babyjubjub_field(field_element: Field) {\n        bn254::assert_lt(field_element, BABYJUBJUB_Fr);\n    }\n\n    pub fn validate_scalar_field_with_bits(field_element: Field) -> [u1; 251] {\n        BabyJubJubPoint::validate_babyjubjub_field(field_element);\n        let bits: [u1; 251] = field_element.to_le_bits();\n        bits\n    }\n\n    // Precondition: This method expects that the point is on-curve.\n    pub fn check_sub_group(self) -> bool {\n        static_assert(\n            BABYJUBJUB_CHARACTERISTIC[250] == 1,\n            \"Characteristic has high bit set\",\n        );\n\n        let mut p = self;\n        for i in 0..250 {\n            p = p.double();\n            if BABYJUBJUB_CHARACTERISTIC[249 - i] == 1 {\n                p = p.add(self);\n            }\n        }\n\n        p.is_identity()\n    }\n\n    pub fn generator_scalar_mul(scalar: Field) -> Self {\n        generator_mul_fix(scalar)\n    }\n}\n\n#[test]\nfn test_babyjubjub_in_correct_subgroup() {\n    let p0 = 4597297048474520994314398800947075450541957920804155712178316083765998639288;\n    let p1 = 5569132826648062501012191259106565336315721760204071234863390487921354852142;\n\n    assert(BabyJubJubPoint::check_sub_group(BabyJubJubPoint::new(p0, p1)));\n}\n\n#[test]\nfn test_two_torsion_not_correct_subgroup() {\n    let p0 = 0;\n    let p1 = -1;\n\n    assert(BabyJubJubPoint::check_sub_group(BabyJubJubPoint::new(p0, p1)) == false);\n}\n#[test]\nfn test_a_plus_two_torsion_not_correct_subgroup() {\n    let p0 = 4689731437944306428780974070575571025333825310181802403039288057202868837337;\n    let p1 = 14792220576807380471707687543579831579477508903129740636298855878394914021491;\n\n    assert(BabyJubJubPoint::check_sub_group(BabyJubJubPoint::new(p0, p1)) == false);\n}\n","path":"/home/gruber/nargo/github.com/TaceoLabs/oprf-nr/main/babyjubjub/src/lib.nr"},"59":{"source":"use crate::bn254::permute_bn254;\nuse crate::bn254::consts;\nuse dep::hash_utils::poseidon;\nuse dep::std::collections::vec::Vec;\n\nfn internal_2(state: [Field; 2]) -> [Field; 2] {\n    let sum = state[0] + state[1];\n    [sum + state[0], sum + 2 * state[1]]\n}\n\nfn internal_3(state: [Field; 3]) -> [Field; 3] {\n    let sum = state.reduce(|a, b| a + b);\n    let mut ret_val = [0; 3];\n    ret_val[0] = state[0] + sum;\n    ret_val[1] = state[1] + sum;\n    ret_val[2] = 2 * state[2] + sum;\n    ret_val\n}\n\nfn external_3(mut state: [Field; 3]) -> [Field; 3] {\n    let sum = state.reduce(|a, b| a + b);\n    state[0] += sum;\n    state[1] += sum;\n    state[2] += sum;\n    state\n}\n\nfn external<let T: u32>(mut state: [Field; T]) -> [Field; T] {\n    let mut mds_parts: Vec<[Field; 4]> = Vec::new();\n    for i in 0..T / 4 {\n        let offset = (4 * i);\n        mds_parts.push(poseidon::mds_4([\n            state[0 + offset],\n            state[1 + offset],\n            state[2 + offset],\n            state[3 + offset],\n        ]))\n    }\n    for i in 0..T / 4 {\n        for j in 0..4 {\n            state[i * 4 + j] = mds_parts.get(i)[j];\n        }\n    }\n\n    let mut stored = [0; 4];\n    for l in 0..4 {\n        stored[l] = mds_parts.get(0)[l];\n        for j in 1..T / 4 {\n            stored[l] += mds_parts.get(j)[l];\n        }\n    }\n    for i in 0..T / 4 {\n        for j in 0..4 {\n            state[i * 4 + j] += stored[j];\n        }\n    }\n\n    state\n}\n\nfn internal_4(mut state: [Field; 4]) -> [Field; 4] {\n    diag_mat_mul(state, consts::internal_diag4)\n}\n\nfn internal_8(mut state: [Field; 8]) -> [Field; 8] {\n    diag_mat_mul(state, consts::internal_diag8)\n}\n\nfn internal_12(mut state: [Field; 12]) -> [Field; 12] {\n    diag_mat_mul(state, consts::internal_diag12)\n}\n\nfn internal_16(mut state: [Field; 16]) -> [Field; 16] {\n    diag_mat_mul(state, consts::internal_diag16)\n}\n\nfn diag_mat_mul<let T: u32>(mut state: [Field; T], diag: [Field; T]) -> [Field; T] {\n    let sum = state.reduce(|a, b| a + b);\n    for i in 0..T {\n        state[i] *= diag[i];\n        state[i] += sum;\n    }\n    state\n}\n\n#[field(bn254)]\npub fn x5_2(input: [Field; 2]) -> [Field; 2] {\n    permute_bn254(input, poseidon::mds_2, internal_2, consts::x5_2_config())\n}\n\n#[field(bn254)]\npub fn x5_3(input: [Field; 3]) -> [Field; 3] {\n    permute_bn254(input, external_3, internal_3, consts::x5_3_config())\n}\n\n#[field(bn254)]\npub fn x5_4(input: [Field; 4]) -> [Field; 4] {\n    permute_bn254(input, poseidon::mds_4, internal_4, consts::x5_4_config())\n}\n\n#[field(bn254)]\npub fn x5_8(input: [Field; 8]) -> [Field; 8] {\n    permute_bn254(input, external, internal_8, consts::x5_8_config())\n}\n\n#[field(bn254)]\npub fn x5_12(input: [Field; 12]) -> [Field; 12] {\n    permute_bn254(input, external, internal_12, consts::x5_12_config())\n}\n\n#[field(bn254)]\npub fn x5_16(input: [Field; 16]) -> [Field; 16] {\n    permute_bn254(input, external, internal_16, consts::x5_16_config())\n}\n\n#[test]\nfn test_x5_2() {\n    assert(\n        x5_2([0, 1])\n            == [\n                0x1d01e56f49579cec72319e145f06f6177f6c5253206e78c2689781452a31878b,\n                0x0d189ec589c41b8cffa88cfc523618a055abe8192c70f75aa72fc514560f6c61,\n            ],\n    );\n    assert(\n        x5_2([\n            0x0ae097f5ad29d8a8329dc964d961c9933a57667122baa88351719021510aadcc,\n            0x1db0afb64a7847b404e509b8076ea6f113e0dc33c8d8923850288b297b366a96,\n        ])\n            == [\n                0x234411a64c9117a670dcbb2e32887c05695108becb3746a4b63a5e0c64abf213,\n                0x0aeacd239c8086b9199880f4c20576cab326b06c4692d3dec9e13a35228a2a47,\n            ],\n    );\n    assert(\n        x5_2([\n            0x190e9f8d74c3ee7e6f9a5fc4f3e9aea43e4c636652d64732663ce4d4e9a82dfc,\n            0x116d4666591fd484d3f63b2143851ecf51790d344f076703aff0ea2ae73d84c0,\n        ])\n            == [\n                0x184f08154e7c0ae8d1dd611de726a33b46e83c881e7dcc83969ab5225bb1ffd2,\n                0x1c869eaf711604998e0015346275a1df87c872497cf501796b5c665bac5e6c51,\n            ],\n    );\n    assert(\n        x5_2([\n            0x0765449fba54a8f027fdfc4bba2251e13867d2999658961503e1c552eb8d30f0,\n            0x2458fc60fe06af665be546da89f792db27ba8122735483b028f7945b79a0121d,\n        ])\n            == [\n                0x00b99fef7542031ec0fc94e798c29b8d270ae80b0496316c722f149ddbd24c10,\n                0x05a9add2dfce4303c28124e1165154fcf44b7784d3adcc56f505d4e5917b8096,\n            ],\n    );\n    assert(\n        x5_2([\n            0x05df817f34e9cc11af435dd58951c0dc120a9637f1625dae110c900fd64fac01,\n            0x165798534b555615e2d3a7c0371d7c6b37814e4816dfcbcce9a7f5134166bf95,\n        ])\n            == [\n                0x2383496930a272a7d99e2db4dcfbe427ac7ece01dbb2c74e0393f44807131987,\n                0x238c2be5f5769977c50e089de45933dc1a00ef4f451497fa67b880fcbb5086da,\n            ],\n    );\n    assert(\n        x5_2([\n            0x278ab5ceb7ccf50051df09e958a60cdc29304d5a8bc5f512e8c05e4e8344b494,\n            0x0691450210975cfd5ad15ad9b7b8d2c0b0e15bc964511530830691b9bdb1deab,\n        ])\n            == [\n                0x267529bf7c33acceb53850eba2b713f4449a04d168f90b211c9cbfc2977955e8,\n                0x0dd91eb3904b8fd295abae96ce1e387d3ce1c06f1e68b8b14567c283a2719c10,\n            ],\n    );\n    assert(\n        x5_2([\n            0x0c19d1ab43ce3d913418687b4a60b758e2be814434c5310c7f0a6f5813befa40,\n            0x0cff2930faece292fb8ef0447faa51eca7538b91999d308c914ffe166deae4b2,\n        ])\n            == [\n                0x1ac275a60d969f95feead488e81955aa70680121066220a8e313309e76ce8c59,\n                0x05119d1c349bf5ad1b9af9ca6f17c40cd378cf971125709f1905b68d5172826c,\n            ],\n    );\n    assert(\n        x5_2([\n            0x23b96a10b3a6b5cb32a4a48ba9e2c7fd95a0381977051d377aba654ce3f46d3f,\n            0x12c4411263a01236387f3ad010243a44ac532a834589d6d7a38a0149748bf187,\n        ])\n            == [\n                0x26603ba36cd41bdbde16e06c6f1ec040743059b6ce45fe6f34e00bcb6e535b04,\n                0x0301f7923f6d373b7a36ce42a8f8be025d3f88e0abcd0b54e78ebfbf9116a9bf,\n            ],\n    );\n    assert(\n        x5_2([\n            0x2f1df4234732c49ac7567c29d2e066308f807e1bbf0951136b7fccba2602ea9e,\n            0x04a23083267080ae4ee1a3cb4173dbce507c86edcfdd02853b0399cdab611517,\n        ])\n            == [\n                0x0d6e20ac92800c7b08438805fe94a871c5f756ec07a919923c4e007cf01fa87e,\n                0x0d0e60f1acb65d948e7ff874e255c2c07a0f0ecc15e4d14209bc5d5715951ccb,\n            ],\n    );\n    assert(\n        x5_2([\n            0x106babe89343a47ce296eed78129b6f7af056b46ad808b2cabb66f371180dd17,\n            0x2f01d999b6e58284d87640c08c49e96d538ba3ffba0c544090fe858dbb5bc28e,\n        ])\n            == [\n                0x08d523548b9f396c877536b5f96fdfd1826ecdc0c806e24ae328586e8a405d8f,\n                0x1c1c5eeb613b596dd524fe59264ae5ef173cbd271e7f476a5f15d56175cb7478,\n            ],\n    );\n    assert(\n        x5_2([\n            0x299c0a40411ed9d7de7792fa299b262937b21fabfa386fa761e3f079c1d9045f,\n            0x2ace2e81e39d97a8e6d83c9e50a8643f4bf01a1465177518558305e7ab254c62,\n        ])\n            == [\n                0x2c62b5c08ee75aa967809de58131cb38e953fdbdccb9140ed92ea89adebcda85,\n                0x2c507b864995a399f7c1143f8c9dc67b7aca63419a2443a879715404a16ec6b8,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_3() {\n    assert(\n        x5_3([0, 1, 2])\n            == [\n                0x0bb61d24daca55eebcb1929a82650f328134334da98ea4f847f760054f4a3033,\n                0x303b6f7c86d043bfcbcc80214f26a30277a15d3f74ca654992defe7ff8d03570,\n                0x1ed25194542b12eef8617361c3ba7c52e660b145994427cc86296242cf766ec8,\n            ],\n    );\n    assert(\n        x5_3([\n            0x2c6422c33190d036a17bd4281738ad60a6b4544c1020da1c0c84880a0ddc71c4,\n            0x245cd98e5af9a6ebb35945b092c7e877ab9549c8919940250956a0bfedb457ab,\n            0x0b43c424171231016dfe2072518b825a18c759383dba4e09a47bcd8b1a55da21,\n        ])\n            == [\n                0x0b6f503d74ca8c80934b48d8d9e41c239ea6bcee17f658d416a0b72fd7daf1b8,\n                0x2845997bb81ad9d29f0b7ba57550cb7160b6930c70c92287207c7b5f65b2814b,\n                0x0a97e625f336a7c5e51bb2881e3b4e224f6e2e01ae5d698fa19446dbc407ac3f,\n            ],\n    );\n    assert(\n        x5_3([\n            0x124ce2326b4a95fe09743697c1e5c9ac9f6940cab7221decfd0162a8873c63ea,\n            0x167148c1014f9f1ae03bb93892ec0164c6f65f779b526c3499d7ac374e84af86,\n            0x18c0badc1c5aa472c434c254786f8e1aa8b519a7ec017dfd20bc1e5dfb820caa,\n        ])\n            == [\n                0x2791fa7cca97f87cc3de6ce004bccf28e3cb631e4fd31d50b38fc79b7e43dbbf,\n                0x22e42774e15a97e78d378b0225379ecbcb76060beef46e10e4b630bbd256003b,\n                0x2e56288af3d63be34692074d7db4ce2f9eda91f7a55ba60d7661d8c2bfca9580,\n            ],\n    );\n    assert(\n        x5_3([\n            0x034f5155557b5e85db4fba5c254882f8658baa03376a38d37ff03fef1f850cfd,\n            0x23975b943c4070c2bc98ec66b4a9e1f0ca1c812b38317bdbfac98aa748b5b059,\n            0x03f9ef0d827a433a679060b654b556daa963c9658f628a3522dee7e839ab3615,\n        ])\n            == [\n                0x0014a5e7728d210b90ef439df76561371be410051332852cea084ef73271ccbd,\n                0x05c0808fa8657cb6091ee49fd5a0b32de2affeab6bed761043044982b3d7e3f5,\n                0x2f6cc98fa05d79737a559115be171d2863e65080353c281b2104bb17b01f9c49,\n            ],\n    );\n    assert(\n        x5_3([\n            0x184561698ba999c39dcd5effd2f073e95345fb74f023ba25e162995a206ba79e,\n            0x294e74e9b2f87eb7f5e00a350a22ff02e22397c278d48cecae04a4a83085a9ce,\n            0x2840b008f9dd0379037622060b97bbe9fb5ffcf3e765c0a7feb5be13405ad2d8,\n        ])\n            == [\n                0x13b47f0963b7751e01c8ff9775b02df2b185d8a968edfded67d518fe00a13104,\n                0x287fc57d4458c6853c98a361b93fbfa6176e346bd75bbb11773b00356d496b6c,\n                0x200f5d2604826c715b6b0b731a5365d9bc24cba1fbeec033e3e0a434a6505251,\n            ],\n    );\n    assert(\n        x5_3([\n            0x1c3c047ca883688ca6b6ddec715eef99a40282a4dc1d1b33910f59f30074e8f4,\n            0x0a3aed04e3acb73a0f74d42f0d304f1afeefc00859a77d956120638d9007fbc5,\n            0x07d9e5a9a2ac225871d7616f13a7a0185731fa679d931762ce1ef7767a3e63df,\n        ])\n            == [\n                0x0df5bd217aa8e906435455b0151adae8dccb5f1fef23c0bd36a15f78f7b90ea7,\n                0x2f6ae610ef9f92d6bce4540aaecfd2f0e93bad0671f544f0c16bd8546de44928,\n                0x1b74956ba343323130615d776a667187f72ade7bc295c7750551170721f5253f,\n            ],\n    );\n    assert(\n        x5_3([\n            0x1e7cb866b31dc33c91585591e7c82530ef2a25c3feef3273b1c4fc382790ab2b,\n            0x2781a330739b20aff560c61207ac9a3dd0f74b78dd9d4ec97a3db650c4d05ae6,\n            0x275dc90993858ee8bcee5a94d1010f30c9731a49eb799e3aa0dfe94c73d1d28a,\n        ])\n            == [\n                0x1c8317bbb73ba936b89bb337d1a91a48639602b721e0400e0b9d5799f64c3dd7,\n                0x1a4887a3b86e801f5602aabf3d247a4fd508ecf6eb5d1e54d53eaeef7235b123,\n                0x1a1298a0b4d732d42c85649ac7167073350be052dedbc334d05cdbb2e636b72c,\n            ],\n    );\n    assert(\n        x5_3([\n            0x276d519f50629d7ab7b0362da8e532da858c989c37765d77e56d570ef67037d1,\n            0x2b7cd64f3fdb10e2006a924c051cd3ea53dfa82e75993bad8d0eb4ca8f3756b4,\n            0x07dc1f509cb68ec98ce1c9d18a89fa75a28a300ea58769a5fdc5ae19b4459c24,\n        ])\n            == [\n                0x2ad18eae7534d3d0efe05e897a4daebc441027e39256c1b647350f4a1969ed22,\n                0x089f6c4f52414101923991f94065e403aa9ddb7af3381c74b595650460d883ef,\n                0x1cfdc65275dc88f45a862bb5618c586c52a548a7ad33fa6240cb06cc79988278,\n            ],\n    );\n    assert(\n        x5_3([\n            0x0c6c15f4368f09bdaa7e7f4bc63d65d597eafe75764d82cb4d774e1982fce517,\n            0x2e250d17689425c849b6d94bf822783c14086e5b5a145f6bd67d61d227e5dfa5,\n            0x18693f449496390c0d6daa3f03170629b987b27c832c9e2aa586e3e36c6eac8e,\n        ])\n            == [\n                0x0d35a94d34a9fe5527a72ddb2a6654bfde040cb5ed436944146971939790429b,\n                0x0bf853441574d5367ebfb250538322e16bda7cd1ed8097a7924f937c3bdb6807,\n                0x1e9ece2f587bdcc047d4f18419934d2d53f5e1aeef8ae5ac7a66bea8eea657b2,\n            ],\n    );\n    assert(\n        x5_3([\n            0x2fb3cd143630e3dd1a1eda75a9e8e698ee7a3a877ec6ecd7a77de97a1e0b6657,\n            0x0c525ee6e5674c991dd70bd04a00bc62119d0ae97a1f1ec89cbdd34ac139edb4,\n            0x2b6d256970b78cda94586db4eb7db119b10ee087b9ba107afe8c64e7b34625b1,\n        ])\n            == [\n                0x131f70df273c7fe22667903a3aaeecfd8a873067c836159ffeb6b7e9f9ff347c,\n                0x2c3734764e1decc2f5edef11beeaa1e7319594a4fdd850ac34370fe616f07fc8,\n                0x06aaada4c2611fd916e1e0e7c31625e60d3e0b3ff972de980a3327350896ba2a,\n            ],\n    );\n}\n#[test]\nfn test_x5_4() {\n    assert(\n        x5_4([\n            0x0000000000000000000000000000000000000000000000000000000000000000,\n            0x0000000000000000000000000000000000000000000000000000000000000001,\n            0x0000000000000000000000000000000000000000000000000000000000000002,\n            0x0000000000000000000000000000000000000000000000000000000000000003,\n        ])\n            == [\n                0x01bd538c2ee014ed5141b29e9ae240bf8db3fe5b9a38629a9647cf8d76c01737,\n                0x239b62e7db98aa3a2a8f6a0d2fa1709e7a35959aa6c7034814d9daa90cbac662,\n                0x04cbb44c61d928ed06808456bf758cbf0c18d1e15a7b6dbc8245fa7515d5e3cb,\n                0x2e11c5cff2a22c64d01304b778d78f6998eff1ab73163a35603f54794c30847a,\n            ],\n    );\n    assert(\n        x5_4([\n            0x0c8c9889597488008e2e96985b843092fa78004ac3406c9df51ed2b6cf1165cd,\n            0x20519dc2e54103607f781cb4c3e0728db3c0183b0d8e32b7a18b3ee7226d1866,\n            0x17f6e0269a9439e0cbafb92fb6a33448460becc662da31786bf22935ca8734ed,\n            0x18bd21d391158c54dd641afa11a9020a2bc49948f16864fbaf161d746d49b3a8,\n        ])\n            == [\n                0x17853a421466990a70c8df0ca883fc9580968a8ff381c573ccdb2a17b4717f1a,\n                0x16c5b3481f48b51a628fc4595f30198f9c7eef5315e126d668a555076d6b77b3,\n                0x06c6ff5c992138c00e99c9daa6a4eeb86cce3b1b8cc9fa8b30c3a9350dedd1cb,\n                0x0fb18430a0e66a85bdf65c38f2d23be9005c48fae709f297268d13bff5076b1c,\n            ],\n    );\n    assert(\n        x5_4([\n            0x1854b7992ec5a1349e9ed40970bbae67373bf98cac98055c7baf28d664384085,\n            0x12d3bf93b4c656e57eb1f4e1fe74f4dc5dacd2b95f27a12f0cc51c8aad9b4ceb,\n            0x26c5ff636e75996c5d4953e2f44fc31403710c59e017cc0c68d7f7b547e5e12d,\n            0x1c29859e1768d3def45f2a97f7f96fd13149e50bd809fe6f49ee960e9d625f3e,\n        ])\n            == [\n                0x17d01a086c63a77d6315cd7a1cdbac3ca89534c1a1da4e778f5ce60bdc77b28f,\n                0x0c64c46dbae63fb3e07037ae5d732c5cdf0da73971b940dbd32b2aa5c0bd7a5f,\n                0x2bcdcd400e2f052facc52233728cea88f9088313746a0f44fc286c5b6fef5f8c,\n                0x0fb03a8ea938397d9aaacde31fd4510d89ad5a11d353603448d19bcd4bdcda8c,\n            ],\n    );\n    assert(\n        x5_4([\n            0x24ad6b688e5398429ffb1e3ba8ab3cd798f9909155b45812325cba5a16d2d220,\n            0x300687b9652aa54e7cae4137d9408e3ddf88a869428998d30b86f788ce92e1d1,\n            0x2aaff3037bd20cd938462fbf41dac988afe9104d7794016c017a29aa411912d0,\n            0x195cf02bd9aeebd4482b3f72dc509221de8c2ebf37361f8766f600bc748de617,\n        ])\n            == [\n                0x143d9fb2ffcec25c75977edf8ffa3d3007cdd38e1bd4d64b0a6603b7e38380a7,\n                0x1d2b015c19154421416a0204b88da26fbb74fa545116bea2c1c252d8cc43f284,\n                0x25bcf030113a4e13e812ebefc4b2af53687c21729bc197462b1f52b9d38820be,\n                0x0758b5e5e91eadf63054e205c4239ad12b950fe183800db6e2673408a4ef2600,\n            ],\n    );\n    assert(\n        x5_4([\n            0x16e6e596105e785a3e0bc02bb15398a4b08c55b9cba3536877ff40b7de1f2a38,\n            0x2530d6ae25e495a3ccf8d51121e0d7134825264c630c9aacb0f78c380498e5eb,\n            0x1586aaed4606463b8d7ebd287062d9128df99c8cebb06d8ddaac95e258e5a804,\n            0x02082849eead984e1db4f4bf307e310a1fa562b14e446cc62f8a7232673b868a,\n        ])\n            == [\n                0x1b9c747e2cec9adeb3d6e37f0f2eb39d3e5055afee568d4feee3396618c86670,\n                0x2752b18bc2f394a02c93e39322a62d37107810fea619c69e5f855390f29af3d5,\n                0x1e6ca93880b078c245c1388d6756d2e222ac749360c0e8890f59cc3469498f89,\n                0x2554845bc6555c2614692cfb69936fc1fdd64df889198dcddaad8fe34fdfd02e,\n            ],\n    );\n    assert(\n        x5_4([\n            0x1e0efaac6c6acea57222f9161313ec9579cda0c85e22f180345af12abc70b5a1,\n            0x0d0f3071f2e4fc48d9dd9f37367de2ec12260ab9a8729269fa1510e9d093a5b3,\n            0x26b2e5123ade4de33a0185d7ee08bb10ab217d8cf44227673904ed9ba7d6d0bf,\n            0x192aa37419458e66c367d86966f9c3f12e1a4ea89883bf21f98989ac5404c163,\n        ])\n            == [\n                0x1882d48c13b9d810e8a260a6097864328e80253b650c95178bc23cf9784a6221,\n                0x14716a2a8cefec1867e13d2972da49ff8eaa54a8a6d570ad3f941e3503c04051,\n                0x1d7d8881a73cc7b1a72651a8ed89ac423a80c81a25b81b9f29da1a46242a2315,\n                0x01727d8c17208e420a5aef8388c19dc1bcf1aa95de99b14fcc954fb830db09e9,\n            ],\n    );\n    assert(\n        x5_4([\n            0x1420cb6e80553413972d39a0e2aa1b0fce8e1759e8955b9d0b4183bfe7cd2577,\n            0x0e0bed978ef7b27a34d0fc3f4db4dd6a62eb2a89deacde38ab43d23b5001d9ec,\n            0x1f52d011ec77d06560315f14de37b7e6af34fa77c8689f82b5cec53a6f731a8f,\n            0x2b6f87516d48fd88765f571998ff308eedbfecb4de3eab9f541845fd5a079a10,\n        ])\n            == [\n                0x1cc0885e44b1e34b49d5a222b7c61d4423b1cb2ef5c7ddfdf79ccfc09d7969fa,\n                0x269f78e3b703e373d6bba5bf975850256e59fe346fee340934a6f8d11aa06d1e,\n                0x20ca89ea0ebbc138a7486139a8661cfd9c60e0f6a4448cee512359f53115d637,\n                0x1608f2be9dd70626d5faf42532b6f3d91bbfe9cf0dc48df9fc70786c22f36e5a,\n            ],\n    );\n    assert(\n        x5_4([\n            0x02ed7335766c6990f8c4c07e406dbe441efe9fe3f8a3b3c36efcf8d5b2466a78,\n            0x2e1b45eb605cde0d22d13f244108dc47d45c395a1854afee35822424b6cc022d,\n            0x2f26a4bd4c1472f8fb3d475c64647acb9371432589214dba81a90cef7e84c3f3,\n            0x018dad8abf0ebbc641d59f342ef89b61a0645dbfb601e4220595050d4927efe6,\n        ])\n            == [\n                0x07ea9ac7ee426db731f066f680e808598fa2a2e2a2a0184343332cac349192cc,\n                0x138eb891fa8db7ced98b0068a5a0d601f0e35c846e92bd89dc99b26fb4c1ca2f,\n                0x08ff879f042fbb823506632bfa99626ec1f8e02849fe0710a915c1f2b1c17e2c,\n                0x234785ac2b70c4e7c0de52b4b9f5b03d04325950cc88e26a2c59f2ee45f1ebdc,\n            ],\n    );\n    assert(\n        x5_4([\n            0x2668dc5c24a61ba1ea716788ca323027411c67114fcf8d3037ec85cf04f9ab49,\n            0x2ff5ef931ab5091bbc32352e20b9971475f2096cdec6a2540897bf383b3f491e,\n            0x269edac091156e2f0b78bf1bda18b4bc0fa57c5da2d9223c0af89e7e32360079,\n            0x0a26433da1fc61b268edb2be549944559ae70c4b90cffb6d3b37f16f1ac7626b,\n        ])\n            == [\n                0x0d1ebc93de138f542afad67b1b7ed5a0a91b6386417a61ef775c4498f324c339,\n                0x02363f63f074a61ea1857ac0e821c228794a18b481adc3bcb52c4a2f1d2b271d,\n                0x2b39691b7342e1b0b5d50511ffb83b7ff01d604b2ad3e9b216d78dd9538bdb3b,\n                0x1b99a6480116544d64604ab259da12cc1a7948106b6107949457356ccdbfa4d4,\n            ],\n    );\n    assert(\n        x5_4([\n            0x0b714049d73a453d12fd8d29b6d3827fca2e9bdb2b81700f91a99af577c7fe7b,\n            0x2f0f7fed2d8dfcd4abb28e3622eae01279c61d4256a6be4cb3b1fd51b8d723bb,\n            0x305e7764e1a84dee8dc9a1f80d850ad02302840f301590f274789f97c8c1f2d1,\n            0x207557596ad35e035c50acafdc27a0073889426cfbe4ba1832d6ef7cef5302ec,\n        ])\n            == [\n                0x021fa88b38fd0749af48dc29fa661c3c4741ea05f359384caa04000481e1d1ef,\n                0x2e62acd7dd3e2bc28218108633a8c30c9cd16957b3122b80e58a04738b9a6974,\n                0x13f8bd5eb5b4d726e77555718c121d9765be75c7eb75f0ece17788d69861141f,\n                0x1843371c51a20880032443ed629204bfc54ae1db656feee8c11c6d4ef2a7cf73,\n            ],\n    );\n    assert(\n        x5_4([\n            0x044d9089d0d731e323eb08218c16222676b1b170bd13d06ce96759a21ebe3279,\n            0x120b8825613c5d3d12545a5806743e5234cc1586f1d1bae59bbde22eb973178d,\n            0x2b5a57fce5f044b2e8b26f6f669b88eb1880183e7bfa2903a16ef0236f2f3faa,\n            0x07f4a9b793b47b8781ede417ad119323d1ae6743d5c3dc990183eec04ae03e0d,\n        ])\n            == [\n                0x2519d1f27af8da43d481547ab075f18bf96be7f94c81439e9a666e9724cc01b2,\n                0x0043d337bfd1462f71190d710e163df4959d74c85977efe90a356a65e4bdff9d,\n                0x2bf3a9750b18f92d984cdfe1f61f23c427e1bd0764095fa2d96c0339cdd4771f,\n                0x00478202dc2b091483edea6c313c77aff25a45419cdab2d88e662fdc007f4c67,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_8() {\n    assert(\n        x5_8([0, 1, 2, 3, 4, 5, 6, 7])\n            == [\n                0x1d1a50bcde871247856df135d56a4ca61af575f1140ed9b1503c77528cf345df,\n                0x2d3943cf476ed49fd8a636660d8a76c83b55f07d06bc082005ad7eb1a21791c5,\n                0x2fcda2dd846fadfde8104b1d05175dcf3cf8bd698ed8ea3ad2fbcf9c06e00310,\n                0x28811ac7e0829171f9d3d81f1c0ff8f34b360d407a16b331a1cb6b5d992de094,\n                0x2c07c1817cfccb67c1297935514885c07abad5a0e15477f6c076c0b0fb1ad6f3,\n                0x1b6114397199bc44e37437dd3ba1754dff007d3315bfcdcdc14ec27d02452f52,\n                0x1431250baf36fb61a07618caee4dd2f500da339a05c553e8f529a3349e617aa2,\n                0x0b19bfa00c8f1d505074130e7f8b49a8624b1905e280ceca5ba11099b081b265,\n            ],\n    );\n    assert(\n        x5_8([\n            0x11e027e38a43d36a72be06d524c0856d027363f604c347937fd91acdd47e04f7,\n            0x28b51285afdea43557ffd2b5ad3ec85c08e1f718e263bf9e8709889d6bb9a745,\n            0x290a6954438d96f11db1a59092c454379c233b5a07bd0b70f29ea12c03a3b729,\n            0x06869a7aa196418515672ba3e3de0124866d8448d387e33d69de16cd0a0cd9d8,\n            0x2aa9acb0cfdabf42c8254db2fe4980c757daaffa7429e87bbbd5756334a01b86,\n            0x10356d863c177d1a97fd1a908b89a6ff0bccda3eae346c96ae8a72f3b44d59ee,\n            0x09b24b777e6352b7908cc4961942624f2725412f84c75ed93238ccd42b2efd49,\n            0x241fd4790bab98a9185d5b11d083ffe5360b3e2094bf1123142bcea4eadf6012,\n        ])\n            == [\n                0x301e58def5ed2e1a5dcaa44a9cd47919246011f39575de8212cd631da771686a,\n                0x23d5d952e536aea304ebc4c83d206a8f1dff4c1480334ac954bb24e273ba2120,\n                0x12386a450b5c89202ee12619ff486c1c2ba39ae969b24f7b850afe0a7f0db2ea,\n                0x1100f7e0935587cc6e3d2a59b69045e12c1e1ca3c442365c5769ea2df8c370a7,\n                0x20bc910a6ec6aacc4007e5dfc7bd7b51adfa1dae2516aa3060e15e5a42106b5e,\n                0x0550bb9366d5da5470ac98c4e97fb12cb04e70fb1e47d17d365e9444a9860761,\n                0x1049903ff3d9d6a8286508e3e7b8e3f3d254228aa00c322ef9d305d3248b8754,\n                0x076dc291e1cdc9f48efeaf713a161de6d43e407133f38b82d56df9279d723de9,\n            ],\n    );\n    assert(\n        x5_8([\n            0x25776de965f9e74ee70f66a4aa501b2e5bdd7f1dc2910bf1a060cc5fd746ed1e,\n            0x2b5b27c3c2f2f6991ce700ba074c7cb8bad876e2a8f09e712310c50f77af22b0,\n            0x2f43305136fcb3ef1d0fa9347702dbcdddd8475ebb01d617a598add5b0d62aca,\n            0x16812fd128edf911aa4f7e27568814a208023bc9ffa8183117efa78ff356734b,\n            0x0811490d27c169cc8a8a774c686cd25dfcebdbfdf9865152728f10b02f416a8a,\n            0x04955c2c8ad3bab330220fb515cd610fd14f3a20d4c8939846580f46cf23b6af,\n            0x048ba851a27072d279d88094f1f3871974d645e1dbd9226fa35f81731ecea4e0,\n            0x065be967a2d16752761af356145ed461a2056ad0a7e9166940623e4d140b76a0,\n        ])\n            == [\n                0x01fdac4b572d213e5b5438a33af928caa48a2325ac8cc30239ceea2f45819e0e,\n                0x1dd13703749821c20ece4e35213b89da18b635672d791e520196a00c6885f575,\n                0x0df6f1389b8d70c99487871540ca5e0cf4607cf5e4556bd2d039a14916bbdc17,\n                0x10d97ee74863b8809387176212ea8d7458d2fb89e5216e6e7fa80fba63c0af7a,\n                0x1384c276930a90e80c8669d30a72706ff550e66e4b5becefa4a4a9f434419d9a,\n                0x27848d26ca176da553cb66917754c38f234c00b0b0d28c2a48e1d5d15a8d8bd6,\n                0x108255dd7381e3b8af4bd33974092e732e5a1bc6be7e6974a9e7d3c4a77f4005,\n                0x2b95ca49b2b7e7316bd7832d29e3235bc3769ffd04b98671af8d116a2ac565ee,\n            ],\n    );\n    assert(\n        x5_8([\n            0x03cab88b5d93ab657ab738c39575c2812e61f87d188d787ec9c920da592c2243,\n            0x1657057a76dc5a0846c28c33fbfcdfed94a3baea5daf495df4aa61ed4bad34d5,\n            0x050fc77fea82eb8ae11537eeeeee6cb66ad4f77810df293cb0ceb614fa86328a,\n            0x0f5574ad89685ce5ae2beab6db16631d32b16789fc9a1d4178bc1b73ad83be17,\n            0x282d72510f9ca1e6fbc868d709137e17e516cc26654ec034fee1cf5bce179bc5,\n            0x1d84329514de9a7030a7ad080cc7683ba63de7b2b14c71611f0cb3565340e223,\n            0x2605438a072c04502ef613759e28d86b51dac43671182ce62250e7a806e4bf9c,\n            0x2aea2975994ffd70c4ff8b6c75840cca6736fde04f03aa784c1cc5b7a27b006f,\n        ])\n            == [\n                0x295df3c1a93aaf9c6e852d06fc490c2811646eb73143f55eb86e679b1ca7354d,\n                0x1ad9d7447e57f1c6ae9a8b2300349e2c9332e5edb6813e12e428922bb66630c6,\n                0x2697581dcc42d3162ea222c0b5a47b3ea975824909a707d0af1431a2a2932c87,\n                0x22829b572f388ea29335c16f079d9e1ea8081a1709e45b9be089932fa70b5e58,\n                0x0398a6b47097a23a0afba8d9b76e126befdf2fcd7742c3136600b751ed18c106,\n                0x203aaf9774c8d558d14c52085d9a4c2406394d0000e640f3372d0084ecc84aa1,\n                0x14be6fa6b09e9b03b603e75baa6a80764e170941fe782879d02988d0428a115d,\n                0x01579c9185a70c3885e75ad94de88c2b6237d7be5fb8f84ebd7c3f2733a04f3f,\n            ],\n    );\n    assert(\n        x5_8([\n            0x01b7c953d757d279f1e4b8b29b70cdb5b181807c1952fe7ad9cc88e441ef4f65,\n            0x09891fea0252d6f9b61c944b994f28f6dccd6f8a3965f8b7b796aec3d81182b2,\n            0x014790065d8a6de104535d6aa5977dca5ef04320eadd4186b590fa810decb825,\n            0x05cf8199af1df3045f8aac45d9c5eb0b301ef9e9d305db6fc6883ca98db1ce02,\n            0x0071c2a63515055a6e739f7f615c549055d12a62336a5458e0dd69857e1ed5f3,\n            0x0b81cf03fa8159f33a588137731941ba56001003494172f97ebc0db4af7f0c97,\n            0x17f989a8604550ff01a9950cfb4499fee9902f763c5c5eac009122da69e8afd8,\n            0x01f0f10c2672f33e6e7510229b2ad4c6507cd678f856b7a7b3497b94da784463,\n        ])\n            == [\n                0x2a989aca81a76dc71608ecce97a1c8a9cbeb17fbc3384155de797d4ebdba2b6c,\n                0x09e6484583737642bc573e4ae77885d5b28f7b4954fa59980d0057e781e1b69f,\n                0x1d738584ceb67d8b49b3ee78b4b3ef1b808f7cac646e5b84517f66342d26e0bd,\n                0x2b0202533b12d6a69de9d2c54360755853b2fe7dbe111af464a3d25ee7a2bb06,\n                0x1b72cbdc33d5b147be615f4cf8c270cf0d49d81911fa03a8108c961f4a83da7d,\n                0x1d15628748330de1caf59dd3246228da6b54cc42b5f2657c274552acefa0ffc7,\n                0x2fb4d731d2643b8247e322052c3fcdaef68775df06174f649d93fa0ff1930bcc,\n                0x0313b7cfffa0ff58a8a1f54fdf6b95f7f772a5d9d24acee109c08c055cde351e,\n            ],\n    );\n    assert(\n        x5_8([\n            0x1a9c3fa290fa302f24a32fc7196e3fbad886e55f0416fc05a0c4ea5f92cac771,\n            0x071a29de76b7de4cf5d077d2ffa826b3bf8fab45f1becafa8eef4173b8c1693b,\n            0x0cd670e01cf5d1f3f45324fcd78776e60a113a7d804cb370cfcb9ab480e47fa6,\n            0x0f4d079133acdc2c86fa92aece9c1a14cb80c64abba63608b233ebd6451d0b08,\n            0x2ea0a7982d4b2cdd448ffdef1635aa69ba5a97520d6825921ea52afbee172a25,\n            0x083171a1ce6c5b90113821f2bf850211372151fef1a5df8efa29845c2c6704b2,\n            0x12e9ede1912ded64927bde975941151f9c2ab111823df2f0ea72fcfe9a6ecb5f,\n            0x2bee3febf6d48fcea7846c6480949bd7c6ed3237b39ba61d48a00f3e6db4afa8,\n        ])\n            == [\n                0x028d3fae682b98b85071b577781c740da8199fce5a379a9dc68fd9f00c6e5520,\n                0x19ba3cd5167c9fbb57abecbbbb9832323f711d36fd37dea79b7571a53d1b5a00,\n                0x118186bc3696352f5e7215011e870b7f2cf9e09989da49e4de935696723365bc,\n                0x04307689687696afb89acae109697ea3c428f9791c03a42dbdd32670d45fb455,\n                0x03a71c8c430e0d2b7ed54ea400147ca5d7441dd63cc9a0ca945ceb11258e3107,\n                0x20ed2ac661874da03bcbe13a250eb08487152d44bef8eb44d1ca1a76dc5cee83,\n                0x034fc10be3c3194c5de940ad9e58cae869ea950c2911d998569658e8ccc25c5c,\n                0x115758ad61eeaff2405b0422c178a9203cd208a7499700768d06c8bbeaaa6399,\n            ],\n    );\n    assert(\n        x5_8([\n            0x05af85a2a83bbf0c8e1745d32f821fd445e7f0e16e3efca09f7b670a7d1b3303,\n            0x2db863f54326e5338ac73f56d5c93d591241489cc2a21faf87385c13dcb73de6,\n            0x04f20a97ec43ba9ab2595f72f6806be8cf6defbf2c5a62338992310c82f3f4b5,\n            0x13f04b49992fe7feceb79da483d1291c04ba82d7ef41321aab047dae78726ee3,\n            0x2e378dff8c0aaa5c7e68f4d288fc3f937eb034c8abccac668bdbb40397bb1189,\n            0x1d3ce99b763439ce5d7e7b461b34d52cf7d2ce66a60017f124d5a89a57ff92d6,\n            0x0467533be3b8b58c27a480b3271328d74e58b1b7fd0135c5871c1cfff3288eb2,\n            0x17efb1242817bc50e52ac1508414af0463ed75b2cd39ceb6b510ec6ce872b631,\n        ])\n            == [\n                0x248c269a62e166b3b921c7aba80b75f73a8db719b3e5bbeeeb519ba146b5ef48,\n                0x00d743b68fa94736b4ee629fa69f1d05ada368b86e272c6187a09bb9ad45e084,\n                0x17ff35e315ac5d8a79f120d82ffa2daf92aa01316b4c56704243af1d342314cf,\n                0x18ebb33f68d51fc94b4815bdb4213aaaf8127d0fcdde245a1a143bf117b95a6c,\n                0x1dba46042e735f0e5171b9ac3740e4448034a69a5c1fb62de8c7e3a89d022161,\n                0x1372c3c58af5ae0ce04419601e8a03e2f613f1f4baafb9561d483b691bc625e4,\n                0x274fe183a550bf98870960b13668ddffd5ae00b457e145695e6752d372152ac9,\n                0x262db490dd2a0370e2a96bc9c5d9296dff723e984b36415273f66eaa55314cfa,\n            ],\n    );\n    assert(\n        x5_8([\n            0x2c8ef342682e4a13c4471f202bd59b9e1a3a89a4f58f456d279c73e92653364f,\n            0x1180875747bff92f8ec8e698a513965c142bb3c2d9d60276a9f3c37f4181fb4a,\n            0x27c395d2f21b9f73aca6fac113a2623cc015c5ebdf87ac3581022a5d55065931,\n            0x01689ef1805380ceac4d0a7e2e80445d0853a5a3813a4922dd9d3dc1c1a1380f,\n            0x2f9bacde66bdd6b539df5ca9a80933db287013d55dab4acdbb5d84b3da018f46,\n            0x26b5f43cf484dca908d3a557b990eeca6a8e6acf9303ac8ffe39366e66bdb863,\n            0x1552a91453438609e676b073b0f5aa68b0713b602adebb39049654ec1c6680b5,\n            0x2d75ac7fcd54f53156a38651170b52281504be4098deebcbf475a2bf4f74e66d,\n        ])\n            == [\n                0x09b846d7cbedab163a34651b199c13fd5d63fae2ef0db60e0e5febde9067ac26,\n                0x1e0ecfd870f8d60d801b899b0070162d919eaa3c130e86e92a5f95e82748477a,\n                0x05e646017cfce6a345cf4a57f3b1d7807371d99ba68bd97ea7ee438e207602b2,\n                0x233c61724808502fc7756361bbc10a45956ae30ee7121f2896b3dc4e764714ba,\n                0x13467a221ce5d3bf338d36280d0a718bacb895e7630edada9fb700dabb95ca51,\n                0x2d996fb08004f0fac8896517d88634daab4484e2d6506f12aa38bbfbba2492f4,\n                0x202b9e2900240d9b062ca7b1e795b5f8265311de20d2c67ed4dfaedcb03c63a0,\n                0x2ebe566b153b14dfe3602a610a23f53c3db2af715dfa9d51be7df965b83ee0f6,\n            ],\n    );\n    assert(\n        x5_8([\n            0x032227d5200a7a32ea6e15021e3e0eec3381e3ed9eba437657422ecd23e7fe53,\n            0x23043016d0bd81048340c78dc7a30339fbf5d6e1a2ff320869af5ad4ecda70cd,\n            0x05f4fb3ae740d37ca96cebd4e5f8b4f115f74793885cbc318f6b15c8666d7cf3,\n            0x1ce79da00c696eb21049015a1c1b00bef6e6d9e097a01d92101518020e7764eb,\n            0x02f2b1d10ceda238ca16f4a1a99449f4858b822ee79e032ca3b73cc17d9e5d61,\n            0x0573ef89a24f29c0e17f1f4429e03a67cadddf208a692610570e9671a9666b51,\n            0x1d8b2b93983ca3167f92af6e873e3eb3fc00912f9d0ff552f2a0eecc4bf5ef34,\n            0x168fbe71a83806e9181500ebbd4655ae1883055b04bb6b7e478fd755b7de5b9d,\n        ])\n            == [\n                0x21e9bac62e77ff814dbe0e6a24c75135936f4988f23197bffce2466810a2b07d,\n                0x25196718e461793cd23d5f04687ceca0cfc9dd398afe89acfa73449630016f50,\n                0x07079236786886d210f62709c3b5921a7ce5bfbfc4a00bc71918bccfb8b15377,\n                0x133fdd783f3a83c6f4d7555919cb08f669433520affb73d01782039749ed70c9,\n                0x290a5a0bbf07a09a3aba494da79f3c8137d772b0359b664b6eb56b7e84db453e,\n                0x184102d72083529789e0b89be0dfa370fc46b62b934f520654752ac8c1de5c93,\n                0x283faa9f66498adc14cef4a5ddb3affc5bf5b67857e52090b515a7a3c4b156fa,\n                0x166a12fabdd43d13c5627a47641eb870946b46361b4c037eac90da1995c4e64b,\n            ],\n    );\n    assert(\n        x5_8([\n            0x2b38c44e6d922f1916c6fe209b60f11d79690da00dfdfc688b083a84e2226575,\n            0x28ffe5213d9d33b4152a2f9df1cbe5be036519f9931371568d3675ddcaf0513e,\n            0x12f3dc47fa9ecd2c8471c8921797ffd99a647b0e0a7f053fac7d20cfd4e7c45e,\n            0x019b85fbfbf4063ff1c2abf19456b9b1a102f35d6fdb93b47b16baad1ba4109a,\n            0x1af5fc2f51aa73bbb6983d3f3208e2443c5b91f5ff862121c05d3f46dab238db,\n            0x2824df6732b46722fddfebbee5ad5dc247cab77531be5e0d46b85ed5d62acae9,\n            0x2160a8293c32813fea9fe6b91cdb3e8bd464b8f0213425874b0b335487675138,\n            0x11766143563259de702db02548131cb0f4898db4823769304c806123d1bdbd43,\n        ])\n            == [\n                0x302d72785ca7f277a71d3f4ecaa03425402f2469f0b412915d7693454449ab55,\n                0x06dc87f90a66d0fc9beb26840a5ce5e8f6ee9372eb2cc6c1e68d26a48dd2380f,\n                0x0d612fc26aa0f5198ea2b6cb6d7ff1b87e7d0fb85e6251107405c0acf24a8c49,\n                0x02da5053884af86f628c215d924f8c5d506f8a6e704f25884c932b5679cff1b3,\n                0x0ee0fcfb45654a9459ef304b5c7ef5413573743f16c661fe0b488270648514f8,\n                0x03d82d7c49a21bdeaed9d646dc878803076564da8a6716d2ff27d98672a9015e,\n                0x06e695edbf722cf7f00c732537f849c950d805819c2fb697319441ee6c369a2d,\n                0x01be2f8cebfbba528e81e581c55280cc32e33931f6299f68f68a2afc4858e334,\n            ],\n    );\n    assert(\n        x5_8([\n            0x16e42b1b9957861119562d0f04fec5050762947b381e0578367260b083327887,\n            0x1ab2141e8e0a746272d9af6699d4e82d5674c69d25d11dd6b5be1725a3beb451,\n            0x1acb3bcff3b760b884bdc302d3003dc62559cb9461f037ae65ed8f625d115f22,\n            0x18297976ae4add63f033d6d282271ca89083d63a8890640b98e3e1324ee7569b,\n            0x077d73a6f7a05d84e5fa59da6c1d3f406852cc9e514cc3547b5d6d467f727a36,\n            0x177aaaf8c8e7ccb27e2ea54943d5b303936e88059ecf15b0a0dd93d07803a928,\n            0x108a170d6203db76a36ac6db771c3519f9754ec6451fae681b774762c2d06c2d,\n            0x143070956a890ae047b64d289805262f80116094005dcf064bf76513c13674d7,\n        ])\n            == [\n                0x17764106391c20d0e4c05715425aa46b968df076f693b32c6e9691807a7df01b,\n                0x006c8e661c70f83b92538e86bfa9d9824eddab837e2cc73db916126902c8538a,\n                0x2a90c3b5b82ce25c30483012671c78a59b0973cf1b547e6e708608879a0a6332,\n                0x17c46fa699248524eae3cabe54df82bd3058209481ffe64d2979c33ae0495ce4,\n                0x1d3ac6bbea4783bd4768316f1673a1e878e0541f5c6aa313530bb732373aa245,\n                0x1c489d5d8b6a312d7e0b038709cc6a8a38e312f34b30398e5efe01da4f4c571b,\n                0x045239eeb3d5e28490bbb2ecadde5f93c8770a0fcce6d6a15f37902ddd93fa02,\n                0x2868346064d8bcc538161402cbd9c297872f9e42205130ecc9838a8f41599d59,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_12() {\n    assert(\n        x5_12([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n            == [\n                0x3014e0ec17029f7e4f5cfe8c7c54fc3df6a5f7539f6aa304b2f3c747a9105618,\n                0x2f90753e7aaf46c158cd12346da7dd37c3136353ec51525cabbaaf2b2350f9b2,\n                0x2e28bdc8b2c68b09da0cb653ee7e54eca909cf2ae010784554aa3e165b1a105f,\n                0x1d6a97ef87dbd3476a848af45beebe6b5d79cb047b37212e3e5839f1e80b397a,\n                0x24e23df24b19b75f44218a08d107709d35561bc1b982cfc317d54568cd496519,\n                0x185a08e623b85e797844191a1f184f7b8fc486253919eb20f1186a8331757018,\n                0x069ed78df853a105c8949dae5b4e81cbe370e8f6e25735a688aa8ff3df9659eb,\n                0x284395d79b64123211a4a59b81a90f9cfa8d8314dccde4cef22ec1e31431efd3,\n                0x0f24be5a8c95e3504ead0da9e792b77d7056f94461d69b04b33ea5d239f8e444,\n                0x022469ccfef0ce5a237518c38dec31fc2804e633b3b365c23a9f703ca31ef393,\n                0x1fcdcee218d5a0101bd233d572f184964854d445ca08d2bd6df6ceba5651e322,\n                0x0905469a776b7d5a3f18841edb90fa0d8c6de479c2789c042dafefb367ad1a2b,\n            ],\n    );\n    assert(\n        x5_12([\n            0x2954cb9ff6347d5c499f1fc52db830ea8fa29f01e77c979c5611ae2aaae0e3de,\n            0x2e12b253c9034b6cc304cb4420dd4bf63c9216a8db85b157b55f45570fafbaa5,\n            0x2de62fca9606e83d76d60bd222c14d4413e9fff2d15f8864a18586b76b32a632,\n            0x053aa142100d013792bbd568174ebef586796425b95544a3f6a206a634be52cb,\n            0x22e8c7cd6ced3be1e324aa7ec1f6c7347c849792e943af4a6d20c962df7a8e00,\n            0x13a81629feaef1e972cb07eb6d159532540d824adc6447dc68ddd3d87f57d767,\n            0x2e28fe5682677d8cf856dac08146a2be10967e4a4e4f4566997862b2e6d05b2a,\n            0x01d5081e49390999b33ea02ab069f0b8855d3fa8bbfd43f9121b4cf28783369b,\n            0x105dba4ad50f65b112ba7114004c8e78acdb8d82e503eff0bbdce42ae5ec7b31,\n            0x141fad864e665d79d8db92eda98782ffb2b2c2f9a3614b3fb777c52415e7d8eb,\n            0x222b0b923438c6a043369e9aa8eca0bbca03c6a27043cd522093da00e0f74967,\n            0x29a6fd647be4d6cd66d9a1113b7360370a4c6709218470c593429b96af7dabba,\n        ])\n            == [\n                0x0257f0ad69a35000c0f2098903aca10697d8b0909bd7e95f54602daddfec71ff,\n                0x2d9ef8a8b201f129cf9ee4778dc349d8f07fef770b637c599869d38b210079a7,\n                0x28f7af08ebbd432d38e754beed5388259415787336308d3368afb59a7afaf483,\n                0x05ff1f845ae26942c954561231bbcbe486d11910dffb70b79eb4623ba0fc6ef0,\n                0x040e1059dbe09077cbfc249c44a14c15bd76d593223daeb3bb96d2c103e867f9,\n                0x0aa8fe67e12b6fd4bc4f43aabf21d3e2c0527a0d708fc15537e49b8138fb14be,\n                0x1c79772645dad9c4b23063d6af5caa9265477748de8d1cd6f09d8e8e7f0bfa3c,\n                0x1da93a274000eb66d6f0745165382a3ce35f8a6984f4f013913e05294113d80e,\n                0x230a40b2e0b5c7f1421896cbadca811b6ab7bd7d550c009048a9a3f1b5102aa4,\n                0x19ba5c10d702746c2a91c418c7da7529fc7739ecc8b9ebb9930cf3882c734161,\n                0x20fb88db1e84b64a269d166dab1b4fb41eea93fc70e8ac70fba15c41ed94440a,\n                0x026a4a32f3788bf37504e335a6565b53554c80f61dd4affa003d399a704a8916,\n            ],\n    );\n    assert(\n        x5_12([\n            0x2668dc335384b37562764a5a19c9e518210e99df10eaadfd8234582773424edc,\n            0x1547f370a3afc9e04397c85b7a3c4fcb4a1a9a82c496f97a24586ddb2899991e,\n            0x301401729a06d886a0e6994e5eeb05df0f132f1e296c7c27ede1ae6e635badb8,\n            0x1f3baa6f3437051086ca888b5bfdf4fd52c0d7dd0530e7ac7da2e28f18a3f8a9,\n            0x274c0f2fe96c00f0b5a429330c5d353f11df9be99d647de5ba2f304c93c16a0e,\n            0x0fb1c188d5e118878c27d579087530bd62fac3244567a97eba7f894fbc769d44,\n            0x25954b4a8b7715fdba97363ab8eae609ffb4f8c4e21a95d0c5e33fbcd44b8e4e,\n            0x27cb4b4b9dd72782a603042e9055c323528979f9e7cc20b9e9732c4a893b0240,\n            0x19945581bc40d43994ec03b221b67bc066c0acad440b8e088e053a0c48bdbb57,\n            0x1871e044e029613b440f0e4c42f7016f2d5996afba39803537cd43d231bed230,\n            0x2cc3e85d2fa143ec0d4360f4b9e818177aed14aa1729abda9fa599895b255b06,\n            0x263692e752e88ca26f0a11f287bc6e34ee9293960a3272317306cedcae431daa,\n        ])\n            == [\n                0x2761fccbeda551f0c04e8b2ff444c1069d9f6b1ffbd27a6cdfada182ba8dcca0,\n                0x12229ab4e7120c8d3b6ce91a8dd6cbfab56b47c0a83f975c1a6e02f9e3d66ef2,\n                0x2f21544af0290c7c29df3aa46d799a0c0e90d1643598b45d6c5372699fcca267,\n                0x26e3da009605d1bba4a63c81b74274a52c61d0700084c8ea08bfd74fdac2d65d,\n                0x17de00cb801527c11534a372fcfabf0f671172b6e868b8d5be1c513065f3a11c,\n                0x1047b435887e2641c56bb84203a54971509ea420628366fa567588e66fd968c8,\n                0x165d2fb6addc9d82bf44c478ccbf2ab3f60d07eee609a4840367accb3ae309bb,\n                0x23fc43f57315da64e45970d84a4200312b65d7ec8c6778831e5f0bb03748bfb1,\n                0x2fce79cba7d35f3b7ded143dffd7f63ced3310a240fa9f8b87b3ad209cdcd999,\n                0x02f7c02befa262f3ee29bd5b7090500636c85bde0de0279166dd0fd9a4235aba,\n                0x0ca46b5a35de6bba8669fbeac600724eea86fa910dfa5e7aea6644cd874bf6c1,\n                0x01eb392b97282a8841f0aee92cfecab3ce141aaf895e011dec35c41ff483a3c7,\n            ],\n    );\n    assert(\n        x5_12([\n            0x12b0aa3d80398d5a38e8bd25d2e0deafd716d06d5b81226951fb503441fd05b0,\n            0x1b9dffbb066e42c5e5fe85e5850f542afb97ff19d0d9e336e13c342b1d856b00,\n            0x2feda7e3978df56ba8ff3b2f922c1dc14b1eeec68c5b4439c48fcb588dab04d4,\n            0x2412a693e4bb430dfe125d42dd27ef6796aa5243325c2da78de0f67387e6666c,\n            0x02173d9ff42d29fb20ac917034ca2b71ebe1c3fe601155505e5506f248a7b4e0,\n            0x0e4e6b1d12b4f45c77e827c9d3456a06f8e072549f5ad6fa306e9a43a803a605,\n            0x2150a663f9e09a48f2ebddae69702f805f876c4857e339312fccb02ee6ad7b21,\n            0x2e35e0cc3cef89f252e864a60c17a99a33992ea8dbb9c99c8d45d8a515499d09,\n            0x0ca9ed526f7bf21c7b1c94cc628da0bb5195a0219663dfb6205d3f6e58a64123,\n            0x283102b3b664803689b7455d3ac787e983718440d1629ab68099f844613bf82b,\n            0x113416a1d8301bacfdc5b45e533a93f7d00ea8882d1dc8a9f0dfd1ac13f8b138,\n            0x107b2566c5b160848eabecfa4b917f7a1ebb03e9593a57b7dd964fdd0263f221,\n        ])\n            == [\n                0x16a931fb7416d55742ae30f51abaac8b2d50374461b45bd7c0d3944325cd892e,\n                0x10ecf93f67f0a304cd49bc0701a89a649a22d407e7172e0d588e8efe39b9fc70,\n                0x1ef1c158ae71004e37af4e204fe4e8de4e09a6eda70526f8de2497a43a43aadf,\n                0x1d1d8ccf693996a2e6ee6911a46afddcfa21eaf13bdbd595b95da72de5cbb0f3,\n                0x0aa36ee23897734da0727d13d55a08708aa02b34e831d46351f2ddc697f90969,\n                0x0aca8aea0e6f9407a7e505bd4bbd17b236d960bde0de04ec8fc780b85db2c4d4,\n                0x15b91aade12b7ef464f05f0f2d1bb28e5351aae1b69b23459102fa8c749e8b59,\n                0x2d446ff7f6e277dadf83f087de11f06845edc688248fdafbde1d003fb67afb57,\n                0x21e2cdd361f7000d443656eee38424e84e6b8ea759f6166223104f5c1ae4145d,\n                0x0786373dd287cb1d1af2e54a065efd1ab958069279a0a42e2e902fb59c136e41,\n                0x20f80e49d40a3100f0e47d677efce1a5754aabbbe942a268f09435bff7fae158,\n                0x0de42ffbe0e04712b1d7d0f921567de60274c5889cb26ea4a843b3e8ff0ac7f6,\n            ],\n    );\n    assert(\n        x5_12([\n            0x06f913e735c17444995621ccb42a892f5793b5bd46bdf03a98b6eee8c982541f,\n            0x0574c7bd5902a962ed3077ff2e512248814d80d4ab986a333e61501ab784d116,\n            0x156f483ead068aeea616b0207af754c9d196ccde6a4cbf3c065a4a0d6cf8336f,\n            0x0c36eb86f67eda21629faa9edfe7161811affbc1c74b60d24aa07069f56661bf,\n            0x20044ad0f60425e723a914e7e1c24c795ec1545a0fc82d9772a33bac351b74ff,\n            0x0544490febb34958b8f5e1dcb49707b33cae9de07a14437fc19d076be4a36586,\n            0x2f763f8c88ead599291f6fb6b2d3638b8ab2c786d0c1d3cd4d228acbc69511f8,\n            0x0b27f81a39605a7a02f36150b6a4925178a1fd47fc978fa04d79998226e8393c,\n            0x2a7ea9a50b2d5ddfaaa08d928af2e106fd9310effa7c26e477f5e09b7766a87a,\n            0x23cefc7bfa7eae7afb78d4477e9c0dd80b9f352c2cf740339c2c90ad8c6562cf,\n            0x0e34dc8ad491c9d2a5dc1735e5ef048adc86e83263fdea28d8d6bf169b6edcad,\n            0x2672af63011515728922cfeaa20a049e4780434e752ee204c83495e5ec6a71b1,\n        ])\n            == [\n                0x168fa37ee9e60b2a56d222d0f46cbcf2a9df856988d85de1984da99c7938a19e,\n                0x0a73702bbdf479e17920fd6c3ec1dc23388dc682ba923b58ceaebd10e965f984,\n                0x2ac4fbdf9eb9b89fee2459c2f3b0815a202f00810102a71efb0a7af8b2da788c,\n                0x2813a024b1a4d2d0f7a84b7c342832ee114543d0721c0f64ac6dd38d4b11d8ec,\n                0x1dd01cbf89bfb151ff192e3288bbcf8ab945beca481dcff187e4d618912aba49,\n                0x14c705069f9c78085477d0e6271a3028fc91b598e5d18d80e458274744bb382b,\n                0x0f60201b8442b0bb2565efd1811ef6a676f1e2255fa7b58485c8462f6fba6a51,\n                0x2237f69bb366146603f4e99213a34100c68de11bb266753ed12a3db609301f40,\n                0x06abbdc76d0a8a44752c71c18f6a171dd7fe06a28bb2e44986589be9a1b6e154,\n                0x26b80d0401753addf90bcd9b049b1368e9fb319cd9d75c41799d55c57b2cc1f1,\n                0x0fca323792bb9dbb480e3a11815750654c819f9a65881632c6bd28bc565d3565,\n                0x21baa4015d5311a3bc0f3c06b2ef48ffec89381da52d64f7b514bfa4c019edf7,\n            ],\n    );\n    assert(\n        x5_12([\n            0x177a260bc01e2206326dad4ae268443ea9f9705eb56166656d4282182e48956a,\n            0x13a9fcfe422c32519591d2a702cea14eea6e86d596cf540f74e6e46288bd53af,\n            0x091fe67afb9b11c527c44796558c13948377689f5a0287ef66bc03c5cf5e7057,\n            0x22fef16b4f5f91be49cb622133c2a2810df4ecb92434c9ccc59fadd66f4f8ac8,\n            0x03aee156ecb1432ef49a275c47f05dbd418c0495377f9711ef9a475cdd6678c8,\n            0x18a8fa0bc6076c19f4de1dad675096485f2dd87f7d609a62dda31a190dd1a73b,\n            0x04e9d288d148ae100fe9c0a0fec1d380bfcfbecaf5793cbdb1f0ae63798390ee,\n            0x268588efef94f39d1bd2ec66efbcbaa874e8bd82c25d9ba3033667005672d70c,\n            0x2cefb1f70bfce0734fcae65b774ab4ae43d3ebcfe6dd8de89ed04d2ced55641a,\n            0x01f5dcd717cdb8520a7c5cfcdba85f39650963569f9f489f777c198795cde267,\n            0x05fe859357c4d9d97482e1e19a8ceea5643fdc8dd765940e671323b46839ec19,\n            0x0285aeb28910cfa907fc8997e86a9e839dc895f0a0e5784eaadfa963fc15e325,\n        ])\n            == [\n                0x1fd6005c290e81d9c34318a8adbd11dc97926d229d62857ccd76eaf410e71bcb,\n                0x0a81e443d16f10e0ea7383c8dc0ff87de8de5f90f98cc2aafb273d9b3a65dc2f,\n                0x3060c2ef68c8a51854e47610c28209e4dddbcdaa9d8ee59ceab07a40d723c792,\n                0x215cc5f37b3678e6b1d7e150690f7ab0062169a1220bcadf3016d8105f1e2731,\n                0x159ff7fa2d966d31abf6cdf41a6a3b574fcf9e9cfedd74a55ab78acf3e7481ec,\n                0x08ce401382ef70859aa564acd3a653c9b01aaec2c98b8437f9ed265303a660e6,\n                0x1ef105d5bfd674ee5c1e9484c8123d8bbc658c1346547b6ea008cb0ebb29f1cd,\n                0x1cdf6648a93f8f8d391c623a239b7bd0da434252d4b32e3f02ee01a96aebd9ce,\n                0x21988200cbea79d3ee52bcd026fc1bc6b0376b9caac771224d1a767d8d362cdf,\n                0x02b094dc06e309d26b5d6afc8f209fafe77b5cded58c661564404b74111a1f8b,\n                0x21cc36fda0788830adc7a7113a4909f9877c8357f926cea204eac3f544881341,\n                0x05049e36b9f79cdf36b6d1e9a61a68c9c863f8d40055816a1ec97acda3f9f9ff,\n            ],\n    );\n    assert(\n        x5_12([\n            0x0a354297f59aa014f9204280e96ca66b80d72a39a338c65aef8673cd113015eb,\n            0x2241a377f9b8ae774bf59d6d48b1035da05bc0095f63cc88045b4a6150327191,\n            0x096d075a1c648963c8422186bc33cc4b4312bdd7af67e10ff5ad88a3c6ca7afe,\n            0x196dd3fde8e4b0a246636a3a729f9a9edf9c5be51d60979a031b74922f29865d,\n            0x10b42b3ab5dece6450a23aa00cf1be5e982fc9fa50695d672a62ad6823cc54cd,\n            0x12e6f93b0c38eef45bead71ed2c20bd370acac6c144ce3b2fb93f32b9d3ac2da,\n            0x2528654f111a309cc8dd885cd49c3c075682d7a683d56d9d5f2d66da33caec30,\n            0x282ae441aaf30c2b08e0e0bbc657bc37eeb00b9f94c326f81ebdd5f1d7193311,\n            0x2d2fd1872fc0aa489d34d8726bab7d4db12c0edf4a0ceaffddd547b4564df0fa,\n            0x27f0c934ddfae26f31f1ac4ddbd61539320ef641e256efe6ac45a81c6a5357f5,\n            0x23ef2eb57a5a9a5e544a41c786229d4ca7d601bb8bd53981bd79bd67cbf4cb45,\n            0x12a74499eb59691ce7cf48f8725d4097082a9281a2c2b5f54e4d9a9341969b95,\n        ])\n            == [\n                0x194eab2c8b53787a84dd6e88590b591db109c63bdbcb4dc180e31d1031a7342e,\n                0x2118c1a10302af8ce58b29dd5b32ff8f9787f54721619c111095f3327f6a70d2,\n                0x212f12c1b70f000983b1d2272838230c69954f5dd7d197fb0d53cd4cfa80fd0a,\n                0x2409845ae9673176bc51ae77ddfc98053cff90112efa3dc67fa5e07cdacb1fa6,\n                0x22abb8e62ab7f47dfe5ec1d87ca8381a63e7dfbe26d0eacb66040b472941278d,\n                0x0eaa0d6fbcc999cb08aca688d4c4c3a5f6b65f9f6380ff6f744b2d8b288252db,\n                0x255cb80c5ce5182a68536ffd6ad4ebd98058836647d8f276e90e71fd19bebff1,\n                0x123074efc3df4076da754532886d7c37e3c3eeb4ac3879b0e225466ceb735967,\n                0x0f3f4ba00481221e9d34f5878560f932ee12d045325df064c224f2d8db8551c3,\n                0x256915e6e98bb1e24a1a0845fdefc7c6a53c690e94c39ead0c76c19a629e7834,\n                0x1936288460695d01815205027a3892a23649ccb9f12506a47ffc63d8c35ad7d4,\n                0x2fb218ed949c4eaec724e1f2ba132bd4e390c9ff3b4d28f6b328b2387a8b9934,\n            ],\n    );\n    assert(\n        x5_12([\n            0x038c3a316e56fbfcbe9cf422c1563a0551b6f6fb6ca764db2cad53ee63c06c86,\n            0x15c3f186965de711887fcd8ef5b395e97f924941134119e21d204a4e1ebc687d,\n            0x26989306c28e62da14bfe4b08459b27483e6522eca75b0938080048d3d34daf4,\n            0x1d0e2c7034504270f703809ebd28af720fe2ee1d08d681e1ab00db3200ed9664,\n            0x201ba1f00c33a6b1a7dd0f774b94c6378bc3e4a69f6c018cbdfacf019e896791,\n            0x09d545e35cffcfe4fae0d83fdfb2d3c2018fcb0338afda6d0a74baa4f1b8098b,\n            0x0f002baca28a8a79c2e1f4f68c2f3eb6d12409ac71ab33ca35ad528f018dd6b8,\n            0x24364b11b5769a8ce7253f6fd6d1b948410173285d276a5441a0239f483a0df0,\n            0x26611dc5eb9bdf8b12ac7493cc531e3a8d758822ea2c4b687611abff37e4a560,\n            0x2b202bee34a7958f47448ba49ce44bb535ea9835e72a6b9726ab59ebbbfd1d49,\n            0x1813fa6108f51d636cbe5a23dae341506442c5ef4f327a9b6ca122e707f7431d,\n            0x05b75d9774d263e55429b82ebe8660d7b28a0e7cbad28a1533834641c1f47969,\n        ])\n            == [\n                0x0315c8823973adf8f0278ac8112f2b04ecd95b87719463c4393573581fe0d6f8,\n                0x065f4248729ec96b816a59af7d1b7df71df49c58cc2a9afbc0395bb3ddbd6be8,\n                0x1406e102b472cde209f5c37213f62b265dec185dbd631971cb2023d985d5ce04,\n                0x04d8865d19fc211c94a232513129140c0f86306623e36f117635891541bc6263,\n                0x0d9577e818494042f48e998aa57672f620bfeed5e89f6b929728743318c3bff1,\n                0x2d4fdbc297d26614016e31cc6b51be3e048efc42ffb32ec878d7da8366b62e12,\n                0x1e7adfa1a68b390a0d9b681b9b37e0fe773038b84f51dd2239545d070c7f9c13,\n                0x1f7137c1db6ed9c608cba8df75a131bd8173566c80d7c6f0429d40893bbc7cdb,\n                0x22b3c88196bb3cf52d93cf0505f3141b01a9d696f9b75273a9ed29aff7c8c7a7,\n                0x14c1c9487ac3fb49fa10efada3e36dced10487077ff24fbbc1c6859fc4437378,\n                0x09093266b2846e1b72402111b6207c45c22ea66fd5a12c9b451ceef95e4f21d3,\n                0x255d822cc1dd2aed4245128fadb29cccfbfe65c02e6adbddb5af28f1e7317654,\n            ],\n    );\n    assert(\n        x5_12([\n            0x2cb1a7dc7f386ebc390c83c64eb12d23d6ce767d27d96935a9247e32812fb7f9,\n            0x0cf7df2f03aa0771560d176d3e1805c34873c5a7fc00c872f5102ef7ab5bd550,\n            0x28b52e69a1ffd2df7f6812a11207f1543c7aa0e40c565f051a721175cfb8dc03,\n            0x18fa26f37810ff1d6dde96dc5fa3d488c213e18739feb0a52d7338dadf00029e,\n            0x08ca33109f8fb4ce0ab6395f90577abfdcb8658abf1dcf300e06f507d7dc1948,\n            0x1401ebcd255db5d34fc562cd00053a1a077c8c1ce780a2a41004a726877d6a9c,\n            0x1b41a43c3a4559c4d13ab91093b9fd53520dd2be02385db4d622e42cffcf15b0,\n            0x1456d6acbd7c08ca242c4dc24152db5f98ccadb20fb4047d5197f900dc78f577,\n            0x2d0e37473c0f1d3bda010e4136dd9d68ed347b23d0425f79921fb57721d2666e,\n            0x0165e900128e5aff68b7db9d0add1c1615e1c1b309514d400798131c748823ab,\n            0x2e9f73bff715be4ef077978ab0c7c3257e74c9e09f416a9d2c02ccc7dc631fbc,\n            0x2546acfa813df1d7bed750425da06ef3971c6fc1378ebd349dea0a15884940ad,\n        ])\n            == [\n                0x0d94945223c7d15a1c19de3b05cc406cad22b679ddae9e6f14ae083a3b629ea4,\n                0x1dd61aeb528386b7b712092ef4a5e298c3ab6374d7b192cb5fde14fb0cca5dc5,\n                0x2d7a2d302733f8dd024e0b0c0a730256ac851cc585f4424e0946e3b811d6fcf3,\n                0x29330025d49a6632ea66d245af5fed97600710f757389310a30bb772e2f86a99,\n                0x284a71b77bd2a264443e4d94b073f2be991d1f16cafdc4536df1411ccd547f3a,\n                0x11593ad25beacd1fd84db833ed62802b962bd5e0c40d70bae9a89d3c75c73642,\n                0x1f241e83d36b3f8e365b6d5e2804678801eb427cdbc9eaacaee1d4b7e847316d,\n                0x26afe3cd8d36343dbc763ed8e97097c555a6982094a0e43c6ab60e30ba6a2342,\n                0x2f0fb792a6860a99ea231776cf1c356811ddff2f95a8bb3a0b122409434955fb,\n                0x051d2c3dc512f089685de894e4182d701f4753cf815d2b509c0ac4c3adbcb011,\n                0x0e84382257339dad52727c2ae9017a298f47a84df54e20187c95f1a411af76e3,\n                0x0dfb0fa8b51ba9c7a88504eea234dbb963cae0d7528bc01b842b521c39b8120e,\n            ],\n    );\n    assert(\n        x5_12([\n            0x27dea82d8f6011df0fb78da7e82e2a13a22f566bb125274842ee68c942ef7553,\n            0x2c7efbf12d19e481fe927c5cedc2ea0ad4e7f3a461501e5b8cd2d559b7d848b4,\n            0x23c963940566be144921a594c3fb1f65068f8ca74fd2102b4475a06328c6e9ec,\n            0x05131895b08c5568114cfa055e5fdd9a43619a11cdea859ef88e40406b10e70e,\n            0x241cb1dea84f0fd68f06eb8e2b37425b017301a93b42fbcf01fef489ddcabd50,\n            0x1c19a4160692eb67a4e98f0c1ec74e34364c8e2004cc06c05fa29a8301db0599,\n            0x1817b5d0a05e86e72f9827f4b7c857a8860ecfef963b18ce965b8e039f075ce9,\n            0x012faeb2c72841492df2192a637f27b0d31a20ca554d451fa2432f953747f6d2,\n            0x253d1d4759f5ddc1c15401bc232e6041e8e7fe7af9d55646a9285ca0c1bf3225,\n            0x226f9d027230383e36b643d17cf11b259e25fbb938d9381b3cdcbdde16006186,\n            0x0b1e4e3b45c23370e9a33a44965b6ed9c70b3193b10f9fa1ddf61747952bef9c,\n            0x1da8de91caece3da1f98e36523b57d29ffea0f5a0364ae04fe6384bea8421789,\n        ])\n            == [\n                0x11e785574a8422eb0a7b9974a4704d2d07a8105268753a96abb59ba492c68d44,\n                0x2d655fb4b6e277d7651728826bb37d7e636c1dee8d532c3e7dddd83d610a6ec7,\n                0x091b41bdefe0e8cd69d94e37eb036f2bd89c82301fe73ec875879bb16b6c9ed2,\n                0x27be34771f7b56c9eceb72e2cacc6c81f18e2317ab1de0d6b330c78ec4d25c49,\n                0x1810db044a8de7cf325fb71272cc1b159f5c7c2572d5a2e254ae246eca122ca8,\n                0x0b9e2f6caa86d76a496ecdaa802431d8e7ce640fb34671f16b59d43719a181c0,\n                0x2d54f8498ced37fc8a89dde3dd4533b229d5afa9f212108b31e7e229712eade9,\n                0x142c4d823407ce1a45cf7204e0bc3afaeb7dc99ecc19a05e2ce17cfd0549e81b,\n                0x2576c6e7dfc1b1f565c01d9ea548c960c94a2c3cf9fafffdc2574db6973df1dc,\n                0x15c96db01380eade5c28754ea21abb2ea9051ea8bd03a74c41f5562906376ed0,\n                0x0e94430cbc9671b09b1a378684d53c5e38181585dac969ee6afd72ac2fe80d52,\n                0x08ed6b7f639aa70211b8aba5e661ee0309ec827690a9472d84f6e50886af4d41,\n            ],\n    );\n    assert(\n        x5_12([\n            0x26e19349657f94d69ef38f895ef34f6cd3dfa6677b8f083b158491bc9d019325,\n            0x10a908d07457a6b73175c274fac62205da9696826a4d2ae29c7d95896c74d4c1,\n            0x1a5b072d9790d06ec111e6220a1505f7a7bf604325634738da0c17abf980b4da,\n            0x23c06f97c13ff15b47a5498b081aad0e853e4c606b920430dc8f74147e1813a6,\n            0x069b8ddaae46ff2333637161daa57868cf58348528844f39b1c9db77556a6f7b,\n            0x0a2f40d0fb59d436d45066a15442aeb5a779ff5c5901761499e37c46e04a0829,\n            0x240811d7aacb9e5bc330b6c2b87048efa021463b33193d6dbeb0070fab3f12b8,\n            0x18025d1b4cd88a705ffe58cf9c537441a46c730e549967f7714c3d879c8f632f,\n            0x00f8aa0d972181b48333521e50f58ae30f76d524da5a76abfb55a34999d30a41,\n            0x1973258be07ec6637cbb9068b4459ac04eed5e6b5a82d24f5b3e04d8b4e4b573,\n            0x239d3d9e7599144aca6dab517d82df07f99a80fd8907ac590626ce6c8752ada7,\n            0x0205b13226797036e6099fe4860572e772c9e6a741b6dacc38f823b6db0139e9,\n        ])\n            == [\n                0x237d0dbf07704544f78073b01b7551f4c91a9b830d87719efddc466b70482fdc,\n                0x2e8753b472abc3b9950c82084c89fd6315f2e18821695d5d7748ccd55e7e0f8c,\n                0x0dd69fc03905ed5a5b9e8f1698cd25757e8fb62d8029e6e1186cda5ee8cafeaf,\n                0x2035d4d8fa26e694a2ef3d21dc5c5e37f1f287e0e89e43e84730e59cd8e567e6,\n                0x17c1631a572db0572bea9aa8d42e39091e182bc7ba125b1b69c482c7388085a6,\n                0x2fdd08a43d40740c7419c28785951c220cd078e8678332dd875f6b15b816d21f,\n                0x2eaa4630bd3804b09117864bad7d138c43b0f8098b75407c68d37ec98f5d860c,\n                0x1475cad03a214e262f4e0f1b70993c068f0c9e508075ee72dac7a91ef5e85fbf,\n                0x030767e78eee3e7a0a33432482a6429d5cd01f5b3cee823ad789d53492110d5d,\n                0x0bc095c941cd2404b561304bf3cd2310f075f55e711ef0e96ba22b8a7e91fcb2,\n                0x0772fc2464ea3d268900b9fcafdc13dcaecb6c2deae2b84f0d75fa5652e42d91,\n                0x29dcba74ee5bb080a8e156999617ac14112435779afec154a9e08c36d286947c,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_16() {\n    assert(\n        x5_16([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n            == [\n                0x0fc2e6b758f493969e1d860f9a44ee3bdffdf796f382aa4ffb16fa4e9bcc333f,\n                0x0c118155a0dfeca3f91faf14a350511228ac33743be91249c6e0b3a635a50de4,\n                0x1a02b3a6571f22bb6392322d3f9f5de145b4f00bdf483072ce6188c30ba0f83d,\n                0x26631df6b2522ecde57413cd680ed590ded356e1c680f865f45be8eb960d1e06,\n                0x250ac4dfed40dc37bac9abe46f7bff3a80481d52a157ac80a1e5d39a5ed60e18,\n                0x17160980d8e7d9cb31addaf294cf047768bffd9fe433e8903b4ed262ee913f5b,\n                0x1d708a9f0995c2e0cd2f55e5dc795126f7191a0eb934ac8172bf54e520361ff6,\n                0x20721a18915e96e37e12c9697427f34d6a366787ea94ea65565c36813a0d77a3,\n                0x08671a9e58105eed9ac673249dcf22f08f098e3c6eb28f9eaa55d67d755972d0,\n                0x01e879484303c6d057128fbcc3a4222c779a62d3666df65d4e0b64c8031d7cc4,\n                0x239e2ce87955ebe19aaad000b38725b729f51175ab7d688f15d997edf0e3b7fc,\n                0x06be612f42b3ebdbade3fe199338c9118eb6b5fb760bda96e45443f130a8b2de,\n                0x11b2c04b4eb9e4844e5ddbb19b56059a815ed5d69405ba51786961235d5f073c,\n                0x006da33e2d57616c0ffc855b48d225a1237c3d80fc7e6b6e73b74e162b85c8a8,\n                0x0ef50c2615882523c6c73a69b4371332a066b2dc4b9630f186db47e3bfca88c8,\n                0x0e2ceb1f8fde5f80be1f41bd239fabdc2f6133a6a98920a55c42891c3a925152,\n            ],\n    );\n    assert(\n        x5_16([\n            0x2ef5bd70482d1d5bce16a04a5220175878dc715c51070672fd79df2f36fb719d,\n            0x015425a96665c5004e9210cf6828d8019c057cd587408a27347d951d9dffc2d9,\n            0x1551585c9c4cd84962ce750509aa7c10f6070167cf02f413b1ebb99b46070f9d,\n            0x13b3e781956e21bfa1ab9b729c8870cd6834165331261b613ed155bec20c705c,\n            0x1efcc38f5d29388649ac90a53f2f18199b3b85b18a817e0ecc35fc8bc0c8f935,\n            0x301c505d503072bf6273b63ddb8ab6decf288fe0ca24e01e9d29d1c2b445840f,\n            0x1d0f515363f3f1d7a730fa40ee5adfc9dbc64ee624f748578583724b9c950d4d,\n            0x08d0a79b8f7f9900e653719a0fa83eddea4cb60912ab072a7c53c5e06be06f57,\n            0x257634dc118a69195eba44a7d683b806b13b6954284c00df03fa6fec498d7136,\n            0x1c3a1e671b80722c3093704597f0682648d4ed2edf527c394437f83455c6dc9f,\n            0x2b9b5fa799f3e7e3b25f5789aea0ad85cf688df558df55cd5aa01e08ad61a0f3,\n            0x2976d9a19d3daaa5d4754b07212dd1790e1a2e792bb1f3f3c1fdf29cb9876a0c,\n            0x024e57dba7a40fcd9c055126821db288671ca25c7a2d331f0a44aafd281c420c,\n            0x2ace2b5e9b3840a1bf285ba01256a92c847585a0387d82959331e1ff831fe7eb,\n            0x095eee248104564b4123f8b16cd2e659a84ee02453ee37267a42d29fb4698efe,\n            0x023a74b7eec73c64bf4c824bf7b15004252f23594d733e8b5e3df99057a1a402,\n        ])\n            == [\n                0x199f8c0ddd4fc19fbabcce889b860aea0840b953d7cb9897a24c03aa91321f30,\n                0x0488d23f20fce69d1c4f405f407987c50e605487002856e3d100a531fbef76b9,\n                0x263a13c6a63a36b7f83690126f3da9083932a4c310fc8273faf7fc7d4106a61b,\n                0x0c819a478981b1e3056aa6eacb7ca03c75df4ef8106dea2e920c6a30ee6eb295,\n                0x186a0cfec51820f97f3c64ca9a3f9fe84d728c3fc65298308db8c252e7763d2a,\n                0x1de58fac635c3539da015d1ae4f775af54ca361c1bb33949146ebc92ec08ed05,\n                0x22cdb2286d74a378ab0e73265d8ea805e70487bab78b09624fae0111e72e7c17,\n                0x2a530cf261e7fa2c5610fd39d40e5363d238b66127bc4da42d3c3e41252f2746,\n                0x1435915959547c0b78257f1ceaddf744d24f20054b06901686a409f3fb7fdd02,\n                0x07d3142e793fc9b5d09fb56da48bdbaf9f3b0c0a60e65c22faea8abcd81fc68a,\n                0x0b68ef91843d5f6a4d2c9274f6ddaa7bd6d78677502d1f2f6b220016fa569b92,\n                0x08473d26da0495891ba80a6b8a306c62d0084260690ccd9f5528a11bf25d18aa,\n                0x2a6c3ab5f6ec231bfab2908184025cf5107cd9231d9e24bfe4676f93e4232528,\n                0x1e7b9102952e2c43c201ca85d589c2ee2f15a0fc44d3c1b14674044b4380f9bc,\n                0x3013bd07b9ff2be6b049d89513b0a65965980986383a64cd5dee34a1f5952917,\n                0x02bfe073ffc8a0c7cc5c2887333dfa9252df70099500399034bf491bb4cee13a,\n            ],\n    );\n    assert(\n        x5_16([\n            0x06b55384dd1f8432d7a1c51b5a6233347e1a01d6ccf71e4df8a97e6acfea494b,\n            0x1fb69c58f691a3f1a356ff552ff6472e1159c39eca1298ff6692ebf1221f21c0,\n            0x1b57c97bd134be1d2ad6ee333fe8f0edb31fd49777b62b78f8ae06c9fda9e4c0,\n            0x21147db82f08d38c7f0041c175f162a5c446de7358cfb084b0290da8eed8a6c7,\n            0x05d9295c10f3f4d7dc74e642e028503ee78745e579cbfa3f1aa69d51921e7f2a,\n            0x08b7ed23161d249564b4fea706cfd77493bd09177077ff0e0c37c708c9137593,\n            0x0f6088e95561f9048541eac5e33fe33cb0a63531feea3fc00158956f4b3cc005,\n            0x231f9caba6d6a31d08fcec1da6c51624fe4563dffdc58f8874cb7e466c98dc50,\n            0x2da993dfb755a6c0c91a1253ee0edc67da208952f85ee94bd4748bfe07b7dcf4,\n            0x2b570a865c287eb3a020b7c5e8d6f9111d77624b77800061df004bc4840e69e9,\n            0x1073ae829bcf6044b33dc5879e01e2e85dc2f555704210a9dda4b1e1540ea2d3,\n            0x2ddd9346aadd09f246abac523816c59f66742633fff2f678556e08620e06b885,\n            0x05c56534c601f945933edbad83040a988aeb0c807891be8270571d942af99cf3,\n            0x26b1a1a534e46eb0e05289e4212b98b3c3c9f03ef2e6d26c85eeca1727ab8628,\n            0x0be9f33db4474cc99f5e835083737dde85a90a009b4d0d06afe4e0fc9230a2c1,\n            0x2bb8306d7c7ec521001e46c904e4761fe8336f9f1fe6ace0e1b5b8b1f473af55,\n        ])\n            == [\n                0x16870ef1a96a29aa6f91b1bc5f129795424bb1651dbfa593b6d67c45a015a325,\n                0x0b61b9d5c43ce81a4101b1a0cf6fe7e8f04af3f8c0af1c00661b89f70addd21a,\n                0x26ed8fb676ab100a0bdbb5835e2ae78378dc93af64926e79ce6b4f67f40a9f2e,\n                0x00afc78c94142cb0b383199db78411ca62cdfdc7642c262b50d82c9e4fd9bb2b,\n                0x100bff127ee5f3050e32522e45372280894ff84b2d73ef46f6b0a0fdccaf7ff9,\n                0x12414b2266a60acf06663ac7396712445676cd748589f272ce0fa143a503af20,\n                0x0bff1c82da41aeb1e380e8fda26480b010e054739d086bdb1236fd173166c032,\n                0x1e969d843bc4ab33ab1ee96d266d57be7c3a401660a5005f2e60378f20913a2f,\n                0x05848e0592a24fd0084d974d1ff4993a11a6b421ae3483bc3c875ab8902c52da,\n                0x17c202dbd22d4ac3d67ee56f02c9a7f707962224d1627bb40a6d780a6c166b09,\n                0x24e7c391772e5cc73fdc171313791b86d0463bc51e7208d4cfdaad7209bf8281,\n                0x0e206595d4d2e3ddb5eb38d58b0bdfa5099b4968a5239912f2840355c67c02ec,\n                0x26323fca2471db34936ee8ec5e48e20de20897de79170ef2411df3e438be8739,\n                0x0a4e622b558ef6d52c7cd3eaa99dfbef28625d7c6c97cabd4f4133c1595eb51d,\n                0x0c64abe0b9786cd362618b6f82c51759cb62844cf2dbb5d42c46f219dfe0f2ac,\n                0x13be1ac72d72e5228b27c42bf32e0672c9cae552f97b89facb63b940e3f8eacc,\n            ],\n    );\n    assert(\n        x5_16([\n            0x1cbaec6b27c2ebc5fdb69e1333798b981dcba6b38391557b7ac7b9b58d0f66c2,\n            0x189851071e8428ff3c8a96ac2ddb17ed0880c59988c3fee8dbfb62e195867fbd,\n            0x154f46875dfe815d037f8c06b2067e2b5cce8b77a9464a65ef2f6e665652b293,\n            0x210f88d63fa89778096ad54e6c0936d8f4d2453536f8f86b83ef5136ff2bc98b,\n            0x041e749316da9c8b5dd8897666b38053a14242ddc349d6f327eaa1e42ca5b570,\n            0x3021a34419c0bf5d11966d97e65789e3c614f59cb295c26b03139e59a053ad2d,\n            0x153dc912ce0688cca194db013cb5af4bf76dd0bcccb59803d6f47a626e838629,\n            0x145ef2786cf7f7dc887e77cfc268fe97d0ce8d3dbd62bf349dd28e8f2a77b008,\n            0x2d284de1cf215ed8a1cf131eacd8f192ba61c98383d2856696da2e670a5b23c1,\n            0x258f58bac3d054ad5f27eae324fa6fe5bba15ca5b84c93887aae8bbfb81488c1,\n            0x1312478dee9197edff1690bf7b350856b0f6960f0f4bd97b1aeb1866f0e6697b,\n            0x0633a7322a72259ae4201daf36ff2dfe2465227bf3a0d521b7b6aab723db6c1a,\n            0x1d712e293228228b7f0b05446a2f4b27c8746711f59ed13bad7218be7aad98fb,\n            0x11745f000bdcf819b4ddbd377ce1d9eb7c326025159c771b055a7ac41e46eb72,\n            0x1fed00452611c593649df2ae4c8f83545a897e67ed2d9acb028f94d114810505,\n            0x2525294c748d48ab2b1f30a660c134608427b3be80a4d72ab723b17d25ed5d52,\n        ])\n            == [\n                0x2b20cdac71d0877cd2ca763fd3b97286a7c6958b9032ff694f7f9a0fab0e6195,\n                0x23aceba4409f64808b72fc225720057fb9bf610fec117d3f981c8743884fcbee,\n                0x08662d7bfef474d3ead01bf3c94fe4ef10e70baf5f6d1cf3e07ce4b6853f66ac,\n                0x0bdb073e51bde89f93a65cbfd98e80ea7f091299ea93eb6cdfadfcec86757077,\n                0x2c78c4dd3279322e16ade03e9c9391b46933d39d5d38d12e6f390b50591ca9f8,\n                0x2d4d8765fb401a33b156176d07abbee282c9e7f5a87a1b6e288d5dca2111d909,\n                0x16a8cf0704071589af3113d86f0b3d0911a56504392015f5adca2c02cc73ccc5,\n                0x055f44503d034bfe2a2699bedbd15681610407737fd8dfffc1513fe10f39b289,\n                0x087742e5845e1b2c965e7f2bc5b408cee716df9c019fb7a770138d5d847e02fa,\n                0x178cbed7704d0d1da3751950067f811e807ffd9c932a7e8ca5d640a41f596f04,\n                0x1bd115492e405f8d46cfd0f60404ad75497aed79a906ec85a29e396f69936ef0,\n                0x27a5f932a5d1078475096c225559697ff8ef6b1a99dec900d802042b71b41987,\n                0x25f29fa8ce03cd5248cfcf4485993eb06d6c0f3223a9ee97af994688bc6d8208,\n                0x0120aea7c2e569bd1cd3ff49623c9d71e0b98e569659802a6ff1d93dae4e4ad0,\n                0x1b8c8cfe6aa076226c4e38ea6ce8407e1e1180720c6c033e041822a809172253,\n                0x20676fd2b77c0704dbf127d2d57e4f3bc12f91a8097c3e99b7a38e9b2e600239,\n            ],\n    );\n    assert(\n        x5_16([\n            0x0aa86dccef554a9a7f6c92f6c0165a13f7a8be302163322a6d5f711eb9e3845d,\n            0x0a190cad0005aa2ce4a7cf7fa9a62653d3f3a43827fff30110fd020402c53905,\n            0x164cbb52ddfd371ffa882dcb7439e0ecb65f82252436ae949192267587120c4d,\n            0x299cad782ce98cb776b5e6eb0f4b14c6cf9ac946c456e42c8285b697e3c6050b,\n            0x088dc71bce272415ab0d566f058612e22395a813a883f38db1822cb18b267009,\n            0x2e1a2c50ad4ab0658989e698e8f5e44e6d6430dcc58b72d2411c670eb2503eeb,\n            0x20b75de40aa801f2d32c39f6e7047f160488af0a746b7b17093f413ef51d2890,\n            0x0ae46fe3de0323cad20b5406bfee689dfbc9d50ed8001d76da9d1690dc396b92,\n            0x2089eb57a6f3fddfddcc41c1eb802f9a01e05f507031cf884329d6db8c7e2bbb,\n            0x1328bee68b74f2941de5e0566a6d512f1911a499af6898269d711c5cc5a571cb,\n            0x25494cc367bf5e4e32161791117ddf46b07f1953a884f32f5cc538bd9593cbae,\n            0x0b9296169e0ab77ce037b47c252113c58a5df01a3cf1578b13e8c5b321311bb4,\n            0x183100059e377c7b243ccedf3fc23fb155ed5033a418ef1918171442bb980623,\n            0x11d7d6603136f4524c6f56871d3d6b55b34535181e10784cab6523a9e22b7972,\n            0x262b84aa27a96cd7969bc7a159bcf16ebc47bc5796ece3990722e8a3748488d5,\n            0x1ce939c908883e403f196b23e35aae5318fe443f56732c7ae3e2e6e8cfa8fb9d,\n        ])\n            == [\n                0x087f30225a428d5c33a5f30a20e144a4bad98168691c477a5d937513c145ac42,\n                0x2e02134b3b4c94e8225b7bda60deae0c941f0d8f1046808bd0bbe6399eb1ca15,\n                0x152f5d1a0c0d5d54478de754fb8749b7085809fd00c084e367798ca4266e3a36,\n                0x2765d29175aef99be7800a2bc4be36b70a967d2d71b717e826d42d996fa36b27,\n                0x0ae1f733d0dde6cfe966688adbbf57d158243f8241cdd4f2ba3a4ed3a33f97b5,\n                0x0ce104a162f4a18b7987c192108df72d8d01fe734d8ff37eba67abc3011b431c,\n                0x2f90f4b7bbf3803960e5d0135933a5b16b95883b0ab32b658e5bd144f7a6e4f2,\n                0x218bdb3f6179a9c2749e5506e3ea3abc9134e1adc1ea964d38060f10d7b842fc,\n                0x016366359c1a2491cd62fb3fc0dff757e731b36149aa71d17ca09e566726cfe3,\n                0x1c3dc890ded994bdac60f387495ced2a17d3cf36debd0b6552726fa18559ac04,\n                0x1280cd57db233133595afa3d60353b3e2bd5bc204bc004598a4c6c4177fdc230,\n                0x051fe637e05e3df14a490a6361c49813eeb572f1ec0e9cdf2bd1b083a3bb4690,\n                0x120f57aaa9a2d63ea48f48d66f3ca7b49bfb2c643a82345086484f07c3d10a9a,\n                0x0569b317c695653ea95ad1238b4c27849cd83fc9915e0942bb5dc04a09b83b22,\n                0x1d8ec58c597322831f4d7ba4cdb1854b16e4a1d50b3dd5d50f5a831068317159,\n                0x11f9675abab82860419f58f50d66788b10c925bace3c0744d4b35d2d705590d1,\n            ],\n    );\n    assert(\n        x5_16([\n            0x1f215d88b7e0d178c8fb74da91021f394ca93b27c8492a2864916ded48b7d7f4,\n            0x031a1f5e05f55ef8abeef5ad6441e6dd3216715223dbcd72b81c4f8bad05c7b4,\n            0x1e7f0b196954bf7434714f11608fb1bb75442a19baba47a538815c8094a4a13f,\n            0x2be3508f3255fdc6e87ed923c0efd1a636015e0300c7b60961413fb1c7fe638a,\n            0x1b57649397840798aa1b82ae73879f3854e93ca5762952136f07af4117b664df,\n            0x1ef0f16ba5fdb90a989f414e49644e591f6ecedc58e932b2382ff136e86ee1f7,\n            0x147db07a080e692a95b481b01fec39845c2663e2cb169a7d31b1968a8a8f91fe,\n            0x1c1b51578fad85b1e0ffc548ecee7354deed9bc75fb45587a6c9cacac3df063d,\n            0x08d54dd1583ec89851a7b6c34f0b684a8a2f2ce0548dbcf3d3f0f0817ef46cd9,\n            0x0674f9986e4f58e1e6b2f66e44138bc1ab5e62d1088eabd0768d1ef294f14e26,\n            0x0b30b59f455281a391c44098a8a25e00ab0f0bee6bb6b6f0b708868000b9d32b,\n            0x025646f735b1b00118aee20d7c8915fad5ac40183cedecd7663ba4d9e065ce4a,\n            0x193a13cb2f3bee2ff69cd7d2abfeee46b0e36df272a405cd13ee20edd821d6d6,\n            0x299c2b6a27955503fffa9ed3dd8d442a075ba565b1c9a063314d8e9f2ed4a776,\n            0x21847ebcbaaa7ef15a86d70147cb83568bf13deaa9616bdd193d9cad4f700e03,\n            0x212bd19baa0935e3533da9d039c0573c6cc511d86ae155e3ff3824b09a24bdfb,\n        ])\n            == [\n                0x2d77aba67df78b757cf497916e42ea927f54c5e31328e6cf1bebab015c52091d,\n                0x1fe50bd2ce720f50a5abc9cacc5e642bf9f0cf48674ce0555ee74259553a4502,\n                0x016149390f59f06de6f97e8a0ba28b041819189b5f92909214867b8e92df0628,\n                0x1b207e3f2968d97fe5602898d8c5ea1e3b950eb44d377042ee50f0fd64891c66,\n                0x198ad95eb80134726e88e82db424001636458d2d5a6f5da69c940af1d61c9d45,\n                0x08c5ff8ac18ad588ef8ebb581cdf38356b94b8cf1ab542ab63f198c13ad3cfbb,\n                0x010b0064966e3457d4a908e9598c6221f73ddf3989df7341f043e7d2df870c93,\n                0x0d2bd5aaed8f574f0ebd0475f7ec3babce372fa1786c0aa36c1ac4cae21dae6a,\n                0x04b2f761bc78dfcf0775a25fb55937efe2f7ffdd6302bbe6d6926caeed70a10a,\n                0x0fea7bbcfbdca10018a0bc6dbf81bae027f12ce721d68b8a6fbd345f564e8c63,\n                0x0ae4518b024d662df03438a13507afdcded21346938c502e5f6fb6cc3eb660ac,\n                0x27007a4792c9d5fb181500ad4c516dda340d96762e0b6326a5d1ff5a4b3b5bca,\n                0x0956ad62323a65c3ba1d1c4ffa34e0401c9d29993a59ad0f4c063b0f8129c3b9,\n                0x2d854411c11ffcf486ce7d6f458782afc80cf2eac1104b605aefa8f7b1eb4392,\n                0x1f4a4de11c6554fb2575b17f7ccb63bdc465ae8db1dadaf6da09f9881a904e9d,\n                0x0c4ce5037da00596b60762c0299771d6c1f3c3ae77d47caa177050c5e655b323,\n            ],\n    );\n    assert(\n        x5_16([\n            0x2d68b06ac8a6c173e6c3973ba865a74dffe3294bff9d0a000f0e48c743f7e5b6,\n            0x11a9b30e033e2e4f6d9953273ea2b0c334dc0d3f0548ee1480ddb8089cecab4d,\n            0x2c8863dd10933bfe3670a9f4626056b32d12c85064b06f69ac6f20b8fd2c3160,\n            0x044d774b22af32615ea0d456d6da216c1ed077b96e363bad69fbe72d45220069,\n            0x218a83e6f91618448f25852a405e540302d5b28719a11491b1ce1bd26997614b,\n            0x286ee17de5be4fe8bd04522619f5624d8e115daeea42237d2beb5e98de6a015b,\n            0x211481e4b0452fc24fdefbb1c1a5f1135816e16b02291c1d88ed3a94b830c9b5,\n            0x1f0d0f9d07e1dfe6471a3772a74b4cc3da80d771fa1a34558c52769ded61f838,\n            0x15b13d0d6834a8794655db51720dcc9c7b454fb2ff919e52767fed602eaf00ba,\n            0x2802cf4fa69f1bca58dc8197bc3aa601022546375f1503964f33727eb610d03b,\n            0x18c298e8be0426a033d82eb001fe15d623867737ddd036ba66508982d02cc8e0,\n            0x153f39a3285da9162d7bd51d5ce90bf0b6c0c1b56943ef4ea1dbb3e0edba079f,\n            0x09e4d973fe24511b29d3ff119362d6fe3f8c545ba0203b2fc2f5b2332b6af67b,\n            0x183c4791f6af7b260faef4dee944dbd032b7a6b36ce6db1dafe39a68581b05da,\n            0x0fecff05819aef06b229c4c9c45303caab0b6a10ef21b2c78ff4335777a950b4,\n            0x2fd2a822e9dad5b1bbf05c48a646fb3baf8fa569ea56b5095f9932c478b402e9,\n        ])\n            == [\n                0x00e7985063474e552a70ee705434a9cb8ad5fd3332081ca7ea29cc2e04736443,\n                0x0bb32611f7a673adaf873ecf44903c4683fdf054c7991868b60986a3fc2434e1,\n                0x2a34a647e4399d41bd6d56b18455e55472e9a3d0b8891ebebb4cb195f1805818,\n                0x1df3d37d4594605755b6db26c7c491f90b166c97e0e2e272947964a406123931,\n                0x296720f19be76efa3be6247b0cb47b5da39a5720f2da232d48be8898c24c644b,\n                0x2f3d7fe8e710de783b56b53b924e1721d80f2f278fbd4a8237dcef5106054295,\n                0x1163dfa4447a370bf32a35ba50ebe6b891c79ec77eace1c189e7122391dd7692,\n                0x2dee066e4cb642e4c36622c7709d56be8e0d4e085edb8504a03b886e5243d9a2,\n                0x20968bd0e88eddb3223fbaa9a4ade0da528774a350851631400da87726794b29,\n                0x22363da61fcced4f9abdbaa90adaee6fba2971e3a2a0e79a2e6f1677b402bab9,\n                0x2b0b7eb2a75f97a809fa1300193648a3d018fdbf879ad078789190ba39d5eef4,\n                0x0a635c902e1d0e7f0b9200babbc49fe779db22445399e372faab05b95a5b0462,\n                0x2af2db88a9a4093bd91bbef603d279ce7ba9fe39da2fb8e43d8640c123c5e91c,\n                0x0389be83959d40d19b73060cf322298ab5031761f18ae2e8ef537b6ea44ab19b,\n                0x2a77063695be741137fa3933536515607abde3f7704a644f763eb7e609e1a78c,\n                0x191a8fa7d5bbdd528c0ea7878e0c731ece9cc1e6e5cc0a6abaab4ae0caf0f769,\n            ],\n    );\n    assert(\n        x5_16([\n            0x26fcf669c5d648ed59490ddca7bbe354b02b4b3ce3413abf45bcc763632216ad,\n            0x217c47cd62feb6c1858beb1af22a9520f7e7dbcef978235471c0255f789fdc63,\n            0x0c9847f7f873b8730c65861cc42a77de4d2a863b853b146c7ee7e3241d9e9f09,\n            0x2bd4ceea8f15ca63bb3e9a0513fff8e0386ab82a2ff7e58cb42e528f5873ae4a,\n            0x2064aaaf465b56437ae42ef30be0970d48508b9ba52aa11da7bc197ea7762df4,\n            0x03faf493e27a84593a1659730c1c124c9b0dc0c9c4a18db3c72ea927ad14b11d,\n            0x13aac7c7b4ea5d86003dcc4b744a058eeb0ab360447e7ff9c8418f6f6e508cc7,\n            0x1775eec665148054cdaa7657b3389473dae36b6c01ab64f18656ae00de9489b0,\n            0x1901be4b7481ff0c8964fa2c77794b164a2e43aed5e36c2c6ccd8f8191c94873,\n            0x2784dc417a5202f66f681f7d4c356dfb01c9522f8ce5eb63c9fec159f3402c86,\n            0x0f6efebb5fd0520b3daa0097aac54c42314945ec6fc96cf5f2f5aeaa191f652d,\n            0x1dba0aebaef806f37235faa2cf8fbdae9da9763cb3d9a6838fcff82ca527d437,\n            0x163d27405b027e50d35bf55eb6431cb75350ffc44eed52185b403b39d5b30b18,\n            0x030735bcca423d70e78a04a53d3a4e728ad28efdc5ceb2f0628937cdadb0ab5e,\n            0x00543427a4899ec4c8756511dc295bc07839445eff4a448ceb3f0480a9f9585e,\n            0x1235ce720c56b2590126a1057c953bee0810f2c9acb12c4b01bb5d9c2bd9bbd5,\n        ])\n            == [\n                0x2824245824515d822c894f4c63e85aa06e957089b7204e11f1b45b4d0c2a6b93,\n                0x0c4a5cc6128bf7d5b1af586ef4c8e8ec1d3258030df4bf9d8c8f169940a8ab46,\n                0x2cdbbc6158e398a4cdbef4b3bc9c6a8ffad29713423d7130d866fd33e046d76c,\n                0x2feae397ccab260ab856007290e7f08c7f04cd1ceeac8b8c31cca55340550b6e,\n                0x14018fd8912b3e30321df757fb6af8e8aea684f2a41663f1aee7e3cad04fb27d,\n                0x15e89fd27ca5fdbd3cf6b39f4a5515f986554ccbf7bc52803a5c989efe392c55,\n                0x1b8cc493266cf81639c10391213e5f822c348991965bbe07b5c9c3e5f78f677c,\n                0x07453d273cfa90c10d4c8e22c77e5bca6c56c0cae0ae1a324dda13615929e2f4,\n                0x01ed8c8bf6308a7a4edbff5280b09d72a74579c3e1d300cfa1432192c240564b,\n                0x1ac754480d4b218c33d23a9264406d16faf30279c3db2fa2b1e1e9e024ae74e8,\n                0x236c9c959c107f7908a670c8a4df73a6487920f5ad811bf06a1dd2c798d7c88a,\n                0x29bf91f77f69fa46f5d605c5bdb40567070a7b45ef6c30ea9c47249829e75915,\n                0x233cb5f0b7bd3b55b11270311018acdde7b7c61a3bbb2ddecc3c61f10d7080f3,\n                0x22082ab254896b3c8d771dc14c9e834878797a505a5ea83e2b624811ec0ba67e,\n                0x09c5e4ca4cb94aa5cd0006b14b62ee34aa916e69c9f52bad52e6b4c4a3b102f7,\n                0x0b6bafed1b7f470294a95eed0c44cc35c87480f167115cad591995e62c069357,\n            ],\n    );\n    assert(\n        x5_16([\n            0x1f30f9fbd02de3245ffa2a842a35c503836cdf7bd91b7bc81eef191c0ed00d91,\n            0x23ef9c7a64ae98919c4aebd890beef09ff5d1b450e3ed7a690a3e6067755101c,\n            0x0a941ca919639269ce0f274572c3bd82ab586684c14f46d648d7ebeb98795354,\n            0x115ac08664baf4020b32a68d9bf3e040e87c1672954d2601bc477121936ceb0c,\n            0x20b24021688034db1d514a2dc2eb17f02eea63e5805efd68ecebd59783d5c13b,\n            0x1802b6eed394a6f2c054a1b1cbf33c842f97ab9a6ec03fd0aeb1b7cced9077db,\n            0x14ef482e31c50bffcc62b1e4d9013f30df6bc380a2b0896fe4e483b4c18c3990,\n            0x130fa7ff2494fdf702c1fc076fb0315917add56464217960bdcdf17162d8e9fe,\n            0x2ecdfab787c80b25dd05f2ba55f49fc6c7817eeda780e464239c99cfb03e445c,\n            0x100c0d9bf6a2384940dcd88e1553609a9480c032b3be8820a3e534544de505fc,\n            0x1ef6e0c3b8d177b3a13f7af721af9d13d4043ea3ff248d4bc155639fce11867c,\n            0x2c9302b8df110fec10b69a6436f2e7cce058e8fb10de6166f2dc7dcd9e717440,\n            0x242411f186e4dd6761a58a115fc4a12a72afe15ab2a8cba314bb36c3af628485,\n            0x27f6a9b6ae28fbf5ef658e8a8d7548578c2321be2fe7d8e61437358c27313bb1,\n            0x2e6b453486b8154a925a8d8f6343d70e3e7b3cf8ae5f98fe5dad385caf3a5b6d,\n            0x251a976a3bb9b67f9c5ce1633ae24fc78d8556949fe699b89b4a496ca8fd33ca,\n        ])\n            == [\n                0x2f73ecbfd328236b62a0de2f90fda6aa39027d2445904729de2cbb132f04eef7,\n                0x2e3b0e241e80ecb5c94599ef79b36384d50924dd78b29d136a78ba8dd4eac3e4,\n                0x240e35568bcf3d794be5b658207a13f30d3be889e85b735a5658c1e8ad8ecd06,\n                0x08f9a03ac71ded3712140d95fb4d84b6247f6ed3f005edc22c11c5749dcce0bb,\n                0x23d19806e8344c08f772bf1e4e6abb068bbe34f262a9e8e4dd1dd87cccfa76b9,\n                0x1d43aa80b45193c0fd0e0ffc51217feb505c0127558bfc4d60f8640a2f799225,\n                0x22bd86bb51b7941c6aeb8905d680a9f2b5d073cee1d72171aad90ee25f07d2f3,\n                0x21acac96adb169d04127c7ad9074753b49ce0ad68d1ecd4be803c7a7bd75049c,\n                0x2d3ccbacd3110045e3d7dda3a9c0114f03fcbbcefb5bf2b864627fa7e015c026,\n                0x0ecd348155a751f395a2c867f4f82a6e2e6a0e549784c3da3c6defd3ed8d2593,\n                0x17cd880e932fc4490b11b73a32e741052df57fd9b563f94192f0dada59fa7eeb,\n                0x0507ec99efeb586fa4a628563ad4c18d92a9ac3f3b69bbffdaad18c43a37c774,\n                0x22ba5e12ee0de1a7db0cf232639db2006be109a47dfd591f9ad4745844b28985,\n                0x0103ad1ccfccb7097c13a71f89d806294a355a4e0e24e9d7d353fa27a60599ed,\n                0x0a2744a2b3f1a1e9f0e365f195dc7bfb2becce17d346623407b68f2be38e6840,\n                0x1a10bad64f9099c918f1e3a713b34d43c9c8442eca37ac2be2933ef06a85f274,\n            ],\n    );\n    assert(\n        x5_16([\n            0x102aaf737cf6e4eded17a778873de94a33432c19f78c93ff6a438b54503073e6,\n            0x010ccff329d1680eb37dc0a14d1df9ecb51b563fbbe8e02f4b973a6d7c5a3ad9,\n            0x1c80734fefdf741d96d23dd5c9494a69eca35ad4c52e6781fe64fec042a39034,\n            0x1fd6d6a936a506af5a88f4efbcf6bacdaf166e18c1a9d9ec2706097e049a48d8,\n            0x0fcd3cf6478e2303fd67a88e8da308c99c6b034b9d9e8505a5cdb1f1328ac19f,\n            0x00a894f3228b2f40329bce6db4aed140044ca13388fe31dbeb7e920c47626b98,\n            0x05627ce9f83ba4ec21200390b4459d20a841b7b6bff58f54f859746e6a1a5bad,\n            0x1a6d68c2e6da0187cc187f14fd60d574347ee8e3b2e6d5377ca28d1c2126d579,\n            0x0796ff0b481621f97e6205b7098b3f34d9e25ce2a568823d34960d10675abe00,\n            0x1658c8c71f79eb8c1cbed9176d3fced3f102f6f3185c0086ca281621421ea687,\n            0x17b29467b557e95e2c98a68a62ae669bfea7e60f6f4b5c6c748536606f9559dd,\n            0x2db966ef0090e9b6b5e8bb41890ed54469beac546172968de44ac4fe1c91fc57,\n            0x116734a408c7898e7c14361cb189db728557f6cc7bf643ead36f46387e474105,\n            0x278912d4acb55f15c263054ee5961722234b0e8fc257d8afe3f55cd707fa8450,\n            0x2a3dbf10426ec43bd82e1aef23553b695b1a9d2339a99ec299649fdd128c7ffb,\n            0x1431dae2b608ec8aff9dbeabfaef7bbabb7a990241b2d2cb84d2b16b474dbec4,\n        ])\n            == [\n                0x04421416d3b0398c2089bea526a32fb66d78da31fb45bd5f1586fd52303adeb7,\n                0x1d8195ae558ec24145f22963dbe020eb9eb32f9b77993dee1a6651de4e043d6b,\n                0x065012470d069eafbdbe2e9472843e570a6c4bec2bff368a7e5177ace65cd7aa,\n                0x28293baa71d7e924399a38aa199be1886bef192b9bd170f4b5061cc266cce797,\n                0x1bf0bff909c28f440eb3a7b2fb48f3b58d30e7e35126eb4c8eb9dabdf4173caf,\n                0x006e32aafe5fc019cf7f2121640ed5877695317872900b005821e902855cb9e2,\n                0x077ce2784361c15f00bd94be5923b0d423e690a51427b82ac6da1bc3e15ff202,\n                0x04bec35d3bfe48abc26f1b213b37a46a6837ea4ef4c7c66aec7d6ec506b4816e,\n                0x09891cb5c5f97bfb53df6fa616a15454a20d2d9d4b1730b143b80603f1d2ead8,\n                0x2d2049ee1c7ade77d7f24e30d79274e6d4b65e32ca00485efbe7fcabe880ecdf,\n                0x0f3f82629e5571fa2d37501eb2c42ff2532b23dfa8b60a250406aea842752891,\n                0x154b6ac1520182ff79d85376c19f8c622c251762b269deae81db64257c3f8853,\n                0x092ebf535121a0cd3342dbf040e69031c5ee7f73a46cba5d7077cc40f1fe7623,\n                0x2e013478205cbe8b6c9315e2fe24374e6954b13a121f84a046656defd81b6aa7,\n                0x14899d106105b55a748e7b8180c6cc6ce1a1700dd723a182ad421bee03bea38d,\n                0x15a2465a074528248166bd7ab12dd8c1f7b0a523acf560393fb53cad0f9ff4a7,\n            ],\n    );\n    assert(\n        x5_16([\n            0x2c8251563bf2daf3832f54b41e1019e416f097fff0185b8972a24baab0041945,\n            0x1c5af36107dd27a50ed1b7be11fecc96955c940f7d1e8d85c73b55d2a72636cd,\n            0x0c2745de6e816df7564b63085fb2bbfac5b7901f3bea6c06527fc367886f25ff,\n            0x19019d42f79fd8654f69436c8230120b91d81a74a2c54a2b99b65b1104a4f855,\n            0x0beab5f110eba2ed3e125e96f33173ce8c969ab78b3ca023c1bcc765ce5df31f,\n            0x11d9b237b412ffd1a2a9d9ddddcf8eb725222a138a12d7dcfdca0856b2048c89,\n            0x1c448b112e517ee96e6ac2f8593f51ddcfea072bf6ad1d117e9072a8084c6a21,\n            0x095dfcdc5f3bb500206ed7fcd09ce1db8a89087a1767dfadf94b1d4a8719ecff,\n            0x2b83981c4547a9a91ddcf3e3d415c6a229e5b79c0194faa17a79fec0c7656625,\n            0x0dfc540c74084bd916dca0116e701424bbb4255575d997ac0980124380c79cba,\n            0x1ee3fd68c5face1c3bde5cc8a09820cf0d55e20c354006d5a1e7c17502fada01,\n            0x1731821cf372f905084ef42395e5cf7377b8e845539fbe75d431c460efb52f56,\n            0x095dd1057519b92facabf3d1bf4cfd9cfba721f13777ee1b156a94982aa0ea92,\n            0x09d8c656b448b642be7e5ba2820cde88395ee99c1609fc57a10e1a761bcec40e,\n            0x2cefff7d3c2d8de4caa6555ef6fe2d20ea75ab55295cd3d422f1e7706d00265b,\n            0x2af9da783cf3f2cdb98d1d0db2d46b500ab16b22d528c3290f9fa61a16e90c77,\n        ])\n            == [\n                0x045fd3534e4e3a441672b2174823a1b0f2bf33744dcedd04decafac412491ba5,\n                0x2e26d947a155dc04da57a4e2d08ff2789601da31999bd3d2d509ce74336db980,\n                0x252121c4d1f937e2a2bbf228252e3d5970b693269061b30ec67a7f46ce4eb28c,\n                0x13461512448fa47d7c334f17166a9791c79b0c7c744b5ec85b944fbcf3b8b364,\n                0x1e00352c73e0c20163f184f610dbc509b6a60e5b6df8636b2e238ea0867004be,\n                0x2256f5718367f8eb6730eb4a3bb0cc69a539b7c5d2e156212944f2f974693159,\n                0x243fc53f1ef63853cb507d4354c41153690522215a975a3b6bbd3f039ee91f71,\n                0x025aa431a3197a94e85c1390f0ae568c6aff20657428413bd8fd636b5db7e457,\n                0x1932edb2b21bf6cba1f674b00b70f923fee4a222872c1858559a60fe33e7baa9,\n                0x2ea0e86e9b5f04901a072c94cdc9c04c512acbc3da27e41a364ce5d4586166f5,\n                0x1b1c638d7c7637ba8a0732f02aa3666dd61c9aa502bc4bc78f4ce8fcc8c0599b,\n                0x2fabaf28f4bb95ee4f11593906d38519054372938ba6ce3be2a3227064ba5104,\n                0x1ec7790f18b886f8806f9865a1b047532fdde00a429656cb02532a1c77d6ff90,\n                0x28535227e19514f1ab220db019b2933cce0670c1c7439bda9aac0daaf63b086e,\n                0x14226659240668ad038136362481d9b9870d4ad6ab62e73bef74ed2ab66429c2,\n                0x0eae0bc0112d05992ae574f1b33f08f5a5bcd3092a6ec79c917effa908fa511f,\n            ],\n    );\n}\n","path":"/home/gruber/nargo/github.com/TaceoLabs/noir-poseidon/v0.5.0-beta.0/poseidon2/src/bn254/perm.nr"},"60":{"source":"mod consts;\npub mod perm;\nuse dep::hash_utils;\nuse dep::hash_utils::poseidon;\n\npub struct Poseidon2Bn254Config<let T: u32, let R: u32> {\n    first_full_rc: [[Field; T]; 4],\n    partial_rc: [Field; R],\n    second_full_rc: [[Field; T]; 4],\n}\n\nfn permute_bn254<let T: u32, let R: u32>(\n    mut state: [Field; T],\n    mm_external: fn([Field; T]) -> [Field; T],\n    mm_internal: fn([Field; T]) -> [Field; T],\n    config: Poseidon2Bn254Config<T, R>,\n) -> [Field; T] {\n    state = mm_external(state);\n    for r in 0..4 {\n        state = hash_utils::vec_add(state, config.first_full_rc[r]);\n        state = poseidon::sbox(state);\n        state = mm_external(state);\n    }\n\n    for r in 0..R {\n        state[0] += config.partial_rc[r];\n        state[0] = poseidon::sbox_e(state[0]);\n        state = mm_internal(state);\n    }\n    for r in 0..4 {\n        state = hash_utils::vec_add(state, config.second_full_rc[r]);\n        state = poseidon::sbox(state);\n        state = mm_external(state);\n    }\n    state\n}\n\n#[field(bn254)]\npub fn hash_1(input: [Field; 1]) -> Field {\n    perm::x5_2([input[0], 1])[0]\n}\n\n#[field(bn254)]\npub fn hash_2(input: [Field; 2]) -> Field {\n    perm::x5_2(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_3(input: [Field; 3]) -> Field {\n    perm::x5_3(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_4(input: [Field; 4]) -> Field {\n    perm::x5_4(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_8(input: [Field; 8]) -> Field {\n    perm::x5_8(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_12(input: [Field; 12]) -> Field {\n    perm::x5_12(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_16(input: [Field; 16]) -> Field {\n    perm::x5_16(input)[0]\n}\n","path":"/home/gruber/nargo/github.com/TaceoLabs/noir-poseidon/v0.5.0-beta.0/poseidon2/src/bn254.nr"},"63":{"source":"use crate::double;\n\n#[field(bn254)]\npub fn sbox<let T: u32>(mut state: [Field; T]) -> [Field; T] {\n    state.map(|x| sbox_e(x))\n}\n\n#[field(bn254)]\npub fn sbox_e(mut x: Field) -> Field {\n    let mut result = x * x;\n    result *= result;\n    result * x\n}\n\n#[field(bn254)]\npub fn mds_2(state: [Field; 2]) -> [Field; 2] {\n    let sum = state[0] + state[1];\n    [sum + state[0], sum + state[1]]\n}\n\npub fn mds_3(state: [Field; 3]) -> [Field; 3] {\n    let sum = state.reduce(|a, b| a + b);\n    let mut ret_val = [0; 3];\n    ret_val[0] = state[0] + sum;\n    ret_val[1] = 2 * state[1] + sum;\n    ret_val[2] = state[2] + sum;\n    ret_val\n}\n\n#[field(bn254)]\npub fn mds_4(mut state: [Field; 4]) -> [Field; 4] {\n    let t_0 = state[0] + state[1];\n    let t_1 = state[2] + state[3];\n    let t_2 = double(state[1]) + t_1;\n    let t_3 = double(state[3]) + t_0;\n    let t_4 = double(double(t_1)) + t_3;\n    let t_5 = double(double(t_0)) + t_2;\n    state[0] = t_3 + t_5;\n    state[1] = t_5;\n    state[2] = t_2 + t_4;\n    state[3] = t_4;\n    state\n}\n","path":"/home/gruber/nargo/github.com/TaceoLabs/noir-poseidon/v0.5.0-beta.0/hash_utils/src/poseidon.nr"},"64":{"source":"mod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/gruber/nargo/github.com/colinnielsen/ecrecover-noir/colinnielsen-patch-1/src/lib.nr"},"65":{"source":"use dep::keccak256;\nuse dep::array_helpers;\n\npub struct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = keccak256::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/gruber/nargo/github.com/colinnielsen/ecrecover-noir/colinnielsen-patch-1/src/secp256k1.nr"},"68":{"source":"mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/home/gruber/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"},"70":{"source":"use babyjubjub::{BabyJubJubPoint, hash_to_curve::encode};\n\n// Generates the blinded query proof point b_q = encode(client_input) * beta, where beta (the blinding randomness provided by the client) is already given in bits (generated via BabyJubJubPoint::validate_scalar_field_with_bits(beta)).\n// The client_input is the input known only to the client, which is encoded to a curve point via the encode() function from the BabyJubJub hash_to_curve module.\n// For further details we refer to https://github.com/TaceoLabs/oprf-service/blob/main/docs/oprf.pdf as well as an implementation example in oprf_example/src/main.nr\npub fn blinded_query(beta: Field, client_input: Field) -> BabyJubJubPoint {\n    // Validate that beta is non-zero and get its bits\n    assert(beta != 0, \"Beta cannot be zero\");\n    let beta_bits = BabyJubJubPoint::validate_scalar_field_with_bits(beta);\n\n    blinded_query_inner(beta_bits, client_input)\n}\n\npub fn blinded_query_inner(beta_bits: [u1; 251], client_input: Field) -> BabyJubJubPoint {\n    // Encode query to curve point and perform scalar multiplication\n    let (px, py) = encode(client_input);\n    // Precondition: encode returns a valid point on the BabyJubJub curve in the prime order subgroup\n    let p = BabyJubJubPoint::new(px, py);\n    // Return the blinded (encoded) query point\n    p.scalar_mul_bits(beta_bits)\n}\n\n#[test]\nfn oprf_query_kat_test() {\n    let beta = 1219447978145766874721695300216900264892278162307712369438981445355514609028;\n    let client_input = 387242419257851558984914892096106188402994395767663340643461644969954908901;\n    let expected = BabyJubJubPoint::new(\n        9674018812144873985515234638873635008708834681175738612597888298086191498827,\n        18818965079786157878748649151755578492493325229415754584538271947197071123195,\n    );\n    let result = blinded_query(beta, client_input);\n    assert((result.x == expected.x) & (result.y == expected.y), \"OPRF query test failed\");\n}\n","path":"/home/gruber/nargo/github.com/TaceoLabs/oprf-nr/main/oprf/src/blinded_query.nr"}},"expression_width":{"Bounded":{"width":4}}}