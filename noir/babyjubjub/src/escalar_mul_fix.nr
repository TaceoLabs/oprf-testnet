// Fixed-base scalar multiplication using windowed method
// Based on Circom's EscalarMulFix implementation
// Reference: https://github.com/iden3/circomlib/blob/master/circuits/escalarmulfix.circom

use super::BABYJUBJUB_Fr;
use super::BabyJubJubPoint;
use super::montgomery::MontgomeryPoint;
use super::window_table::{generate_window_table, generator_window_table, select_from_window};
use std::static_assert;

// Function to perform fixed-base scalar multiplication on a segment of bits,
// This needs the bits + the initial generator table, generated by generator_window_table() for G or generate_window_table(current_base)
fn segment_mul_fix_generator<let N: u32>(
    bits: [u1; N],
    generator_table: [MontgomeryPoint; 8],
) -> (BabyJubJubPoint, MontgomeryPoint) {
    // Ensure segment size is within valid range
    // Copied below is the comment from circomlib explaining the reasoning
    // This ensures that the Montogomery adders never receive identical points or zero points as input, as long as the base is not the identity point.
    /*

    The scalar is s = a0 + a1*2^3 + a2*2^6 + ...... + a81*2^243
    First We calculate Q = B + 2^3*B + 2^6*B + ......... + 2^246*B

    Then we calculate S1 = 2*2^246*B + (1 + a0)*B + (2^3 + a1)*B + .....+ (2^243 + a81)*B

    And Finaly we compute the result: RES = SQ - Q

    As you can see the input of the adders cannot be equal nor zero, except for the last
    substraction that it's done in montgomery.

    A good way to see it is that the accumulator input of the adder >= 2^247*B and the other input
    is the output of the windows that it's going to be <= 2^246*B
    */
    static_assert(
        N <= 246,
        "Segment size must be <= 246 bits, otherwise the base wraps around, which can cause issues such as add being called with identical points.",
    );

    // Calculate number of windows (each window is 3 bits)
    let num_windows = (N + 2) / 3;

    // Track current base (starts at generator, becomes 8*G, 64*G, etc.)
    let mut current_base = generator_table[0]; // 1G

    let mut window_outputs: [MontgomeryPoint; 82] = [current_base; 82];
    let mut bases: [MontgomeryPoint; 82] = [current_base; 82];
    let mut actual_windows = 0;

    // Phase 1: Process each window
    for i in 0..num_windows {
        if (3 * i) < N {
            let table = if i == 0 {
                generator_table
            } else {
                generate_window_table(current_base)
            };

            // Extract 3 bits for this window
            let bit0 = if (3 * i) < N { bits[3 * i] } else { 0 };
            let bit1 = if (3 * i + 1) < N { bits[3 * i + 1] } else { 0 };
            let bit2 = if (3 * i + 2) < N { bits[3 * i + 2] } else { 0 };

            let window_bits: [u1; 3] = [bit0, bit1, bit2];
            let selected = select_from_window(window_bits, table);

            window_outputs[i] = selected;
            bases[i] = current_base;
            actual_windows = i + 1;

            current_base = table[7];
        }
    }

    // Phase 2: Build compensation chain
    let mut compensation = bases[0];
    for i in 1..actual_windows {
        compensation = compensation.add(bases[i]);
    }

    // Phase 3: Add extra doubling for safety
    let doubled_last_base = current_base.double();
    compensation = compensation.add(doubled_last_base);

    // Phase 4: Build accumulator chain
    let mut accumulator = doubled_last_base;
    for i in 0..actual_windows {
        accumulator = accumulator.add(window_outputs[i]);
    }

    // Phase 5: Convert to Edwards and perform final compensation
    let acc_edwards = BabyJubJubPoint::from_montgomery(accumulator);
    let comp_edwards = BabyJubJubPoint::from_montgomery(compensation);
    let result = acc_edwards.subtract(comp_edwards);

    (result, current_base)
}

// Fixed-base scalar multiplication for the BabyJubJub generator point
// Uses windowed method with precomputed table internally
// soft precondition: scalar < BABYJUBJUB_Fr
// hard precondition: scalar < 2^251
// Returns: BabyJubJubPoint = scalar * G
pub fn generator_mul_fix(scalar: Field) -> BabyJubJubPoint {
    let bits: [u1; 251] = scalar.to_le_bits();
    // split bits into two segments to protect against overflows in the field
    let mut bits_0: [u1; 126] = [0; 126];
    for i in 0..126 {
        bits_0[i] = bits[i];
    }
    let mut bits_1: [u1; 125] = [0; 125];
    for i in 0..125 {
        bits_1[i] = bits[i + 126];
    }
    let generator_window_table = generator_window_table();
    let (result_seg0, current_base) = segment_mul_fix_generator(bits_0, generator_window_table);

    let generator_table_seg1 = generate_window_table(current_base);

    let (result_seg1, _) = segment_mul_fix_generator(bits_1, generator_table_seg1);

    let result = result_seg0.add(result_seg1);
    result
}

#[test]
fn test_segment_mul_fix_small() {
    let g = BabyJubJubPoint::generator();
    let bits: [u1; 3] = [1, 0, 1];
    let generator_window_table = generator_window_table();

    let (result, _) = segment_mul_fix_generator(bits, generator_window_table);
    let expected = g.scalar_mul(5);

    assert(result.x == expected.x, "segment_mul_fix_small: x mismatch vs scalar_mul(5)");
    assert(result.y == expected.y, "segment_mul_fix_small: y mismatch vs scalar_mul(5)");
}

#[test]
fn test_segment_mul_fix_medium() {
    let g = BabyJubJubPoint::generator();
    let bits: [u1; 9] = [1, 0, 1, 1, 0, 0, 0, 1, 1]; // 397 in LE

    let generator_window_table = generator_window_table();
    let (result, _) = segment_mul_fix_generator(bits, generator_window_table);
    let expected = g.scalar_mul(397);

    assert(result.x == expected.x, "segment_mul_fix_medium: x mismatch vs scalar_mul(397)");
    assert(result.y == expected.y, "segment_mul_fix_medium: y mismatch vs scalar_mul(397)");
}

#[test]
fn test_escalar_mul_fix_basic() {
    let g = BabyJubJubPoint::generator();

    // Test zero scalar
    let result_0 = generator_mul_fix(0);
    assert(result_0.is_identity(), "generator_mul_fix(0) should return identity point");

    // Test identity scalar
    let result_1 = generator_mul_fix(1);
    assert(result_1.x == g.x, "generator_mul_fix(1): x mismatch vs generator");
    assert(result_1.y == g.y, "generator_mul_fix(1): y mismatch vs generator");

    // Test small scalar
    let result_5 = generator_mul_fix(5);
    let expected_5 = g.scalar_mul(5);
    assert(result_5.x == expected_5.x, "generator_mul_fix(5): x mismatch vs scalar_mul(5)");
    assert(result_5.y == expected_5.y, "generator_mul_fix(5): y mismatch vs scalar_mul(5)");

    // Test large scalar
    let large_scalar = 123456789;
    let result_fixed = generator_mul_fix(large_scalar);
    let result_basic = g.scalar_mul(large_scalar);
    assert(
        result_fixed.x == result_basic.x,
        "generator_mul_fix(123456789): x mismatch vs scalar_mul",
    );
    assert(
        result_fixed.y == result_basic.y,
        "generator_mul_fix(123456789): y mismatch vs scalar_mul",
    );
}

#[test]
fn test_optimized_generator_mul_fix() {
    let g = BabyJubJubPoint::generator();

    let scalar = 5;
    let result_optimized = generator_mul_fix(scalar);
    let result_regular = g.scalar_mul(scalar);

    assert(result_optimized.x == result_regular.x, "optimized vs regular: x mismatch for scalar=5");
    assert(result_optimized.y == result_regular.y, "optimized vs regular: y mismatch for scalar=5");

    let large_scalar = 123456789;
    let result_opt_large = generator_mul_fix(large_scalar);
    let result_reg_large = g.scalar_mul(large_scalar);

    assert(
        result_opt_large.x == result_reg_large.x,
        "optimized vs regular: x mismatch for large scalar",
    );
    assert(
        result_opt_large.y == result_reg_large.y,
        "optimized vs regular: y mismatch for large scalar",
    );

    let very_large_scalar = BABYJUBJUB_Fr - 1234567890;
    let result_gen = g.scalar_mul(very_large_scalar);
    let result_opt = generator_mul_fix(very_large_scalar);

    assert(result_gen.x == result_opt.x, "regular vs optimized: x mismatch for scalar=5");
    assert(result_gen.y == result_opt.y, "regular vs optimized: y mismatch for scalar=5");
}

#[test]
fn test_segment_mul_fix_generator() {
    let bits: [u1; 9] = [1, 0, 1, 1, 0, 0, 0, 1, 1]; // 397 in LE
    let generator_window_table = generator_window_table();

    let (result_opt, _) = segment_mul_fix_generator(bits, generator_window_table);
    let result_reg = BabyJubJubPoint::generator().scalar_mul_bits(bits);

    assert(result_opt.x == result_reg.x, "segment_mul_fix_generator: x mismatch for bits=397");
    assert(result_opt.y == result_reg.y, "segment_mul_fix_generator: y mismatch for bits=397");
}

#[test]
fn test_segment_mul_fix_generator_by_char() {
    let id = generator_mul_fix(BABYJUBJUB_Fr);
    assert(id.is_identity(), "generator_mul_fix(BABYJUBJUB_Fr) should return identity point");
}

#[test]
fn test_segment_mul_fix_generator_by_minus_1() {
    let minus_1 = BABYJUBJUB_Fr - 1;
    let id = generator_mul_fix(minus_1);
    let minus_generator = BabyJubJubPoint::generator().negate();
    assert(id.x == minus_generator.x, "generator_mul_fix(-1) x should match generator");
    assert(id.y == minus_generator.y, "generator_mul_fix(-1) x should match generator");
}
